<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"https://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="https://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>2016 ObjectOrientedについて</title>
<!-- 2016-12-11 日 19:09 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="suzuki@cis.iwate-u.ac.jp" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://wiki.cis.iwate-u.ac.jp/~suzuki/org-html-theme/styles/sos/css/sos.css">
<link rel="stylesheet" type="text/css" href="https://wiki.cis.iwate-u.ac.jp/~suzuki/org-html-theme/styles/bigblow/css/hideshow.css"/>
<script type="text/javascript" src="https://wiki.cis.iwate-u.ac.jp/~suzuki/org-html-theme/styles/bigblow/js/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="https://wiki.cis.iwate-u.ac.jp/~suzuki/org-html-theme/styles/bigblow/js/jquery-ui-1.10.2.min.js"></script>
<script type="text/javascript" src="https://wiki.cis.iwate-u.ac.jp/~suzuki/org-html-theme/styles/bigblow/js/jquery.localscroll-min.js"></script>
<script type="text/javascript" src="https://wiki.cis.iwate-u.ac.jp/~suzuki/org-html-theme/styles/bigblow/js/jquery.scrollTo-1.4.3.1-min.js"></script>
<script type="text/javascript" src="https://wiki.cis.iwate-u.ac.jp/~suzuki/org-html-theme/styles/bigblow/js/jquery.zclip.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://wiki.cis.iwate-u.ac.jp/~suzuki/org-html-theme/styles/bigblow/js/hideshow.js"></script>
<script type="text/javascript" src="https://wiki.cis.iwate-u.ac.jp/~suzuki/org-html-theme/styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://wiki.cis.iwate-u.ac.jp/~suzuki/org-html-theme/styles/sos/js/hideshow.js"></script>
<script type="text/javascript" src="https://wiki.cis.iwate-u.ac.jp/~suzuki/org-html-theme/styles/sos/js/sos.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">2016 ObjectOrientedについて</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. オブジェクト指向に至る軌跡</a>
<ul>
<li><a href="#sec-1-1">1.1. オブジェクト指向以前</a>
<ul>
<li><a href="#sec-1-1-1">ソフトウェア危機</a></li>
<li><a href="#sec-1-1-2">構造化プログラミング</a>
<ul>
<li>
<ul>
<li><a href="#sec-1-1-2-0-1">Todo 構造化プログラミングとは</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-1-1-3">モジュラプログラミング</a>
<ul>
<li>
<ul>
<li><a href="#sec-1-1-3-0-1">凝集度と結合度</a></li>
<li><a href="#sec-1-1-3-0-2">悪い結合、良い結合</a></li>
<li><a href="#sec-1-1-3-0-3">悪い凝集、良い凝集</a></li>
<li><a href="#sec-1-1-3-0-4">状態と副作用の支配</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-1-1-4">抽象データ型</a>
<ul>
<li>
<ul>
<li><a href="#sec-1-1-4-0-1">抽象データ型の情報隠蔽とカプセル化</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-1-2">1.2. オブジェクト指向?</a></li>
<li><a href="#sec-1-3">1.3. Simula &amp; C++のオブジェクト指向</a>
<ul>
<li><a href="#sec-1-3-1">どの処理を呼び出すか決めるメカニズム</a>
<ul>
<li>
<ul>
<li><a href="#sec-1-3-1-0-1">動的ディスパッチ</a></li>
<li><a href="#sec-1-3-1-0-2">継承と委譲</a>
<ul>
<li><a href="#sec-1-3-1-0-2-1">継承</a></li>
<li><a href="#sec-1-3-1-0-2-2">委譲</a></li>
</ul>
</li>
<li><a href="#sec-1-3-1-0-3">オブジェクト指向の要素</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-1-4">1.4. Smalltalk &amp; Objective-Cのオブジェクト指向</a>
<ul>
<li><a href="#sec-1-4-1">仮想機械としてのオブジェクト</a></li>
<li><a href="#sec-1-4-2">メッセージング</a>
<ul>
<li><a href="#sec-1-4-2-1">動的な送信</a></li>
<li><a href="#sec-1-4-2-2">メッセージ転送</a></li>
<li><a href="#sec-1-4-2-3">非同期送信</a></li>
</ul>
</li>
<li><a href="#sec-1-4-3">オブジェクト指向という言葉が意味していること</a></li>
</ul>
</li>
<li><a href="#sec-1-5">1.5. まとめ</a></li>
<li><a href="#sec-1-6">1.6. あとがき</a></li>
</ul>
</li>
<li><a href="#sec-2">2. オブジェクト指向あれこれ</a></li>
<li><a href="#sec-3">3. オブジェクト指向に至るまで (まとめのまとめ）</a>
<ul>
<li><a href="#sec-3-1">3.1. オブジェクト指向に至るまで</a>
<ul>
<li><a href="#sec-3-1-1">ソフトウェア危機</a></li>
<li><a href="#sec-3-1-2">構造化プログラミング</a></li>
<li><a href="#sec-3-1-3">モジュラプログラミング</a>
<ul>
<li>
<ul>
<li><a href="#sec-3-1-3-0-1">凝集度と結合度</a></li>
<li><a href="#sec-3-1-3-0-2">悪い結合、良い結合</a></li>
<li><a href="#sec-3-1-3-0-3">悪い凝集、良い凝集</a></li>
<li><a href="#sec-3-1-3-0-4">状態と副作用の支配</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3-1-4">抽象データ型</a>
<ul>
<li>
<ul>
<li><a href="#sec-3-1-4-0-1">抽象データ型の情報隠蔽とカプセル化</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3-2">3.2. オブジェクト指向?</a></li>
<li><a href="#sec-3-3">3.3. Simula &amp; C++のオブジェクト指向</a>
<ul>
<li><a href="#sec-3-3-1">どの処理を呼び出すか決めるメカニズム</a>
<ul>
<li><a href="#sec-3-3-1-1">動的ディスパッチ</a></li>
<li><a href="#sec-3-3-1-2">継承と委譲</a>
<ul>
<li><a href="#sec-3-3-1-2-1">継承</a></li>
<li><a href="#sec-3-3-1-2-2">委譲</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3-3-2">オブジェクト指向の要素</a></li>
</ul>
</li>
<li><a href="#sec-3-4">3.4. Smalltalk &amp; Objective-Cのオブジェクト指向</a>
<ul>
<li><a href="#sec-3-4-1">仮想機械としてのオブジェクト</a></li>
<li><a href="#sec-3-4-2">メッセージング</a>
<ul>
<li><a href="#sec-3-4-2-1">動的な送信</a></li>
<li><a href="#sec-3-4-2-2">メッセージ転送  (Wikipedia)</a></li>
<li><a href="#sec-3-4-2-3">非同期送信</a></li>
</ul>
</li>
<li><a href="#sec-3-4-3">オブジェクト指向という言葉が意味していること</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-4">4. Joe Armstrongのオブジェクト指向はクソだ！</a>
<ul>
<li><a href="#sec-4-1">4.1. オブジェクト指向が"Suck"である理由</a>
<ul>
<li><a href="#sec-4-1-1">反論その１</a></li>
<li><a href="#sec-4-1-2">反論その２</a></li>
<li><a href="#sec-4-1-3">反論その３-オブジェクト指向言語ではデータタイプ定義はあちこちに散らばってしまう</a></li>
<li><a href="#sec-4-1-4">反論その４</a></li>
</ul>
</li>
<li><a href="#sec-4-2">4.2. オブジェクトが広まった理由</a></li>
</ul>
</li>
<li><a href="#sec-5">5. Strategic Choice を読もう</a>
<ul>
<li><a href="#sec-5-1">5.1. 記事一覧</a></li>
<li><a href="#sec-5-2">5.2. 構造化プログラミング</a></li>
<li><a href="#sec-5-3">5.3. パルナスの規則</a>
<ul>
<li><a href="#sec-5-3-1">解釈</a></li>
<li><a href="#sec-5-3-2">なんで？</a></li>
</ul>
</li>
<li><a href="#sec-5-4">5.4. 抽象データ型 - Strategic Choice</a>
<ul>
<li><a href="#sec-5-4-1">どういうこと？</a></li>
<li><a href="#sec-5-4-2">モジュールとの関連</a></li>
<li><a href="#sec-5-4-3">クラスとの関連</a></li>
</ul>
</li>
<li><a href="#sec-5-5">5.5. オブジェクト指向の本懐 - Strategic Choice</a>
<ul>
<li><a href="#sec-5-5-1">ソフトウエア開発プロセスの観点 &#x2013; オブジェクト指向の本懐（４）</a>
<ul>
<li><a href="#sec-5-5-1-1">概念(conceptual)</a></li>
<li><a href="#sec-5-5-1-2">仕様(specification)</a></li>
<li><a href="#sec-5-5-1-3">実装(implementation)</a></li>
<li><a href="#sec-5-5-1-4">オブジェクトとソフトウエア開発プロセスの観点の間のマッピング</a>
<ul>
<li><a href="#sec-5-5-1-4-1">概念レベル</a></li>
<li><a href="#sec-5-5-1-4-2">仕様レベル</a></li>
<li><a href="#sec-5-5-1-4-3">実装レベル</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-5-6">5.6. オブジェクト指向設計原則 - Strategic Choice</a></li>
<li><a href="#sec-5-7">5.7. プログラミング原則 [Unix思想] - Strategic Choice</a></li>
<li><a href="#sec-5-8">5.8. ソフトウェア開発の真実とウソ - Strategic Choice</a></li>
<li><a href="#sec-5-9">5.9. ソフトウェア開発原則一覧 - Strategic Choice</a></li>
<li><a href="#sec-5-10">5.10. 七つの設計原理 - Strategic Choice</a></li>
<li><a href="#sec-5-11">5.11. 漏れのある抽象化の法則 - Strategic Choice</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
<a href="./">ホーム</a> /
<a href="./lects.html">講義</a> /
<a href="./ruby.html">ruby</a> / 
<a href="./oo.html">OO</a> / 
<a href="./emacs.html">emacs</a> / 
<a href="./meta-ruby.html">meta-ruby</a> /
<a href="./note.html">note</a> /
<a href="https://github.com/masayuki054/meta-ruby">github-repos</a> /
<a href="https://wiki.cis.iwate-u.ac.jp/svn/meta-ruby/">svn-repos</a>
<a href="https://wiki.cis.iwate-u.ac.jp/~suzuki/lects/meta-ruby/">2015</a> /
</p>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> オブジェクト指向に至る軌跡</h2>
<div class="outline-text-2" id="text-1">
<dl class="org-dl">
<dt> 出展 </dt><dd><a href="https://qiita.com/hirokidaichi/items/591ad96ab12938878fe1">新人プログラマに知っておいてもらいたい人類がオブジェクト指向を手に入れるまでの軌跡 - Qiita</a>
</dd>
</dl>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> オブジェクト指向以前</h3>
<div class="outline-text-3" id="text-1-1">
<p>
オブジェクト指向プログラミング、あるいはオブジェクト指向言語は、
それに至るまでの様々なアイデアを統合し、再編され、また現実
的な制約の中で歪みながら生まれてきたものだったりする。
</p>

<p>
プログラミングパラダイムは，
現実世界のプログラミングという人間活動の中で生じた
課題をどのように整理していくかという中で生まれてきた。
</p>
</div>

<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">ソフトウェア危機</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
<a href="https://ja.wikipedia.org/wiki/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E5%8D%B1%E6%A9%9F">ソフトウェア危機</a> (wikipedia) とは
</p>

<p>
1960年代の後半、コンピュータが進歩するにつれて、より複雑
なソフトウェアが求められ始める時代、その複雑さをコントロールするた
めの道具やアイデアはあまり多くなかった。
</p>

<p>
プロジェクトは、複雑化する一方なのに、管理手法もなければ、データ型
は基本的な数値でしかなく、変数はメモリアロケーションそのものだった。
</p>

<p>
また、プログラムの流れは、gotoやjump命令のようにプログラムカウンタ
を直にコントロールする抽象度の低いもので制御されることが多かった。
</p>

<p>
プログラムはフローチャートで記述され、それをマシン語としてパンチす
るといったプロジェクトX的な世界のことを考えれば、その理解が正しいの
かもしれない。
</p>

<p>
なんにせよ、そういった当時の人からすると逼迫していたが、今から見る
となんとも牧歌的な世界観の中で、構造化プログラミングという概念が生
まれる。
</p>
</div>
</div>

<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">構造化プログラミング</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
ダイクストラは構造化プログラミングを提案した
</p>

<p>
ときどき、勘違いされているが構造化プログラミングとは「手続き型言語」
のことでもなければ「gotoを使わないプログラミング」のことでもない。
</p>
</div>

<div id="outline-container-sec-1-1-2-0-1" class="outline-6">
<h6 id="sec-1-1-2-0-1">Todo 構造化プログラミングとは</h6>
<div class="outline-text-6" id="text-1-1-2-0-1">
<p>
<a href="https://ja.wikipedia.org/wiki/%E6%A7%8B%E9%80%A0%E5%8C%96%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0">構造化プログラミング(wikipedia)</a>
</p>

<ul class="org-ul">
<li>構造化プログラミングではプログラミング言語が持つステートメントを
直接使ってプログラムを記述するのではなく、
</li>
<li>それらを抽象化したステートメントを持つ仮想機械を想定し、
</li>
<li>その仮想機械上でプログラムを記述する。
</li>

<li>普通、抽象化は1段階ではなく階層的である。
<ul class="org-ul">
<li>各階層での実装の詳細は他の階層と隔離されており、
</li>
<li>実装の変更の影響はその階層内のみに留まる(Abstract data
structures)。
</li>
<li>各階層はアプリケーションに近い抽象的な方から土台に向かって順
序付けられている。
</li>
<li>この順序は各階層を設計した時間的な順番とは必ずしも一致しない
</li>
</ul>
</li>
</ul>

<p>
つまり、現代風に言い換えると「レイヤリングアーキテクチャ」のよう
なもので、ある土台の上にさらに抽象化した土台をおき、その上にさら
に・・・というようにプログラムをくみ上げていく考え方のことだ。
</p>

<p>
これは、現在のプログラミングにおいても当たり前となっている考え方
だ。
</p>

<p>
だから、我々は、ひとつのアーキテクチャないし関数の中で異なる抽象
化レイヤの実装を同居することをさける。
</p>

<p>
一方、耳目を集めやすいgoto文有害論とともに構造化技法の一部である
構造化定理(任意のフローチャートは、for文とif文で記述できる)が注目
され、手続き型プログラミング言語を現代の形に押し上げていった。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-1-3" class="outline-4">
<h4 id="sec-1-1-3">モジュラプログラミング</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
こういった背景のなか、プログラムは大きく複雑になり続ける。至極自然
な流れとして、それを分割しようとしていく。
</p>
</div>

<div id="outline-container-sec-1-1-3-0-1" class="outline-6">
<h6 id="sec-1-1-3-0-1">凝集度と結合度</h6>
<div class="outline-text-6" id="text-1-1-3-0-1">
<p>
モジュールの分割には、大きな指針がなかった。現在でもやろうと思え
ば全然関係のない機能を１つのモジュールに詰め込むことはできる。
</p>

<p>
熟練したプログラマとそうでないプログラマで、作り出すモジュールの
品質は違う。その品質の尺度として、凝集度と結合度という概念がしば
らくして生まれた。
</p>

<p>
結合度：よいコラボレーションとわるいコラボレーションを定義した
<a href="https://ja.wikipedia.org/wiki/%E7%B5%90%E5%90%88%E5%BA%A6">https://ja.wikipedia.org/wiki/%E7%B5%90%E5%90%88%E5%BA%A6</a>
</p>

<p>
凝集度：よい機能群のまとめ方とわるい機能のまとめ方を定義した
<a href="https://ja.wikipedia.org/wiki/%E5%87%9D%E9%9B%86%E5%BA%A6">https://ja.wikipedia.org/wiki/%E5%87%9D%E9%9B%86%E5%BA%A6</a>
</p>

<p>
これらは「関心の分離」を行うためにどのようにするべきかという指針でもあった。
<a href="https://ja.wikipedia.org/wiki/%E9%96%A2%E5%BF%83%E3%81%AE%E5%88%86%E9%9B%A2">https://ja.wikipedia.org/wiki/%E9%96%A2%E5%BF%83%E3%81%AE%E5%88%86%E9%9B%A2</a>
</p>

<p>
この「関心」とはそのモジュールの「責任」「責務」と言い換えてもい
いかもしれない。この責任とモジュールが一致した状態にできるとその
モジュールは凝集度が高く、結合度を低くすることができる。
</p>

<p>
それぞれ悪い例と良い例を見ていき、「責任」「責務」の分解とは何か
をとらえていこう。
</p>
</div>
</div>

<div id="outline-container-sec-1-1-3-0-2" class="outline-6">
<h6 id="sec-1-1-3-0-2">悪い結合、良い結合</h6>
<div class="outline-text-6" id="text-1-1-3-0-2">
<p>
悪い結合としては、あるモジュールが依存しているモジュールの内部デー
タをそのまま使っていたり（内容結合）、同じグローバル変数（共通結
合）をお互いに参照していたりというようなつながり方だ。
</p>

<p>
こうなってしまうとモジュールは自分の足でたっていられなくなる。つ
まり、片方を修正するともう片方も修正せざるをえなくなったり、予想
外の動作を強いられることになる。
</p>

<p>
逆に良い結合としては、定められたデータの受け渡し(データ結合)やメッ
セージの送信（メッセージ結合）のように内部構造に依存せず、情報の
やり取りが明示的になっている状態を言う。
</p>

<p>
これはまさにカプセル化とメッセージパッシングのことだよね、と思っ
た方は正しい。オブジェクト指向は良い結合を導くために考えだされた
のだから。
</p>
</div>
</div>

<div id="outline-container-sec-1-1-3-0-3" class="outline-6">
<h6 id="sec-1-1-3-0-3">悪い凝集、良い凝集</h6>
<div class="outline-text-6" id="text-1-1-3-0-3">
<p>
凝集度が低い状態とは，つまり悪い凝集とは，何か，
</p>

<dl class="org-dl">
<dt> 暗合的凝集 </dt><dd>アトランダムに選んできた処理を集めたモジュールは
悪い。何を根拠に集めたのかわからないものも悪い凝集だ。
</dd>

<dt> 論理的凝集 </dt><dd>論理的に似ている処理だからという理由だけで集めて
はいけない。
</dd>
</dl>

<p>
たとえば、入出力の処理だからといって、
</p>

<div class="org-src-container">

<pre class="src src-java">function open(type,name){
    switch(type){
    case "json": ... break;
    case "yaml": ... break;
    case "csv" : ... break;
    case "txt" : ... break;
	:
    }
    return result;

}
</pre>
</div>

<p>
openという関数にif文やswitch文を大量に入れて、あらゆるopen処理を
まとめた関数をイメージしてもらいたい。（その論理的な関係を一つの
記述にまとめたいと思うこと自体は悪い発想じゃないが、同じ場所に書
くことで、もっと大事なデータとの関係が危うくなってしまう。その矛
盾をうまく解決するのが同じメッセージをデータ構造ごとに異なる解釈
をさせるポリモーフィズムだ。）
</p>

<p>
そういった種類のものがメンテナンスしづらいというのはイメージしや
すいだろう。
</p>

<dl class="org-dl">
<dt> 時間的凝集 </dt><dd>他にも同じようなタイミングで実施されるからといっ
て、モジュール化するのもの問題がある。たとえば、
initという関数の中ですべてのデータ構造の初期化を
するイメージをしてほしい。
</dd>
</dl>

<p>
一方、良い凝集とはなんなのか、それは
</p>

<dl class="org-dl">
<dt> 通信的凝集 </dt><dd>とあるデータに触れる処理をまとめることであるとか、
</dd>

<dt> 情報的凝集 </dt><dd>適切な概念とデータ構造とアルゴリズムをひとまとめ
にすること。
</dd>

<dt> 機能的凝集 </dt><dd>それによって、ひとつのうまく定義されたタスクをこ
なせるように集めることである。
</dd>
</dl>
</div>
</div>

<div id="outline-container-sec-1-1-3-0-4" class="outline-6">
<h6 id="sec-1-1-3-0-4">状態と副作用の支配</h6>
<div class="outline-text-6" id="text-1-1-3-0-4">
<p>
よいモジュール分割とはなにか
</p>

<ul class="org-ul">
<li>それは、処理とそれに関連するデータの関係性を明らかにして支配し
ていくことの重要性だ。

<p>
できれば、完全にデータの存在を隠蔽できてしまえると良いが、現実
のプログラムではそうは行かない場合も多い。
</p>
</li>
</ul>

<p>
こういった実務プログラミングの中で何が難しいかというと、それが状
態と副作用を持つことだ。
</p>

<p>
たとえば、
</p>
<div class="org-src-container">

<pre class="src src-java">function add(a,b){
    return a+b;
}
</pre>
</div>

<p>
このような副作用を持たない関数はテストもしやすく、バグが入り込む隙が少ない。
たとえば、計算機のレジスタ機能をこの関数に導入し、
</p>

<div class="org-src-container">

<pre class="src src-java">var r = 0;
function add(a,b){
    r = a+ (isUndefined(b)||r)
    return r
}
</pre>
</div>

<p>
このようにすると途端に考慮するべき事柄が増える。関連する状態や副
作用を含めて、関数を大別すると次のようになる。
</p>

<p>
オブジェクト指向に至るモジュラプログラミングは、こういった状態や
副作用に対して，積極的に命名，可視化，粗結合化をしていくことで
「関心の分離」を実現しようとした。
</p>

<p>
たとえば、現在でもC言語のプロジェクトなどでは，構造体とそれを引
数とする関数群ごとにモジュールを分割し，大規模なプログラミングを
行っている。構造体と関数群
</p>

<div class="org-src-container">

<pre class="src src-c">typedef struct {
    :
} Person;

void person_init(person*p,...){
    :
}

char * person_get_name(person *p){
    :
}

void person_set_name(person *p,char *name){
    :
}
</pre>
</div>

<p>
よくあるのは、上記のように構造体の名前のprefixとしてつけ、構造体
のポインタを第一引数として渡す手法だ。
</p>

<p>
その名残なのか、正確なところはよく知らないが、pythonやperlのオブ
ジェクト指向では、自分自身を表すデータが、第一引数として関数に渡
される。
</p>

<div class="org-src-container">

<pre class="src src-python">class Person(object):
    def __init__(self, a, b):
	self.a = a
	self.b = b
</pre>
</div>

<div class="org-src-container">

<pre class="src src-perl">package Person {
    sub new(){
	my ($class,$a,$b) = @_;
	my $self = bless{},$class;
	$self-&gt;init($a,$b);
	return $self;
    }
    sub init {
	my ($self,$a,$b) = @_;
	$self-&gt;{a} = $a;
	$self-&gt;{b} = $b;
    }
}
</pre>
</div>

<p>
あくまで関数の純粋性を犠牲にしないように発展を続けた関数型プログ
ラミングと、状態や副作用をデータ構造として主役にしていった手続き
型プログラミングの分かれ目として理解すると面白い。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-1-4" class="outline-4">
<h4 id="sec-1-1-4">抽象データ型</h4>
<div class="outline-text-4" id="text-1-1-4">
<p>
よいモジュール化の肝は、状態と副作用を隠蔽し、データとアルゴリズム
をひとまとめにすることだった。
</p>

<p>
それらを言語的に支援するために抽象データ型という概念が誕生した。
</p>

<p>
抽象データ型は、今で言うクラスのことだ。すなわちデータとそれに関連
する処理をひとまとめにしたデータ型のことだ。ようやくオブジェクト指
向の話に近づいてきた。ダイクストラの構造化プログラミングでは、デー
タ処理をどのように抽象化するかが課題として残っていた。
</p>

<p>
また、データ型と実際のメモリアロケーションは別であるので、新たに変
数を定義するとデータの共有はしない。あるデータ型を実際に存在するメ
モリに割り当てることをインスタンス化という。
</p>

<p>
抽象データ型のポイントは、その内部データへのアクセスを抽象データ型
にひもづいた関数でしか操作することができないという考え方だ。
</p>

<p>
これはつまり、たとえば、先ほどのC言語の例でいうと
</p>

<div class="org-src-container">

<pre class="src src-c">//people.h

typedef struct {
    //内部構造も公開している
} people;

void people_init(people *p,...);

char * people_get_name(people *p);

void people_set_name(people *p,char *name);
</pre>
</div>

<p>
このままだと、構造体の内部構造も公開しているので、
</p>

<div class="org-src-container">

<pre class="src src-c">people user;
user.age = 10;
printf("%d years old",user.age);
</pre>
</div>

<p>
のように内部構造に直接アクセスできてしまう。C言語では、テクニック
としてperson.h　こちらを公開する
</p>

<div class="org-src-container">

<pre class="src src-c">typedef struct sPerson person;

void person_init(person *p,...);

char * person_get_name(person *p);

void person_set_name(person *p,char *name);
</pre>
</div>

<div class="org-src-container">

<pre class="src src-c">//people_private.h　こちらはモジュール内で利用する

#include "person.h";

struct sPerson {
    //　ここに内部構造
};

//非公開用関数
_person_private(person *p,....);
</pre>
</div>

<p>
公開するヘッダと非公開のヘッダを分けることで、情報の隠蔽を行い抽象
データ型としての役目を成り立たせている。
</p>
</div>

<div id="outline-container-sec-1-1-4-0-1" class="outline-6">
<h6 id="sec-1-1-4-0-1">抽象データ型の情報隠蔽とカプセル化</h6>
<div class="outline-text-6" id="text-1-1-4-0-1">
<p>
C言語の構造体であっても、ヘッダファイルの定義と実装を分けることで、
抽象データ型の内部構造を隠蔽することができたが、言語機能として外
部からのアクセスに対する制限を明示できるようにサポートした。カプ
セル化やブラックボックス化というのは情報隠蔽よりも広い概念ではあ
るが、これらの機能によって、「悪い結合」を引き起こさないようにし
ている。
</p>

<p>
JavaやC#などのアクセス修飾子がそれにあたる。
</p>

<p>
PerlやJavaScriptなどアクセス修飾子の無い言語では、公開と非公開を
明確に区別せず、_privateMethodのようにアンダースコアを先頭につけ
ることで、擬似的に公開と非公開を区別する。
</p>

<p>
いずれにしても、ポイントは抽象化されたデータを取り扱うレイヤは、
抽象化されていない生の階層を直接触ることがないという階層化の考え
方だ。
</p>

<p>
これによって、複雑化した要求を抽象化の階層を定義していくという現
代的なプログラミングスタイルが確立した。
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> オブジェクト指向?</h3>
<div class="outline-text-3" id="text-1-2">
<p>
最初のオブジェクト指向言語は、1960年代に出現したSimulaという言語だ。
</p>

<p>
これはシミュレーション記述のために作られた言語であったが、後に汎用言
語となった。
</p>

<p>
オブジェクト、クラス（抽象データ型）、動的ディスパッチ、継承が既にあ
り、ガーベジコレクトまで実装されていたらしい。汎用言語としてそこまで
はやることはなかったが、これらの優れたコンセプトは今現在まで生き残っ
ている。
</p>

<p>
Simulaの優れたコンセプトをもとに，２つの，今でも使われている，C言語
拡張が生まれた。
</p>

<p>
一つはC++。もう一つはObjective-Cである。
</p>

<p>
C言語はとても実際的なものだったので、それにプリプロセッサの形で優れ
たコンセプトを輸入しようとしたのは当然の成り行きといえばそうだ。
</p>

<p>
SimulaのコンセプトをもとにSmalltalkという言語というか環境が爆誕した。
</p>

<p>
Smalltalkは、Simulaのコンセプトに「メッセージング」という概念を加え、
それらを再統合した。Smalltalkはすべての処理がメッセージ式として記述
される「純粋オブジェクト指向言語」だ。
</p>

<p>
そもそもオブジェクト指向という言葉はここで誕生した。
</p>

<p>
オブジェクト指向という言葉の発明者であるアランケイは後に「オブジェク
ト指向という名前は失敗だった」と述べている。メッセージングの概念が軽
視されて伝わってしまうからだという。
</p>

<p>
何にせよ、このSmalltalkの概念をもとにC言語を拡張したのがObjective-C
だ。
</p>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> Simula &amp; C++のオブジェクト指向</h3>
<div class="outline-text-3" id="text-1-3">
<p>
C++の作者であるビャーネ・ストロヴストルップは、オブジェクト指向を
「『継承』機構と『多態性』を付加した『抽象データ型』のスーパーセット」
として整理した。
</p>

<p>
C++ではメソッドのことをメンバー関数と呼ぶ。これはSimulaがメンバープ
ロシージャと読んでいるところに由来する。メソッドは、Smalltalkが発明
した用語だ。
</p>
</div>

<div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1">どの処理を呼び出すか決めるメカニズム</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
さて、継承と多態を足した抽象データ型といっても、なんだか良くわからない。
</p>

<p>
特に多態がいまいちわかりにくい。オブジェクト指向プログラミングの説明で
</p>

<div class="org-src-container">

<pre class="src src-c++">string = number.StringValue
string = date.StringValue
</pre>
</div>

<p>
これで、それぞれ違う関数が呼び出されるのがポリモーフィズムですよと
呼ばれる。
</p>

<p>
これだけだとシグネチャも違うので、違う処理が呼ばれるのも当たり前に
見える。
</p>

<p>
では、こう書いてみたらどうか
</p>

<div class="org-src-container">

<pre class="src src-c++">string = stringValue(number) // 実際にはNumberToStringが呼ばれる
string = stringValue(date)   // 実際にはDateToStringが呼ばれる
</pre>
</div>

<p>
このようにしたときに、すこし理解がしやすくなる。引数の型によって呼
ばれる関数が変わる。こういう関数を polymorphic (poly-複数に morphic-
変化する) な関数という。
</p>

<p>
これをみたときに"関数のオーバーロード"じゃないか？と思った人は鋭い。
<a href="https://ja.wikipedia.org/wiki/%E5%A4%9A%E9%87%8D%E5%AE%9A%E7%BE%A9">https://ja.wikipedia.org/wiki/%E5%A4%9A%E9%87%8D%E5%AE%9A%E7%BE%A9</a>
</p>

<p>
多態とは異なる概念とされるが、引数によって呼ばれる関数が変わるとい
う意味では似ている。しかし、次のようなケースで変わってくる。
</p>

<div class="org-src-container">

<pre class="src src-c++">function toString(IStringValue sv) string {
    return StringValue(sv)
}
</pre>
</div>

<p>
IStringValueはStringValueという関数を実装しているオブジェクトを表す
インターフェースだ。これを受け取ったときに、関数のオーバーロードで
は、どの関数に解決したら良いか判断がつかない。関数のオーバーロード
は、コンパイル時に型情報を付与した関数を自動的に呼ぶ仕組みだからだ。
</p>

<div class="org-src-container">

<pre class="src src-c++">stringValue(number:Number) =&gt; StringValue-Number(number)
stringValue(date :Date)  =&gt; StringValue-Date(date)

function toString(IStringValue sv) string {
    return StringValue(sv) =&gt; StringValue-IStringValue (無い！)
}
</pre>
</div>

<p>
それに対して、動的なポリモーフィズムを持つコードの場合、次のように
動作してくれるので、インターフェースを用いた例でも予想通りの動作を
する。
</p>

<div class="org-src-container">

<pre class="src src-c++">function StringValue(v:IstringValue){
    switch(v.class){ //オブジェクトが自分が何者かということを知っている。
    case Number: return StringValue-Number(number)
    case Date   : return StringValue-Date(date)
    }
}
</pre>
</div>


<p>
このようにどの関数を呼び出すのかをデータ自身に覚えさせておき、実行
時に探索して呼び出す手法を <b>動的分配*，*動的ディスパッチ</b> と呼ぶ。
</p>

<p>
このように動的なディスパッチによる多態性はどのような意味があるのか。
</p>

<p>
それはインターフェースによるコードの再利用と分離である。
</p>

<p>
特定のインターフェースを満たすオブジェクトであれば、それを利用した
コードを別のオブジェクトを作ったとしても再利用できる。
</p>

<p>
これによって、悪い凝集で例に挙げた論理的凝集をさけながら、
汎用的な処理を記述することができるのだ。
</p>

<p>
オブジェクト指向がはやり始めた当時は、再利用という言葉が比較的バズっ
たが、現在的に言い換えるなら、インターフェースに依存した汎用処理と
して記述すれば、結合度が下がり、テストが書きやすくなったり、仕様変
更に強くなったりする。
</p>
</div>

<div id="outline-container-sec-1-3-1-0-1" class="outline-6">
<h6 id="sec-1-3-1-0-1">動的ディスパッチ</h6>
<div class="outline-text-6" id="text-1-3-1-0-1">
<p>
動的ディスパッチのキモは、オブジェクト自身が自分が何者であるか知っ
ており、また、実行時に関数テーブルを探索して、どの関数を実行する
かというところにある。SimulaもC++もvirtualという予約語を用いて、
仮想関数の動的分配をすることを宣言できる。
</p>

<div class="org-src-container">

<pre class="src src-c++">/*
Vtable for B1
B1::_ZTV2B1: 3u entries
0     (int (*)(...))0
8     (int (*)(...))(&amp; _ZTI2B1)
16    B1::f1

Class B1
   size=16 align=8
   base size=16 base align=8
B1 (0x7ff8afb7ad90) 0
    vptr=((&amp; B1::_ZTV2B1) + 16u)
 */
class B1 {
public:
    void f0(){}
    virtual void f1(){}
    char before_b0_char;
    int member_b1;
};
/*
Class B0
   size=4 align=4
   base size=4 base align=4
B0 (0x7ff8afb7e1c0) 0
 */
class B0{
private:
    void f(){};
    int member_b1;
};
</pre>
</div>

<p>
このようにデータ自身にvtable(仮想関数テーブル）へのポインタを埋め込んであり、
それをたどることで解決する。
</p>

<p>
逆にvirtual宣言をしなければ、仮想関数テーブルをたどるというオーバー
ヘッドなしに関数を呼ぶことができる。Javaでは、デフォルトでvirtual
宣言されているのと等価に動的なディスパッチが行われる。C++やC#では、
動的ディスパッチのコストを必要なときにしか利用しないために(ゼロオー
バーヘッドポリシー)、virtual宣言を明示的にする必要がある。
</p>

<p>
objective-Cも同様であるが、関数ポインタを直に取得することでこのオー
バーヘッドを回避することができる。
</p>
<div class="org-src-container">

<pre class="src src-c++">//objectivce-c.m

SEL selector = @selector(f0); 
IMP p_func = [obj methodForSelector : selector ];
// p_funcを保持しておいて、繰り返しなどで
   :
pfunc(obj , selector);   // pfunc使うと、探索コストを減らせる。
// 何か重要でない限りする必要はない。
</pre>
</div>

<p>
疑似コードで、この動的なディスパッチを表現するとこのようになる。
</p>

<div class="org-src-container">

<pre class="src src-c++">//動的ディスパッチの疑似コード

var PERSON_TABLE = {
    "getName" : function(self){return self.name},
};

var object = {
    _vt_ : PERSON_TABLE, // 自分が何ができるか教える
    name : "daichi hiroki"
};

// メソッドを動的に呼び出す
function methodCall(object,methodName){
    // オブジェクト自身を第一引数として束縛する
    return object._vt_[methodName](object)
}

methodCall(object,"getName");
</pre>
</div>

<p>
こうなってくると、多態を実現するためには、３つの要素が必要だとわかる。
</p>

<ul class="org-ul">
<li>データに自分自身が何者か教える機能
</li>
<li>メソッドを呼び出した際にそれを探索する機能
</li>
<li>オブジェクト自身を参照できるように引数に束縛する機能
</li>
</ul>

<p>
あとからオブジェクト指向的機能を追加したperl5の例が、これらを端的
に追加しているので見ていこう。
</p>

<div class="org-src-container">

<pre class="src src-perl">package Person;

sub new {
    my($class,$ref) = @_;
    #リファレンスとパッケージを結びつけるbless関数
    # $classはPersonパッケージを表す
    return bless( $object, $ref );
}
sub get_name{
    my ($self) = @_;
    $self-&gt;{name};
}

#メソッドの動的な探索と第一引数に束縛する-&gt;アロー演算子
my $person = Person-&gt;new({ name =&gt; "daichi hiroki"});
$person-&gt;get_name;
</pre>
</div>

<p>
このなかで、bless関数はリファレンスに対して、リファレンス自身が
「関数を探索するべきモジュールはここですよ。」と教えている。
（blessは祝福するという意味。パッケージのご加護が守護霊みたいにくっ
つくイメージ。）
</p>

<p>
また-&gt;演算子を使うことで、自動的に探索と呼び出しを実現している。
</p>

<p>
あと付けでOOP機能を足そうというときに、たった二つの機能で多態を実
現したPerl5のアプローチにはたぐいまれなセンスを感じる。
</p>
</div>
</div>

<div id="outline-container-sec-1-3-1-0-2" class="outline-6">
<h6 id="sec-1-3-1-0-2">継承と委譲</h6>
<div class="outline-text-6" id="text-1-3-1-0-2">
</div><div id="outline-container-sec-1-3-1-0-2-1" class="outline-7">
<h7 id="sec-1-3-1-0-2-1">継承</h7>
<div class="outline-text-7" id="text-1-3-1-0-2-1">
<p>
さて、SimulaとC++がもたらした最後の要素は継承だ。継承は、あるク
ラスの機能をもったまま、別の機能を追加したもう一つのクラスを作る
仕組みだ。
</p>

<p>
まずはデータだけで考えてみよう。
生徒と先生の管理をしたいというときに、
二つに共通しているデータ構造は名前、性別、年齢であり、
生徒は追加して、学科と年次を管理し、
先生は追加して、専門と月収を管理したいとする。
</p>

<div class="org-src-container">

<pre class="src src-c">typedef struct {
    int age;
    int sex;
    char *name;
} Person;

typedef struct {
    People people;
    int grade;
    int study:
} Student;

typedef struct {
    People people;
    int field;
    int salary;
} Teacher;

Teacher t;
t.people.age = 10;
</pre>
</div>

<p>
とするとこのように構造体に構造体を埋め込むことで、共通するデータ
構造を持つことができる。
</p>

<p>
これに処理を追加する場合、次のようにするだろう。
</p>

<div class="org-src-container">

<pre class="src src-c">char * person_get_name(Person *self) {
    return self-&gt;name;
}
char * teacher_get_name(Teacher *self){
    return person_get_name((People *)self);
}

char * teacher_get_name_2(Teacher *self){
    return person_get_name(&amp;self.person);
}

Teacher *pt = teacher_alloc_init(30,MALE,"daichi hiroki",MATH,30);
teacher_get_name(pt);
</pre>
</div>

<p>
このようにアップキャストして、埋め込んだ構造体内部にアクセスすることができる。
それか、埋め込んだ構造体をそのまま渡すなどして、処理の共通化を実現する。
</p>

<p>
しかし、これでは処理の共通化をするごとにその呼び出しコードを追加する必要がある。
これをうまく提供してくれるのが 継承機能だ。
</p>

<p>
public/protectedなメンバー関数やメンバー変数に対して、継承関係をたどって
探すことができる。
</p>

<p>
そのため
</p>

<div class="org-src-container">

<pre class="src src-c++">Teacher *t = new Teacher;
t-&gt;get_name; // Teacher自体に宣言がなくても、Peopleクラスを探索してくれる。
</pre>
</div>

<p>
のように書くことができる。
</p>

<p>
また、
</p>

<div class="org-src-container">

<pre class="src src-c++">string nameFormat(People *p)  {
    return sprintf("%s(%d) %s",p-&gt;get_name,p-&gt;get_age,(p-&gt;get_sex == MALE) ? "男性" :"女性");  
}
</pre>
</div>

<p>
というような関数があったときに、
</p>

<div class="org-src-container">

<pre class="src src-c++">Person *p = new Person;
Student *s = new Student;
Teacher *t = new Teacher;

nameFormat(p);
nameFormat(s);
nameFormat(t);
</pre>
</div>

<p>
Person自身かそのサブクラスであれば、共通の処理を利用することができる。
</p>

<p>
この継承関係を言語機能として提供するためにperl5では、もう一つの機能を追加する。
それが@ISAだ。
</p>

<div class="org-src-container">

<pre class="src src-perl">package Person;
sub get_name{"person"}

package Student;
# @ISAにパッケージを追加するとblessされたパッケージに関数がなかった場合にそちらを探索に行く
our @ISA = qw/Person/;

package Teacher;
our @ISA = qw/Person/;
</pre>
</div>

<p>
このようにどこを探索するのかという情報だけ宣言できるようにすれば、
問題なく継承関係を表現することができる。
</p>

<p>
ちょうど、FQNで表記すると
</p>

<p>
@Teacher::ISA="Person"という表現になり、teacher is a personという関係が成り立っていることを表現している。
</p>

<p>
このときのメソッド探索を疑似コードで書くと次のようになる。
動的ディスパッチの疑似コード
</p>

<div class="org-src-container">

<pre class="src src-c++">var PERSON_TABLE = {
    "getName" : function(self){return self.name}
};

var STUDENT_TABLE = {
    "getGrade" : function(self){return self.grade},
    "#is-a#"  : PERSON_TABLE
};

var object = {
    _vt_ : STUDENT_TABLE, // 自分が何ができるか教える
    name : "daichi hiroki"
};

// メソッドを動的に呼び出す
function methodCall(object,methodName){

    var vt = object._vt_;
    // is-aを順番にたどってmethodを見つけて実行する
    while(vt){
	var method = vt[methodName];
	if( method ) return method(object);
	vt = vt["#is-a#"];
    }
    throw Error;
}

methodCall(object,"getName");
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-3-1-0-2-2" class="outline-7">
<h7 id="sec-1-3-1-0-2-2">委譲</h7>
<div class="outline-text-7" id="text-1-3-1-0-2-2">
<p>
継承の代わりに委譲という手段を用いているプログラミング言語がある。
これはSimulaとC++の系譜とは少し違うが、動的ディスパッチの話をしたので
簡単に説明する。
</p>

<p>
これは、クラスベースのオブジェクト指向に対してプロトタイプベース
のオブジェクト指向と呼ばれたりする。身近な例ではJavaScriptなどだ。
</p>

<p>
継承と委譲の違いは先ほどのC言語の例で言えば、すごく単純で埋め込む構造体が
ポインタかそうでないかという違いくらいだ。
</p>

<div class="org-src-container">

<pre class="src src-c++">typedef struct {
    int age;
    int sex;
    char *name;
} Person;

typedef struct {
	Person* person;
    int grade;
    int study:
} Student;

typedef struct {
    Person* person;
    int field;
    int salary;
} Teacher;
</pre>
</div>

<p>
委譲は、探索先のオブジェクトを動的に書き換えることができる。
</p>

<div class="org-src-container">

<pre class="src src-c++">t-&gt;person = new Person;
</pre>
</div>

<p>
疑似コードで言えば、
動的ディスパッチの疑似コード
</p>

<p>
var hogetaro = {
    getName : function(self){return self.name},
    name       : "hogetaro"
};
</p>

<p>
var object = {
    <span class="underline">prototype</span> : hogetaro, // 次に探索するオブジェクトを決める
    name : "daichi hiroki"
};
</p>

<p>
// メソッドを動的に呼び出す
function methodCall(object,methodName){
    //　最初は自分自身
    var pt = object;
    // is-aを順番にたどってmethodを見つけて実行する
    while(pt){
        var method = pt[methodName];
        if( method ) return method(object);
        pt = pt._prototype_;
    }
    throw Error;
}
</p>

<p>
methodCall(object,"getName");
object._prototype_ = { getName:function(){return "hello"}};
// プロトタイプは動的に書き換えることができる。
methodCall(object,"getName");
</p>

<p>
このようになる。
こうやって、prototypeを順番に追って検索していくのをjavascriptではプロトタイプチェーンと読んでいる。luaであれば同じ役割をするのがmetatableというものがある。
</p>

<p>
こういった委譲によるメソッド探索は、動的継承とも呼ばれている。
</p>

<p>
このようにメソッドの動的な探索に対して、どのような機構をつけるのかというのが
オブジェクト指向では重要な構成要素と言える。
</p>

<p>
rubyのmoduleやそのinclude,prepend、特異メソッド、特異クラスなどは
まさにその例だ。
</p>

<p>
それらをjavascriptで疑似コード的に実装した例として、こちらを参照してもらいたい。
<a href="https://qiita.com/hirokidaichi/items/f653a843208971981c37">https://qiita.com/hirokidaichi/items/f653a843208971981c37</a>
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-3-1-0-3" class="outline-6">
<h6 id="sec-1-3-1-0-3">オブジェクト指向の要素</h6>
<div class="outline-text-6" id="text-1-3-1-0-3">
<p>
このようにオブジェクト指向のための機能は、
</p>

<p>
抽象データ型：データと処理をひもづける
抽象データ型：情報の隠蔽を行うことができる
オブジェクト：データ自身が何者か知っている
動的多態：オブジェクト自身のデータと処理を自動的に探索する
探索先の設定：継承、委譲
</p>

<p>
ということになる。
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> Smalltalk &amp; Objective-Cのオブジェクト指向</h3>
<div class="outline-text-3" id="text-1-4">
<p>
アランケイの「オブジェクト指向」の定義:
</p>
<blockquote>
<p>
パーソナルコンピューティングに関わる全てを『オブジェクト』とそれらの間
で交わされる『メッセージ送信』によって表現すること
</p>
</blockquote>
</div>

<div id="outline-container-sec-1-4-1" class="outline-4">
<h4 id="sec-1-4-1">仮想機械としてのオブジェクト</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
アランケイの世界観の中では、メモリとCPUとそれに対する命令を持つ機械
をさらに抽象化するとしたら、それは同じくデータと処理と命令セットを
もつ仮想機械で抽象化されるべきだと考えていた。
</p>

<p>
構造化プログラミングの中でダイクストラが仮想機械として階層
的に抽象化すべきだと言っていたこととかぶる。
</p>

<p>
オブジェクトは独立した機械と見なし，それに対してメッセージを送り、
自ら持つデータの責任は自らが負う。
</p>

<p>
Smalltalkの実行環境もまた仮想機械として作られている。
</p>
</div>
</div>

<div id="outline-container-sec-1-4-2" class="outline-4">
<h4 id="sec-1-4-2">メッセージング</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
Smalltalkでメッセージ送信は下記のように記述する:
</p>

<div class="org-src-container">

<pre class="src src-ruby">receiver message
</pre>
</div>

<p>
Objective-Cであれば、C言語の中に次のように書く:
</p>

<div class="org-src-container">

<pre class="src src-objective-c">[receiver message]
[receiver methodName:args1 with:args]
</pre>
</div>

<p>
メッセージとは通信のアナロジーだ。アドレスさえ知っていれば、メッセー
ジは自由に送れる。受信者(レシーバ)はメッセージを受け取っているにす
ぎないので、その解釈は自由に行うことができる。
</p>

<p>
このメッセージらしさが出てくる特徴をいくつか紹介しよう。
</p>
</div>

<div id="outline-container-sec-1-4-2-1" class="outline-5">
<h5 id="sec-1-4-2-1">動的な送信</h5>
<div class="outline-text-5" id="text-1-4-2-1">
<p>
メッセージ内容もまたオブジェクトにすぎないので、動的に作成し、送ることができる。
たとえば、rubyのObject#sendがその性質をそのまま表現している。
</p>

<div class="org-src-container">

<pre class="src src-ruby">class A
  def hello
    p "hello"
  end
end

a = A.new
# 動的にメソッドを作成
method = "he" + "ll" + "o"
# それを呼び出す
a.send(method)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-4-2-2" class="outline-5">
<h5 id="sec-1-4-2-2">メッセージ転送</h5>
<div class="outline-text-5" id="text-1-4-2-2">
<p>
受け取ったメッセージは、仮にメソッド定義がなかったとしても自由に取
り扱うことができる。
</p>

<p>
<a href="https://ja.wikipedia.org/wiki/%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E8%BB%A2%E9%80%81">メッセージ転送 - Wikipedia</a>
</p>

<ul class="org-ul">
<li>rubyの method_missing や Objective-C の forwardInvocation がそれ
にあたる。他にもPerlのAUTOLOADなど、最近の動的型言語には用意され
ていることが多い。
</li>

<li>proxy.rb
</li>
</ul>

<div class="org-src-container">

<pre class="src src-ruby">class Proxy
  def method_missing(name, *args, &amp;block)
    target.send(name, *args, &amp;block)
  end

  def target
    @target ||= []
  end
end

Proxy.new &lt;&lt; 1

'end'
</pre>
</div>

<p>
たとえば、Proxyクラスをこのように定義してあげるとすべてのメッセージ
を@targetのオブジェクトにそのまま転送してあげることができる。
</p>
</div>
</div>

<div id="outline-container-sec-1-4-2-3" class="outline-5">
<h5 id="sec-1-4-2-3">非同期送信</h5>
<div class="outline-text-5" id="text-1-4-2-3">
<p>
ほとんどの言語でメッセージの結果を同期的に受け取るようになっている
ので、意識しづらいが、メッセージというアナロジーである以上、それを
同期的に待ち受ける必要はない。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-4-3" class="outline-4">
<h4 id="sec-1-4-3">オブジェクト指向という言葉が意味していること</h4>
<div class="outline-text-4" id="text-1-4-3">
<p>
このようにメッセージパッシングというアナロジーを使うことで、様々な
性質がオブジェクト指向には加わることになった。
</p>

<p>
しかし、オブジェクト指向という言葉が意味しているのが、C++の再定義
したオブジェクト指向として理解されることで、このメッセージパッシン
グの要素が意識されなくなってしまったため、前述したようにアランケイ
はその命名が不適切だったと考えているらしい
</p>

<p>
<a href="https://www.infoq.com/jp/news/2010/07/objects-smalltalk-erlang">https://www.infoq.com/jp/news/2010/07/objects-smalltalk-erlang</a>
</p>

<p>
この記事は今までの議論の流れをふまえると、理解がしやすいと思う。
特に
</p>

<blockquote>
<p>

</p>

<p>
私は、オブジェクト指向プログラミングというものに疑問を持ち始めまし
た。Erlangはオブジェクト指向ではなく、関数型プログラミング言語だと
考えました。そして、私の論文の指導教官が言いました。「だが、あなた
は間違っている。Erlangはきわめてオブジェクト指向です。」 彼は、オ
ブジェクト指向言語はオブジェクト指向ではないといいました。これを信
じるかどうかは確かではありませんでしたが、Erlangは唯一のオブジェク
ト指向言語かもしれないと思いました。オブジェクト指向プログラミング
の3つの主義は、メッセージ送信に基づいて、オブジェクト間で分離し、
ポリモーフィズムを持つものです。
</p>
</blockquote>
</div>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> まとめ</h3>
<div class="outline-text-3" id="text-1-5">
<ul class="org-ul">
<li>オブジェクト指向も構造化プログラミングも問題の抽象化で同じことを見ていた。
</li>

<li>C++はSimulaからモジュール化や抽象データ型、動的多態といった良い性質を採用した。
</li>

<li>一方、SmalltalkはSimulaの着想をメッセージとオブジェクトという概念
で統合した。それによって、様々な動的な性質を現在の言語にもたらして
きた。
</li>

<li>また、メッセージパッシングという概念は、本質的には現在注目を浴びて
いる Actor や CSP のような並行モデルと似通っており、興味深い。
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> あとがき</h3>
<div class="outline-text-3" id="text-1-6">
<p>
少しはオブジェクト指向という考え方の背景が見えてきて、それがより良い
設計やコーディングにつながればうれしいです。
</p>

<p>
この説明は、オブジェクト指向の説明の本流ではない、いわば傍流的なもの
ではありますが、より実際的で、より技術的理解を必要とするものなので、
初学者向けではなかったかと思います。ですが、これを理解することで、様々
な言語機能の背景を推察することができ、バラバラの事柄が有機的につなが
ることを期待しています。
</p>
</div>
</div>
</div>


<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> オブジェクト指向あれこれ</h2>
<div class="outline-text-2" id="text-2">
<p>
オブジェクト指向あれこれ
<a href="https://d.hatena.ne.jp/asakichy/20090428/1240878836">https://d.hatena.ne.jp/asakichy/20090428/1240878836</a>
</p>

<p>
アジャイル設計と5つの原則 - かまずにまるのみ。
<a href="https://tdak.hateblo.jp/entry/20130703/1372842149">https://tdak.hateblo.jp/entry/20130703/1372842149</a>
</p>

<p>
オブジェクト指向の法則集 - Qiita
<a href="https://qiita.com/kenjihiranabe/items/9eddc70e279861992274">https://qiita.com/kenjihiranabe/items/9eddc70e279861992274</a>
</p>

<p>
オブジェクト指向の本懐 - Strategic Choice
<a href="https://d.hatena.ne.jp/asakichy/20090421/1240277448">https://d.hatena.ne.jp/asakichy/20090421/1240277448</a>
</p>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> オブジェクト指向に至るまで (まとめのまとめ）</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> オブジェクト指向に至るまで</h3>
<div class="outline-text-3" id="text-3-1">
</div><div id="outline-container-sec-3-1-1" class="outline-4">
<h4 id="sec-3-1-1">ソフトウェア危機</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
<a href="https://ja.wikipedia.org/wiki/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E5%8D%B1%E6%A9%9F">ソフトウェア危機</a> 
</p>

<p>
コンピュータが進歩するにつれて、より複雑なソフトウェアが求められ始める
その複雑さをコントロールするための道具やアイデアが不足
</p>

<p>
プロジェクト管理手法もなければ、
抽象度の低いデータ型，変数，制御構造
</p>
</div>
</div>

<div id="outline-container-sec-3-1-2" class="outline-4">
<h4 id="sec-3-1-2">構造化プログラミング</h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
<a href="https://ja.wikipedia.org/wiki/%E6%A7%8B%E9%80%A0%E5%8C%96%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0">構造化プログラミング(wikipedia)</a>
</p>

<p>
つまり、現代風に言い換えると「レイヤリングアーキテクチャ」のよう
なもので、ある土台の上にさらに抽象化した土台をおき、その上にさら
に・・・というようにプログラムをくみ上げていく考え方のことだ。
</p>

<p>
だから、我々は、ひとつのアーキテクチャないし関数の中で異なる抽象
化レイヤの実装を同居することをさける。
</p>
</div>
</div>

<div id="outline-container-sec-3-1-3" class="outline-4">
<h4 id="sec-3-1-3">モジュラプログラミング</h4>
<div class="outline-text-4" id="text-3-1-3">
<p>
大きく複雑になるプログラムの分割
</p>
</div>

<div id="outline-container-sec-3-1-3-0-1" class="outline-6">
<h6 id="sec-3-1-3-0-1">凝集度と結合度</h6>
<div class="outline-text-6" id="text-3-1-3-0-1">
<p>
結合度：よいコラボレーションとわるいコラボレーションを定義した
<a href="https://ja.wikipedia.org/wiki/%E7%B5%90%E5%90%88%E5%BA%A6">https://ja.wikipedia.org/wiki/%E7%B5%90%E5%90%88%E5%BA%A6</a>
</p>

<p>
凝集度：よい機能群のまとめ方とわるい機能のまとめ方を定義した
<a href="https://ja.wikipedia.org/wiki/%E5%87%9D%E9%9B%86%E5%BA%A6">https://ja.wikipedia.org/wiki/%E5%87%9D%E9%9B%86%E5%BA%A6</a>
</p>

<p>
これらは「関心の分離」を行うためにどのようにするべきかという指針でもあった。
<a href="https://ja.wikipedia.org/wiki/%E9%96%A2%E5%BF%83%E3%81%AE%E5%88%86%E9%9B%A2">https://ja.wikipedia.org/wiki/%E9%96%A2%E5%BF%83%E3%81%AE%E5%88%86%E9%9B%A2</a>
</p>

<p>
この「関心」とはそのモジュールの「責任」「責務」と言い換えてもい
いかもしれない。この責任とモジュールが一致した状態にできるとその
モジュールは凝集度が高く、結合度を低くすることができる。
</p>
</div>
</div>

<div id="outline-container-sec-3-1-3-0-2" class="outline-6">
<h6 id="sec-3-1-3-0-2">悪い結合、良い結合</h6>
<div class="outline-text-6" id="text-3-1-3-0-2">
<p>
悪い結合としては、あるモジュールが依存しているモジュールの内部デー
タをそのまま使っていたり（内容結合）、同じグローバル変数（共通結
合）をお互いに参照していたりというようなつながり方だ。
</p>

<p>
こうなってしまうとモジュールは自分の足でたっていられなくなる。つ
まり、片方を修正するともう片方も修正せざるをえなくなったり、予想
外の動作を強いられることになる。
</p>

<p>
逆に良い結合としては、定められたデータの受け渡し(データ結合)やメッ
セージの送信（メッセージ結合）のように内部構造に依存せず、情報の
やり取りが明示的になっている状態を言う。
</p>

<p>
これはまさにカプセル化とメッセージパッシングのことだよね、と思っ
た方は正しい。オブジェクト指向は良い結合を導くために考えだされた
のだから。
</p>
</div>
</div>

<div id="outline-container-sec-3-1-3-0-3" class="outline-6">
<h6 id="sec-3-1-3-0-3">悪い凝集、良い凝集</h6>
<div class="outline-text-6" id="text-3-1-3-0-3">
<p>
凝集度が低い状態とは，つまり悪い凝集とは，何か，
</p>

<dl class="org-dl">
<dt> 暗合的凝集 </dt><dd>アトランダムに選んできた処理を集めたモジュールは
悪い。何を根拠に集めたのかわからないものも悪い凝集だ。
</dd>

<dt> 論理的凝集 </dt><dd>論理的に似ている処理だからという理由だけで集めて
はいけない。
</dd>

<dt> 時間的凝集 </dt><dd>他にも同じようなタイミングで実施されるからといっ
て、モジュール化するのもの問題がある。たとえば、
initという関数の中ですべてのデータ構造の初期化を
するイメージをしてほしい。
</dd>
</dl>

<p>
一方、良い凝集とはなんなのか、それは
</p>

<dl class="org-dl">
<dt> 通信的凝集 </dt><dd>とあるデータに触れる処理をまとめることであるとか、
</dd>

<dt> 情報的凝集 </dt><dd>適切な概念とデータ構造とアルゴリズムをひとまとめ
にすること。
</dd>

<dt> 機能的凝集 </dt><dd>それによって、ひとつのうまく定義されたタスクをこ
なせるように集めることである。
</dd>
</dl>
</div>
</div>

<div id="outline-container-sec-3-1-3-0-4" class="outline-6">
<h6 id="sec-3-1-3-0-4">状態と副作用の支配</h6>
<div class="outline-text-6" id="text-3-1-3-0-4">
<p>
よいモジュール分割とはなにか
</p>

<ul class="org-ul">
<li>それは、処理とそれに関連するデータの関係性を明らかにして支配し
ていくことの重要性だ。

<p>
できれば、完全にデータの存在を隠蔽できてしまえると良いが、現実
のプログラムではそうは行かない場合も多い。
</p>
</li>
</ul>

<p>
こういった実務プログラミングの中で何が難しいかというと、それが状
態と副作用を持つことだ。
</p>

<p>
オブジェクト指向に至るモジュラプログラミングは、こういった状態や
副作用に対して，積極的に命名，可視化，粗結合化をしていくことで
「関心の分離」を実現しようとした。
</p>

<p>
たとえば、現在でもC言語のプロジェクトなどでは，構造体とそれを引
数とする関数群ごとにモジュールを分割し，大規模なプログラミングを
行っている。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3-1-4" class="outline-4">
<h4 id="sec-3-1-4">抽象データ型</h4>
<div class="outline-text-4" id="text-3-1-4">
<p>
よいモジュール化の肝
</p>
<ul class="org-ul">
<li>状態と副作用を隠蔽し、
</li>
<li>データとアルゴリズムをひとまとめにする
</li>
</ul>

<p>
それらを言語的に支援するために抽象データ型という概念が誕生した。
</p>

<p>
抽象データ型は、今で言うクラス
</p>
<ul class="org-ul">
<li>すなわちデータとそれに関連する処理をひとまとめにしたデータ型のこ
とだ。
</li>

<li>抽象データ型のポイントは、その内部データへのアクセスを抽象データ
型にひもづいた関数でしか操作することができないという考え方だ。
</li>
</ul>

<p>
内部構造を隠し，型とインタフェースを公開する。
</p>

<ul class="org-ul">
<li>公開するヘッダと非公開のヘッダを分けることで、情報の隠蔽を行い抽象
データ型としての役目を成り立たせている。
</li>
</ul>
</div>

<div id="outline-container-sec-3-1-4-0-1" class="outline-6">
<h6 id="sec-3-1-4-0-1">抽象データ型の情報隠蔽とカプセル化</h6>
<div class="outline-text-6" id="text-3-1-4-0-1">
<p>
言語機能として外部からのアクセスを制限できるようにした。
</p>

<p>
カプセル化やブラックボックス化というのは情報隠蔽よりも広い概念で
はあるが、これらの機能によって、「悪い結合」を引き起こさないよう
にしている。
</p>

<p>
これによって、複雑化した要求を抽象化の階層を定義していくという現
代的なプログラミングスタイルが確立した。
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> オブジェクト指向?</h3>
<div class="outline-text-3" id="text-3-2">
<p>
simula
</p>
<ul class="org-ul">
<li>オブジェクト、
</li>
<li>クラス（抽象データ型）、
</li>
<li>動的ディスパッチ、
</li>
<li>継承
</li>
<li>ガーベジコレクト
</li>
</ul>

<p>
Simulaの優れたコンセプトをもとに，２つの，今でも使われている，C言語
拡張が生まれた。
</p>

<p>
一つはC++。もう一つはObjective-Cである。
</p>

<p>
SimulaのコンセプトをもとにSmalltalkという言語というか環境が爆誕した。
</p>

<p>
Smalltalkは、Simulaのコンセプトに「メッセージング」という概念を加え、
それらを再統合した。Smalltalkはすべての処理がメッセージ式として記述
される「純粋オブジェクト指向言語」だ。
</p>

<p>
そもそもオブジェクト指向という言葉はここで誕生した。
</p>

<p>
オブジェクト指向という言葉の発明者であるアランケイは後に「オブジェク
ト指向という名前は失敗だった」と述べている。メッセージングの概念が軽
視されて伝わってしまうからだという。
</p>

<p>
何にせよ、このSmalltalkの概念をもとにC言語を拡張したのがObjective-C
だ。
</p>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> Simula &amp; C++のオブジェクト指向</h3>
<div class="outline-text-3" id="text-3-3">
<p>
C++のオブジェクト指向
</p>

<blockquote>
<p>
継承と多態性を付加した抽象データ型のスーパーセット
</p>
</blockquote>
</div>

<div id="outline-container-sec-3-3-1" class="outline-4">
<h4 id="sec-3-3-1">どの処理を呼び出すか決めるメカニズム</h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
さて、継承と多態を足した抽象データ型といっても、なんだか良くわからない。
</p>

<p>
特に多態がいまいちわかりにくい。オブジェクト指向プログラミングの説明で
</p>

<div class="org-src-container">

<pre class="src src-c++">string = number.StringValue
string = date.StringValue
</pre>
</div>

<p>
これで、それぞれ違う関数が呼び出されるのがポリモーフィズムですよと
呼ばれる。
</p>

<p>
これだけだとシグネチャも違うので、違う処理が呼ばれるのも当たり前に
見える。
</p>

<p>
では、こう書いてみたらどうか
</p>

<div class="org-src-container">

<pre class="src src-c++">string = stringValue(number) // 実際にはNumberToStringが呼ばれる
string = stringValue(date)   // 実際にはDateToStringが呼ばれる
</pre>
</div>

<p>
このようにしたときに、すこし理解がしやすくなる。引数の型によって呼
ばれる関数が変わる。こういう関数を polymorphic (poly-複数に morphic-
変化する) な関数という。
</p>

<p>
これをみたときに"関数のオーバーロード"じゃないか？と思った人は鋭い。
<a href="https://ja.wikipedia.org/wiki/%E5%A4%9A%E9%87%8D%E5%AE%9A%E7%BE%A9">https://ja.wikipedia.org/wiki/%E5%A4%9A%E9%87%8D%E5%AE%9A%E7%BE%A9</a>
</p>

<p>
多態とは異なる概念とされるが、引数によって呼ばれる関数が変わるとい
う意味では似ている。しかし、次のようなケースで変わってくる。
</p>

<div class="org-src-container">

<pre class="src src-c++">function toString(IStringValue sv) string {
    return StringValue(sv)
}
</pre>
</div>

<p>
IStringValueはStringValueという関数を実装しているオブジェクトを表す
インターフェースだ。これを受け取ったときに、関数のオーバーロードで
は、どの関数に解決したら良いか判断がつかない。関数のオーバーロード
は、コンパイル時に型情報を付与した関数を自動的に呼ぶ仕組みだからだ。
</p>

<div class="org-src-container">

<pre class="src src-c++">stringValue(number:Number) =&gt; StringValue-Number(number)
stringValue(date :Date)  =&gt; StringValue-Date(date)

function toString(IStringValue sv) string {
    return StringValue(sv) =&gt; StringValue-IStringValue (無い！)
}
</pre>
</div>

<p>
それに対して、動的なポリモーフィズムを持つコードの場合、次のように
動作してくれるので、インターフェースを用いた例でも予想通りの動作を
する。
</p>

<div class="org-src-container">

<pre class="src src-c++">function StringValue(v:IstringValue){
    switch(v.class){ //オブジェクトが自分が何者かということを知っている。
    case Number: return StringValue-Number(number)
    case Date   : return StringValue-Date(date)
    }
}
</pre>
</div>

<p>
このようにどの関数を呼び出すのかをデータ自身に覚えさせておき、実行
時に探索して呼び出す手法を <b>動的分配*，*動的ディスパッチ</b> と呼ぶ。
</p>

<p>
このように動的なディスパッチによる多態性はどのような意味があるのか。
</p>

<p>
それはインターフェースによるコードの再利用と分離である。
</p>

<p>
特定のインターフェースを満たすオブジェクトであれば、それを利用した
コードを別のオブジェクトを作ったとしても再利用できる。
</p>

<p>
これによって、悪い凝集で例に挙げた論理的凝集をさけながら、
汎用的な処理を記述することができるのだ。
</p>

<p>
オブジェクト指向がはやり始めた当時は、再利用という言葉が比較的バズっ
たが、現在的に言い換えるなら、インターフェースに依存した汎用処理と
して記述すれば、結合度が下がり、テストが書きやすくなったり、仕様変
更に強くなったりする。
</p>
</div>


<div id="outline-container-sec-3-3-1-1" class="outline-5">
<h5 id="sec-3-3-1-1">動的ディスパッチ</h5>
<div class="outline-text-5" id="text-3-3-1-1">
<p>
動的ディスパッチのキモは、オブジェクト自身が自分が何者であるか知っ
ており、また、実行時に関数テーブルを探索して、どの関数を実行する
かというところにある。
</p>

<p>
こうなってくると、多態を実現するためには、３つの要素が必要だとわかる。
</p>

<ul class="org-ul">
<li>データに自分自身が何者か教える機能
</li>
<li>メソッドを呼び出した際にそれを探索する機能
</li>
<li>オブジェクト自身を参照できるように引数に束縛する機能
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-3-1-2" class="outline-5">
<h5 id="sec-3-3-1-2">継承と委譲</h5>
<div class="outline-text-5" id="text-3-3-1-2">
</div><div id="outline-container-sec-3-3-1-2-1" class="outline-6">
<h6 id="sec-3-3-1-2-1">継承</h6>
</div>

<div id="outline-container-sec-3-3-1-2-2" class="outline-6">
<h6 id="sec-3-3-1-2-2">委譲</h6>
<div class="outline-text-6" id="text-3-3-1-2-2">
<p>
このようにメソッドの動的な探索に対して、どのような機構をつけるのかというのが
オブジェクト指向では重要な構成要素と言える。
</p>

<p>
rubyの module やその include, prepend、特異メソッド，特異クラスなどは
まさにその例だ。
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-sec-3-3-2" class="outline-4">
<h4 id="sec-3-3-2">オブジェクト指向の要素</h4>
<div class="outline-text-4" id="text-3-3-2">
<ul class="org-ul">
<li>抽象データ型：データと処理をひもづける
</li>
<li>抽象データ型：情報の隠蔽を行うことができる
</li>
<li>オブジェクト：データ自身が何者か知っている
</li>
<li>動的多態：オブジェクト自身のデータと処理を自動的に探索する
</li>
<li>探索先の設定：継承、委譲
</li>
</ul>

<p>
ということになる。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> Smalltalk &amp; Objective-Cのオブジェクト指向</h3>
<div class="outline-text-3" id="text-3-4">
<p>
アランケイによるオブジェクト指向の定義：
</p>

<blockquote>
<p>
パーソナルコンピューティングに関わる全てを『オブジェクト』とそれらの
間で交わされる『メッセージ送信』によって表現すること
</p>
</blockquote>
</div>

<div id="outline-container-sec-3-4-1" class="outline-4">
<h4 id="sec-3-4-1">仮想機械としてのオブジェクト</h4>
<div class="outline-text-4" id="text-3-4-1">
<dl class="org-dl">
<dt> アランケイの世界観 </dt><dd>         コンピュータを抽象化するとしたら、データと処理と命令セットをも
つ仮想機械で抽象化されるべき
</dd>

<dt> 構造化プログラミング </dt><dd>        仮想機械として階層的に抽象化すべき
</dd>

<dt> オブジェクト指向 </dt><dd>         オブジェクトを独立した機械と見なし、それに対してメッセージを送
り、自ら持つデータの責任は自らが負う。
</dd>
</dl>

<p>
Smalltalkの実行環境もまた仮想機械として作られている。
</p>
</div>
</div>

<div id="outline-container-sec-3-4-2" class="outline-4">
<h4 id="sec-3-4-2">メッセージング</h4>
<div class="outline-text-4" id="text-3-4-2">
<p>
Smalltalkでメッセージ送信は下記のように記述する:
</p>

<div class="org-src-container">

<pre class="src src-ruby">receiver message
</pre>
</div>

<p>
メッセージングは通信。
</p>

<ul class="org-ul">
<li>アドレスさえ知っていれば、メッセージは自由に送れる。
</li>

<li>レシーバはメッセージを受け取リ，その解釈はレシーバ自身が行う
</li>
</ul>

<p>
このメッセージらしさが出てくる特徴をいくつか紹介しよう。
</p>
</div>

<div id="outline-container-sec-3-4-2-1" class="outline-5">
<h5 id="sec-3-4-2-1">動的な送信</h5>
<div class="outline-text-5" id="text-3-4-2-1">
<p>
メッセージの内容もまたオブジェクトなので、動的に作成し送ることができる。
</p>

<div class="org-src-container">

<pre class="src src-ruby">class A
  def hello
    p "hello"
  end
end

a = A.new
# 動的にメソッドを作成
method = "he" + "ll" + "o"
# それを呼び出す
a.send(method)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-4-2-2" class="outline-5">
<h5 id="sec-3-4-2-2">メッセージ転送  <a href="https://ja.wikipedia.org/wiki/%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E8%BB%A2%E9%80%81">(Wikipedia)</a></h5>
<div class="outline-text-5" id="text-3-4-2-2">
<p>
受け取ったメッセージは、仮にメソッド定義がなかったとしても自由に取
り扱うことができる。
</p>

<ul class="org-ul">
<li>rubyの method_missing は，メソッドがない時に呼ばれるメソッド。
メソッドの未定義を知ることができ，その処理を他のオブジェクトにま
かせるのが，メッセージ転送。

<p>
proxy.rb
</p>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-ruby">class Proxy
  def method_missing(name, *args, &amp;block)
    target.send(name, *args, &amp;block)
  end

  def target
    @target ||= []
  end
end

Proxy.new &lt;&lt; 1

'end'
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-4-2-3" class="outline-5">
<h5 id="sec-3-4-2-3">非同期送信</h5>
<div class="outline-text-5" id="text-3-4-2-3">
<p>
メッセージの送信と結果の受信を別々に行なう。
</p>

<p>
並列計算が可能になる。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3-4-3" class="outline-4">
<h4 id="sec-3-4-3">オブジェクト指向という言葉が意味していること</h4>
<div class="outline-text-4" id="text-3-4-3">
<p>
<a href="https://www.infoq.com/jp/news/2010/07/objects-smalltalk-erlang">https://www.infoq.com/jp/news/2010/07/objects-smalltalk-erlang</a>
</p>

<p>
オブジェクト指向プログラミングの3つの主義は、
</p>

<ul class="org-ul">
<li>メッセージ送信に基づいて、
</li>

<li>オブジェクト間で分離し、
</li>

<li>ポリモーフィズムを持つ
</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Joe Armstrongのオブジェクト指向はクソだ！</h2>
<div class="outline-text-2" id="text-4">
<p>
<a href="https://qiita.com/lambda-knight/items/fb7530232912dc4176c4">オブジェクト指向はクソか？ - Qiita</a> を読んで
</p>

<ul class="org-ul">
<li>後から見つけた，<a href="https://gist.github.com/posaunehm/4087971">Why OO Sucks by Joe Armstrong</a> の訳の方がぴんときます。
</li>
</ul>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> オブジェクト指向が"Suck"である理由</h3>
<div class="outline-text-3" id="text-4-1">
<blockquote>
<p>
私のOOPに対する反対意見はOOの基本的なアイデアに対するものも含まれます。
以下にそのアイデアのアウトラインと私の反対意見を述べます。
</p>
</blockquote>
</div>

<div id="outline-container-sec-4-1-1" class="outline-4">
<h4 id="sec-4-1-1">反論その１</h4>
<div class="outline-text-4" id="text-4-1-1">
<blockquote>
<p>

</p>

<ul class="org-ul">
<li>データ構造と機能は一緒にすべきではない
</li>
</ul>

<p>
（Objection 1 - Data structure and functions should not be bound
together）
</p>

<p>
オブジェクトは関数とデータ構造が分割出来ない単位としてひとつまとめにし
ています。しかし、私はこれこそが基本的でかつ大きな誤りであると考えてい
ます。なぜなら、関数とデータは異なる世界に存在するからです。なぜでしょ
う。関数は何かを実行します。そして関数はインプットとアウトプットを持ち
ます。関数の入力と出力はデータ構造であり、関数により変更されます。
</p>
</blockquote>

<ul class="org-ul">
<li>「関数とデータは異なる世界に存在するからです」は，理由が希薄です。
<ul class="org-ul">
<li>「関数とデータは，異なるものです。」は認めます。
</li>
<li>データとその処理関数は近くにあって，同時に見られた方が，分かりやす
いことが多いと思う。
</li>
<li>データだけからなるクラスがあってもいいし，インタフェースだけからな
るモジュールがあってもいい。Rubyではそうなっている。
</li>
</ul>
</li>
</ul>

<blockquote>
<p>

</p>

<p>
多くの言語の関数は命令のシーケンスから作られます。すなわち、「まずはこ
れを実行して、次はこれを実行しなさい」という手順です。関数を理解するた
めにはどのような順序でものごとが実行されるかを理解しなければなりません
（遅延評価をサポートする関数型言語と論理型言語ではこの制限は緩やかで
す）。
</p>
</blockquote>

<ul class="org-ul">
<li>関数についての説明はそのとおり。
</li>
</ul>

<blockquote>
<p>
データ構造はそれそのものです。これらは何もしません。これらは本来宣言的
なものなのです。データ構造を理解することは関数を理解することよりもはる
かに簡単なことなのです。
</p>
</blockquote>

<ul class="org-ul">
<li>これは違うと思う。データ構造だけを見て，データ構造を用いてできる
ことを理解することは，ほんとうに難しいこと，だと思う。
</li>
</ul>

<blockquote>
<p>
関数は，入力から出力へと変換するための，ブラックボックスです。入力と出
力を理解すれば，関数を理解したことになります。でも理解したからと言って，
関数を記述できることにはなりません。
</p>
</blockquote>

<ul class="org-ul">
<li>些細なことですが，「入力と出力を理解すれば関数を理解したことになり
ます」ではなくて，関数を利用できることになるだと思います。そして，
「関数を利用できない人に，関数の中身は記述できません」だと思います。
</li>
</ul>

<blockquote>
<p>
関数は通常、コンピュータシステムにおいてジョブがデータ構造をT1からT2に
変換することの観察を通して理解したことになります。
</p>
</blockquote>

<ul class="org-ul">
<li>ここは最初，理解できませんでした。
</li>
<li>「関数を書くには，複数のデータを見なくてはいけない。ある一つの型を主
にみて，書くことはよくない」と言ってるのかな。
<ul class="org-ul">
<li>そうかもしれないが，。。。
</li>
<li>適切な抽象度で見れば，関数のやってることは下記の3種 (ほんとかな？):
<dl class="org-dl">
<dt> 変換 </dt><dd>自身 -&gt; 自身
</dd>
<dt> 簡約 </dt><dd>自身 -&gt; 自明なもの
</dd>
<dt> 合成 </dt><dd>自身 -&gt; 高いレベルのもの
</dd>
</dl>
<p>
だとすると，変換や簡約は自身と一緒に記述してあると，わかりやすい。
合成は，自身の中に記述するのではなく，高いレベルのものと一緒に書
くべきだと，思えます。
</p>

<p>
入力が複数ある場合は，「どれか主になるものがある」場合や，「一纏
めとして扱うことができる」場合は，型(データ)を主に，処理の記述が
でき，何をやっているのかが，分かりやすいと，思えます。
</p>
</li>
</ul>
</li>
</ul>

<blockquote>
<p>
このように関数とデータ構造は全く異なるタイプの生き物です。そしてそれを
同じカゴの中に閉じ込めるのは全く持って間違っていることなのです。
</p>
</blockquote>

<ul class="org-ul">
<li>「異なるタイプの生き物を同じカゴに閉じ込めるのは間違い」は，理由になっていません。
</li>

<li>関数とデータ構造を近くに置いて，同時に見られることは，いいことです。
</li>

<li>問題があるとすれば，同じデータ構造に対し，異なる操作関数からなるク
ラスが沢山ある場合の冗長さかな。
</li>

<li>「データを理解することは簡単」が考え方の違いの根本ですね，きっと。

<p>
データ駆動なのか関数駆動(こんな言葉ある？)なのかの違いですね。
</p>

<p>
関数駆動において，関数をできるだけ汎用にするためには，入力の型は，
できるだけシンプルにし，入力の意味を多様に解釈・適応できることが，
関数の汎用性を高めるこになる。
</p>

<p>
オブジェクト指向では，その解釈や適応できることを，書いておきたいんだ
よね。きっと。
</p>
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-4-1-2" class="outline-4">
<h4 id="sec-4-1-2">反論その２</h4>
<div class="outline-text-4" id="text-4-1-2">
<blockquote>
<p>

</p>

<ul class="org-ul">
<li>すべてはオブジェクトではない
</li>
</ul>

<p>
(Objection 2 - Everything has to be an object.)
</p>

<p>
「時刻」について考えてみましょう。OO言語の立場での「時刻」はオブジェク
トであるべきです。でも、非OO言語では「時刻」はデータタイプのインスタン
スです。例えばErlangでは「時刻」の多くのバラエティがあります。これらは
とても明白で曖昧さがありません。
</p>
</blockquote>

<ul class="org-ul">
<li>時刻を表すデータ型はあったほうがいいでしょう。自明だと思います。時
刻を表すのに整数の組み合わせをもちいたいならそうもできます。
オブジェクトであるべきかどうかの議論にはなっていません。
</li>
</ul>

<pre class="example">
    -deftype day() = 1..31.
    -deftype month() = 1..12.
    -deftype year() = int().
    -deftype hour() = 1..24.
    -deftype minute() = 1..60.
    -deftype second() = 1..60.
    -deftype abstime() = {abstime, year(), month(), day(), hour(), min(), sec()}.
    -deftype hms() = {hms, hour(), min(), sec()}.
    ...

これらの定義はどの特定のオブジェクトにも属していません。これらはどこで
も利用できるデータ構造で「時刻」を表現しており、システムのどの関数から
でも利用することができます。

そしてどのようなメソッドにも関連していません。
</pre>

<ul class="org-ul">
<li>これらはインタフェース群とクラス (abstime(), hms()) )に見えるなぁ。
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-4-1-3" class="outline-4">
<h4 id="sec-4-1-3">反論その３-オブジェクト指向言語ではデータタイプ定義はあちこちに散らばってしまう</h4>
<div class="outline-text-4" id="text-4-1-3">
<blockquote>
<p>
(Objection 3 - In an OOPL data type definitions are spread out all over
the place.)
</p>

<p>
オブジェクト指向ではデータタイプはオブジェクトとして定義されます。そう
するとデータタイプは一箇所で見つけることができません。ErlangやCではす
べての私のデータは一箇所であるinclude fileもしくはデータ辞書でみつける
ことができます。でも、OOPLではこのようなことができず、データタイプ定義
はあちこちに散らばってしまいます。
</p>
</blockquote>

<ul class="org-ul">
<li>Rubyでは，class/module 単位のまとまりをつくり, 継承やincludeにより
階層を作り，require によって，必要なライブラリを記述し，
適切な抽象度で，見ることができる。散らばっているのではなく，
適切なまとまりごとに*リンク*づけられている。
一望したければ，ツールをつくればいいだろう。
</li>
</ul>

<blockquote>
<p>

</p>

<p>
この例を示しましょう。私が汎用的なデータ構造を定義したいとします。この
汎用データタイプとはシステムのすべての場所で使えるものです。
</p>

<p>
LISPプログラマであれば「わずかな汎用データタイプと多くの小さな関数がこ
れらに作用すること」が「数多いデータタイプとこれらに作用する少ない数の
関数よりも良いこと」という真実を知っています。
</p>

<p>
そして､汎用データ構造としてリンクリストや配列、ハッシュテーブルがあり、
さらには時刻、日付、ファイル名などがあります。
</p>

<p>
OOPLでは私は汎用的なデータ構造を定義する際にはなにかベースオブジェクト
の中から選択しなければならないというとても面倒くさいことをしなければな
りません。そして､そのデータ構造はこのオブジェクトを継承して作る必要が
あります。もし何か「時刻」のオブジェクトを定義したい場合、これがどのベー
スオブジェクトに所属していて、それ自体、どのようなオブジェクトであるか
考えなければならないのです｡
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-4-1-4" class="outline-4">
<h4 id="sec-4-1-4">反論その４</h4>
<div class="outline-text-4" id="text-4-1-4">
<blockquote>
<p>

</p>

<ul class="org-ul">
<li>オブジェクトはプライベートな状態を持っている
</li>
</ul>

<p>
（Objection 4 - Objects have private state.）
</p>

<p>
状態(state)は諸悪の根源です。特に関数の副作用は避けるべきです。しかし
ながらプログラミング言語において状態は好ましいものではないのに関わらず、
実世界では状態は至るところに存在します。
</p>
</blockquote>

<ul class="org-ul">
<li>はい，実世界をモデル化するプログラムでは，状態を持つことは 避けら
れませんね。
</li>
</ul>

<blockquote>
<p>
例えば私は銀行口座の状態､すなわちに預金残高に大いなる関心があります。
そしていつ私が入金や出金をする場合には銀行の口座が正しく更新されなけれ
ばとても困ったことになります。
</p>

<p>
実世界でこのような状態が存在したとして、この状態を取り扱うためにはプロ
グラミング言語はどのような仕組みを提供すればよいのでしょうか。
</p>

<p>
OOPLはプログラマから状態を隠しなさいといいます。状態は隠されてアクセス
関数を通してしか見えません。
</p>

<p>
伝統的なプログラミング言語であるCやPasalでは状態変数の可視性は言語のス
コープのルールによってコントロールされます。
</p>

<p>
でも､純粋に宣言的な言語では状態は存在しないことになっています。このよ
うな宣言的言語ではシステムのグローバルな状態はすべての関数の入力や出力
になりうるのです。関数型言語におけるモナドや論理型言語におけるDCGでは
「状態はあたかも関係のないように」プログラミングすることができます。に
も関わらず必要な場合にはこれらのシステムの状態に完全にアクセスをするこ
とができるのです。
</p>

<p>
ほんとうは「プログラマから状態を隠す」というOOPLで選択されたオプション
はとても悪いものなのです。状態を公開して状態の厄介さを最小限にしようと
する努力をすべきなのに､その代わりとしてOOPLではそれを隠し去ってしまっ
たのです。
</p>
</blockquote>

<ul class="org-ul">
<li>よく理解できていませんが，「プログラマから状態を隠すのは良くない，
OOPLだけがそうしている」という主張と読みました。
</li>

<li>「隠くすことも，公開することも，できるようにしよう」という立場だと思
います。アクセスすべきものは，アクセスできるようにします。でも，アク
セスする時は，その持ち主のメソッドを通してというのが，Rubyのやり方。
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> オブジェクトが広まった理由</h3>
<div class="outline-text-3" id="text-4-2">
<blockquote>
<p>

</p>

<p>
オブジェクト指向が広まった理由は次のとおりだといわれています。
</p>

<ul class="org-ul">
<li>Reason 1 - It was thought to be easy to learn.
（簡単に学べると思われていたから）
</li>
</ul>
</blockquote>

<ul class="org-ul">
<li>Ruby は簡単に学べると思う。
</li>
</ul>

<blockquote>
<p>

</p>

<ul class="org-ul">
<li>Reason 2 - It was thought to make code reuse easier.
（再利用がより簡単だと思われているから）
</li>
</ul>
</blockquote>

<ul class="org-ul">
<li>Rubyでは，再利用が簡単だと思う。
</li>
</ul>

<blockquote>
<p>

</p>

<ul class="org-ul">
<li>Reason 3 - It was hyped.
（売り込まれたから）
</li>

<li>Reason 4 - It created a new software industry.
（新しいソフトウエア産業を作ったから）
</li>
</ul>
</blockquote>

<ul class="org-ul">
<li>そういう風潮もありますね。
</li>
</ul>

<blockquote>
<p>
 
しかし、１と２が事実であるという証拠はまったくを持って見たことがありま
せん。
</p>
</blockquote>

<ul class="org-ul">
<li>筆者は Ruby を使ったことがあるのかなぁ？
</li>
</ul>

<blockquote>
<p>

</p>

<p>
それでも実際にオブジェクト指向が広まった理由はテクノロジーに対す
る逆向きの作用であると思われます。つまり、あるテクノロジーがひどすぎる
と、そのテクノロジー自体が作った問題を解決するための新たなビジネスが登
場して、金儲けをしたい人たちのアイデアになるのです。実はこのことが実際
のOOPに対する推進力になっているということなのです｡
</p>
</blockquote>

<ul class="org-ul">
<li>そういう風潮もありますね。
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Strategic Choice を読もう</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> 記事一覧</h3>
<div class="outline-text-3" id="text-5-1">
<p>
<a href="https://d.hatena.ne.jp/asakichy/archive">https://d.hatena.ne.jp/asakichy/archive</a>
</p>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> 構造化プログラミング</h3>
<div class="outline-text-3" id="text-5-2">
<p>
■[構造化プログラミング]構造化プログラミング入門
</p>

<p>
構造化プログラミング
</p>

<p>
構造化とは、構造のない、いわば行き当たりばったりのものを、指針に基づいた構造へと整理する作
 業。 
</p>

<ul class="org-ul">
<li>オブジェクト指向も、オブジェクトという構造に整理するという1つの構造化であるといえる。 
</li>
</ul>

<p>
現在でも見通しの良い整理されたコードを書くにあたって、構造化プログラミングは有効に作用する。
</p>

<p>
定義
</p>

<p>
1つの入り口と1つの出口を持つようなプログラムは「順次・反復・分岐」の3つの基本的な論理構造
によって記述できる
</p>

<p>
基本手段
</p>

<ul class="org-ul">
<li>基本3構造 

<ul class="org-ul">
<li>順次（連接） 
</li>
<li>反復（繰り返し） 
</li>
<li>分岐 
</li>
</ul>
</li>

<li>段階的詳細化 

<ul class="org-ul">
<li>言葉どおりに捉えれば段階的に詳細にしていくということ 
</li>
<li>つまりトップダウンで詳細化するということ 
</li>
<li>基準が必要 
</li>

<li>凝集度 
</li>
<li>結合度 
</li>
</ul>
</li>
</ul>

<p>
取上理由
</p>

<ul class="org-ul">
<li>構造化プログラミングにおけるトップダウンの機能分解には、確かに問題がある。 

<ul class="org-ul">
<li>この問題がオブジェクト指向の動機にもなっている。 
</li>
</ul>
</li>

<li>ただし、構造化プログラミングの実装部分のエッセンス（特に凝集度・結合度の考え方）は今でも参考
になる。 

<ul class="org-ul">
<li>[構造化プログラミング]段階的詳細化 
</li>
<li>[構造化プログラミング]凝集度 
</li>
<li>[構造化プログラミング]結合度 
</li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> パルナスの規則</h3>
<div class="outline-text-3" id="text-5-3">
<p>
&gt; モジュールの利用者には、そのモジュールを利用するために必要なすべての
&gt; 情報を与え、それ以外の情報は一切見せないこと。
</p>

<p>
&gt; モジュールの作成者には、そのモジュールを実装するために必要なすべての
&gt; 情報を与え、それ以外の情報は一切見せないこと。
</p>
</div>

<div id="outline-container-sec-5-3-1" class="outline-4">
<h4 id="sec-5-3-1">解釈</h4>
<div class="outline-text-4" id="text-5-3-1">
<p>
インターフェイスと実装の分離を行い、情報隠蔽またはカプセル化を実現する。 
</p>
</div>
</div>

<div id="outline-container-sec-5-3-2" class="outline-4">
<h4 id="sec-5-3-2">なんで？</h4>
<div class="outline-text-4" id="text-5-3-2">
<p>
システムの部分同士は最小かつ明快なつながりで結ばれていることが望ましい。
</p>

<ul class="org-ul">
<li>内部を知らなくても使える（再利用） 
</li>
<li>利用者に影響を与えず実装を入れ替えることが出来る（保守） 
</li>
</ul>
</div>
</div>
</div>




<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> 抽象データ型 - Strategic Choice</h3>
<div class="outline-text-3" id="text-5-4">
<p>
<a href="https://d.hatena.ne.jp/asakichy/20090225/1235547089">https://d.hatena.ne.jp/asakichy/20090225/1235547089</a>
</p>

<p>
abstract data type (ADT)
</p>
</div>

<div id="outline-container-sec-5-4-1" class="outline-4">
<h4 id="sec-5-4-1">どういうこと？</h4>
<div class="outline-text-4" id="text-5-4-1">
<ul class="org-ul">
<li>型定義を公開できること。 

<ul class="org-ul">
<li>プログラマがデータ型を定義。 
</li>
</ul>
</li>

<li>インスタンスに対する操作が利用出来ること。 

<ul class="org-ul">
<li>「do(data)」ではなく「data.do()」。 
</li>
</ul>
</li>

<li>内部のデータを保護し、上記の操作のみがアクセス出来ること。 

<ul class="org-ul">
<li>情報隠蔽。 
</li>
</ul>
</li>

<li>複数のインスタンスを作れること。 

<ul class="org-ul">
<li>マルチプルインスタンス。 
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5-4-2" class="outline-4">
<h4 id="sec-5-4-2">モジュールとの関連</h4>
<div class="outline-text-4" id="text-5-4-2">
<ul class="org-ul">
<li>モジュールで情報隠蔽までは可能だった。（パルナスの規則） 
</li>
<li>しかし複数インスタンスが作れない。 
</li>
<li>これを満たすのがADT。 
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5-4-3" class="outline-4">
<h4 id="sec-5-4-3">クラスとの関連</h4>
<div class="outline-text-4" id="text-5-4-3">
<ul class="org-ul">
<li>クラスは，抽象データ型を実現するもの
</li>
<li>これに加えて，下記を特徴として持つ:
<ul class="org-ul">
<li><b>継承</b> 
</li>
<li><b>ポリモーフィズム</b> ((s-:?))
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5"><span class="section-number-3">5.5</span> オブジェクト指向の本懐 - Strategic Choice</h3>
<div class="outline-text-3" id="text-5-5">
<p>
<a href="https://d.hatena.ne.jp/asakichy/20090421/1240277448">https://d.hatena.ne.jp/asakichy/20090421/1240277448</a>
</p>
</div>

<div id="outline-container-sec-5-5-1" class="outline-4">
<h4 id="sec-5-5-1">ソフトウエア開発プロセスの観点 &#x2013; オブジェクト指向の本懐（４）</h4>
<div class="outline-text-4" id="text-5-5-1">
<p>
オブジェクト指向の考察の前提知識， 
マーチン・ファウラー「UMLモデリングのエッセンス」で提唱
</p>
</div>

<div id="outline-container-sec-5-5-1-1" class="outline-5">
<h5 id="sec-5-5-1-1">概念(conceptual)</h5>
<div class="outline-text-5" id="text-5-5-1-1">
<ul class="org-ul">
<li>調査対象領域における概念を表現。 
</li>
<li>実装とは関係なく導き出される。 
</li>
<li>「私は何に対して責任があるのか？」 
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5-5-1-2" class="outline-5">
<h5 id="sec-5-5-1-2">仕様(specification)</h5>
<div class="outline-text-5" id="text-5-5-1-2">
<ul class="org-ul">
<li>ソフトウェアを考慮。 
</li>
<li>実装ではなく、インターフェイスの考慮 。 
</li>
<li>「私はどのように使用されるのか？」 
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5-5-1-3" class="outline-5">
<h5 id="sec-5-5-1-3">実装(implementation)</h5>
<div class="outline-text-5" id="text-5-5-1-3">
<ul class="org-ul">
<li>ソースコード自体を考慮。 
</li>
<li>上の2つを考えた後。 
</li>
<li>「私はどのように自身の責任を全うするのか？」 
</li>
</ul>

<p>
この観点の使い分けが非常に重要
</p>

<ul class="org-ul">
<li>概念レベルでコミュニケーションを取とると、お互いの詳細は知らなくて良
いことになります。
</li>
<li>設計はまずここで考えることになります。すなわちソフトウェア以下は考慮
しません。
</li>
<li>すると設計アウトプットにおいて、使用者に概念をそのままにして実装を変
更できるため、結果的に使用者に対して（発生しやすい変更である）実装変
更から守ることになります。
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5-5-1-4" class="outline-5">
<h5 id="sec-5-5-1-4">オブジェクトとソフトウエア開発プロセスの観点の間のマッピング</h5>
<div class="outline-text-5" id="text-5-5-1-4">
<p>
ソフトウェア開発プロセスの観点とオブジェクト指向設計がよくマッチするから。
以下にオブジェクトと観点のマッピングを示す:
</p>
</div>

<div id="outline-container-sec-5-5-1-4-1" class="outline-6">
<h6 id="sec-5-5-1-4-1">概念レベル</h6>
<div class="outline-text-6" id="text-5-5-1-4-1">
<ul class="org-ul">
<li>オブジェクトは責任の集合 
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5-5-1-4-2" class="outline-6">
<h6 id="sec-5-5-1-4-2">仕様レベル</h6>
<div class="outline-text-6" id="text-5-5-1-4-2">
<ul class="org-ul">
<li>オブジェクトはその他のオブジェクトや自ら起動することが出来るメソッドの集合 
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5-5-1-4-3" class="outline-6">
<h6 id="sec-5-5-1-4-3">実装レベル</h6>
<div class="outline-text-6" id="text-5-5-1-4-3">
<ul class="org-ul">
<li>オブジェクトはコードとデータ、それらの相互演算処理 
</li>
</ul>

<p>
そしてこの観点の使い分けがわかると、既存の開発手法から「オブジェクト指
向（の本質）」にパラダイムシフトし易くなります。
</p>
</div>
</div>
</div>
</div>
</div>


<div id="outline-container-sec-5-6" class="outline-3">
<h3 id="sec-5-6"><span class="section-number-3">5.6</span> オブジェクト指向設計原則 - Strategic Choice</h3>
<div class="outline-text-3" id="text-5-6">
<p>
<a href="https://d.hatena.ne.jp/asakichy/20090122/1232879842">https://d.hatena.ne.jp/asakichy/20090122/1232879842</a>
</p>
</div>
</div>

<div id="outline-container-sec-5-7" class="outline-3">
<h3 id="sec-5-7"><span class="section-number-3">5.7</span> プログラミング原則 [Unix思想] - Strategic Choice</h3>
<div class="outline-text-3" id="text-5-7">
<p>
<a href="https://d.hatena.ne.jp/asakichy/searchdiary?word=*[Unix%C2%BB%C3%97%C3%81%C3%9B]">https://d.hatena.ne.jp/asakichy/searchdiary?word=*[Unix%C2%BB%C3%97%C3%81%C3%9B]</a>
</p>
</div>
</div>

<div id="outline-container-sec-5-8" class="outline-3">
<h3 id="sec-5-8"><span class="section-number-3">5.8</span> ソフトウェア開発の真実とウソ - Strategic Choice</h3>
<div class="outline-text-3" id="text-5-8">
<p>
ohttps://d.hatena.ne.jp/asakichy/20131007/1381097627
</p>
</div>
</div>

<div id="outline-container-sec-5-9" class="outline-3">
<h3 id="sec-5-9"><span class="section-number-3">5.9</span> ソフトウェア開発原則一覧 - Strategic Choice</h3>
<div class="outline-text-3" id="text-5-9">
<p>
<a href="https://d.hatena.ne.jp/asakichy/20100205/1265329796">https://d.hatena.ne.jp/asakichy/20100205/1265329796</a>
</p>
</div>
</div>

<div id="outline-container-sec-5-10" class="outline-3">
<h3 id="sec-5-10"><span class="section-number-3">5.10</span> 七つの設計原理 - Strategic Choice</h3>
<div class="outline-text-3" id="text-5-10">
<p>
<a href="https://d.hatena.ne.jp/asakichy/20090806/1249526499">https://d.hatena.ne.jp/asakichy/20090806/1249526499</a>
</p>
</div>
</div>

<div id="outline-container-sec-5-11" class="outline-3">
<h3 id="sec-5-11"><span class="section-number-3">5.11</span> 漏れのある抽象化の法則 - Strategic Choice</h3>
<div class="outline-text-3" id="text-5-11">
<p>
<a href="https://d.hatena.ne.jp/asakichy/20160729/1469743543">https://d.hatena.ne.jp/asakichy/20160729/1469743543</a>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: suzuki@cis.iwate-u.ac.jp</p>
<p class="date">Created: 2016-12-11 日 19:09</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 25.1.1 (<a href="https://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
