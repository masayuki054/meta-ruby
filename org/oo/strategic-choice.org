* Strategic Choice を読もう

** 記事一覧
http://d.hatena.ne.jp/asakichy/archive

** 構造化プログラミング


■[構造化プログラミング]構造化プログラミング入門

構造化プログラミング

構造化とは、構造のない、いわば行き当たりばったりのものを、指針に基づいた構造へと整理する作
 業。 

 * オブジェクト指向も、オブジェクトという構造に整理するという1つの構造化であるといえる。 

現在でも見通しの良い整理されたコードを書くにあたって、構造化プログラミングは有効に作用する。

定義

 1つの入り口と1つの出口を持つようなプログラムは「順次・反復・分岐」の3つの基本的な論理構造
 によって記述できる

基本手段

   - 基本3構造 

     * 順次（連接） 
     * 反復（繰り返し） 
     * 分岐 

   - 段階的詳細化 

     * 言葉どおりに捉えれば段階的に詳細にしていくということ 
     * つまりトップダウンで詳細化するということ 
     * 基準が必要 

     * 凝集度 
     * 結合度 

取上理由

   - 構造化プログラミングにおけるトップダウンの機能分解には、確かに問題がある。 

     * この問題がオブジェクト指向の動機にもなっている。 

   - ただし、構造化プログラミングの実装部分のエッセンス（特に凝集度・結合度の考え方）は今でも参考
     になる。 

     * [構造化プログラミング]段階的詳細化 
     * [構造化プログラミング]凝集度 
     * [構造化プログラミング]結合度 


** パルナスの規則

> モジュールの利用者には、そのモジュールを利用するために必要なすべての
> 情報を与え、それ以外の情報は一切見せないこと。

> モジュールの作成者には、そのモジュールを実装するために必要なすべての
> 情報を与え、それ以外の情報は一切見せないこと。

*** 解釈

インターフェイスと実装の分離を行い、情報隠蔽またはカプセル化を実現する。 

*** なんで？

システムの部分同士は最小かつ明快なつながりで結ばれていることが望ましい。

- 内部を知らなくても使える（再利用） 
- 利用者に影響を与えず実装を入れ替えることが出来る（保守） 




** 抽象データ型 - Strategic Choice

http://d.hatena.ne.jp/asakichy/20090225/1235547089

abstract data type (ADT)

*** どういうこと？

- 型定義を公開できること。 

  * プログラマがデータ型を定義。 

- インスタンスに対する操作が利用出来ること。 

  * 「do(data)」ではなく「data.do()」。 

- 内部のデータを保護し、上記の操作のみがアクセス出来ること。 

  * 情報隠蔽。 

- 複数のインスタンスを作れること。 

  * マルチプルインスタンス。 

*** モジュールとの関連

- モジュールで情報隠蔽までは可能だった。（パルナスの規則） 
- しかし複数インスタンスが作れない。 
- これを満たすのがADT。 

*** クラスとの関連

- クラスは，抽象データ型を実現するもの
- これに加えて，下記を特徴として持つ:
  - *継承* 
  - *ポリモーフィズム* ((s-:?))


** オブジェクト指向の本懐 - Strategic Choice
http://d.hatena.ne.jp/asakichy/20090421/1240277448

*** ソフトウエア開発プロセスの観点 -- オブジェクト指向の本懐（４）

 オブジェクト指向の考察の前提知識， 
 マーチン・ファウラー「UMLモデリングのエッセンス」で提唱

**** 概念(conceptual) 

  - 調査対象領域における概念を表現。 
  - 実装とは関係なく導き出される。 
  - 「私は何に対して責任があるのか？」 

**** 仕様(specification) 

  - ソフトウェアを考慮。 
  - 実装ではなく、インターフェイスの考慮 。 
  - 「私はどのように使用されるのか？」 

**** 実装(implementation) 

 - ソースコード自体を考慮。 
 - 上の2つを考えた後。 
 - 「私はどのように自身の責任を全うするのか？」 

 この観点の使い分けが非常に重要

 - 概念レベルでコミュニケーションを取とると、お互いの詳細は知らなくて良
   いことになります。

 - 設計はまずここで考えることになります。すなわちソフトウェア以下は考慮
   しません。

 - すると設計アウトプットにおいて、使用者に概念をそのままにして実装を変
   更できるため、結果的に使用者に対して（発生しやすい変更である）実装変
   更から守ることになります。

**** オブジェクトとソフトウエア開発プロセスの観点の間のマッピング

 ソフトウェア開発プロセスの観点とオブジェクト指向設計がよくマッチするから。
 以下にオブジェクトと観点のマッピングを示す:

***** 概念レベル 
      - オブジェクトは責任の集合 

***** 仕様レベル 
      - オブジェクトはその他のオブジェクトや自ら起動することが出来るメ
        ソッドの集合

***** 実装レベル 
      - オブジェクトはコードとデータ、それらの相互演算処理

 そしてこの観点の使い分けがわかると、既存の開発手法から「オブジェクト指
 向（の本質）」にパラダイムシフトし易くなります。


** オブジェクト指向設計原則 - Strategic Choice
http://d.hatena.ne.jp/asakichy/20090122/1232879842

** プログラミング原則 [Unix思想] - Strategic Choice
http://d.hatena.ne.jp/asakichy/searchdiary?word=%2A%5BUnix%BB%D7%C1%DB%5D

** ソフトウェア開発の真実とウソ - Strategic Choice
ohttp://d.hatena.ne.jp/asakichy/20131007/1381097627

** ソフトウェア開発原則一覧 - Strategic Choice
http://d.hatena.ne.jp/asakichy/20100205/1265329796

** 七つの設計原理 - Strategic Choice
http://d.hatena.ne.jp/asakichy/20090806/1249526499

** 漏れのある抽象化の法則 - Strategic Choice
http://d.hatena.ne.jp/asakichy/20160729/1469743543



