* Strategic Choice を読もう

http://d.hatena.ne.jp/asakichy/archive
を読んで，まとめをつくり，自分の理解を作りましょう。

** 記事一覧
http://d.hatena.ne.jp/asakichy/archive

** 構造化プログラミング


*** 構造化プログラミング入門

構造化とは、構造のない、いわば行き当たりばったりのものを、指針に基づい
た構造へと整理する作業。

オブジェクト指向も、オブジェクトという構造に整理するという1つの構造化であるといえる。 

現在でも見通しの良い整理されたコードを書くにあたって、構造化プログラミングは有効に作用する。

**** 定義

1つの入り口と1つの出口を持つようなプログラムは「順次・反復・分岐」の3
つの基本的な論理構造によって記述できる

**** 基本手段

   - 基本3構造 

     * 順次（連接）
     * 反復（繰り返し） 
     * 分岐 

   - 段階的詳細化 

     * 言葉どおりに捉えれば段階的に詳細にしていくということ 
     * つまりトップダウンで詳細化するということ 
     * 基準が必要 
       * 凝集度 
       * 結合度 

**** 取上理由

   - 構造化プログラミングにおけるトップダウンの機能分解には、確かに問題がある。 

     * この問題がオブジェクト指向の動機にもなっている。 

   - ただし、構造化プログラミングの実装部分のエッセンス（特に凝集度・結合度の考え方）は今でも参考
     になる。 

     * 構造化プログラミング -- 段階的詳細化 
       [[http://d.hatena.ne.jp/asakichy/20090217/1234830611][段階的詳細化 - Strategic Choice]]

     * 構造化プログラミング -- 凝集度 
       [[http://d.hatena.ne.jp/asakichy/20090218/1234990542][凝集度 - Strategic Choice]]

     * 構造化プログラミング -- 結合度 
       [[http://d.hatena.ne.jp/asakichy/20090219/1234936956       ][結合度 - Strategic Choice]]

** パルナスの規則

> モジュールの利用者には、そのモジュールを利用するために必要なすべての
> 情報を与え、それ以外の情報は一切見せないこと。

> モジュールの作成者には、そのモジュールを実装するために必要なすべての
> 情報を与え、それ以外の情報は一切見せないこと。

*** 解釈

インターフェイスと実装の分離を行い、情報隠蔽またはカプセル化を実現する。 

*** なんで？

システムの部分同士は最小かつ明快なつながりで結ばれていることが望ましい。

- 内部を知らなくても使える（再利用） 
- 利用者に影響を与えず実装を入れ替えることが出来る（保守） 




** 抽象データ型 - Strategic Choice

http://d.hatena.ne.jp/asakichy/20090225/1235547089

abstract data type (ADT)

*** どういうこと？

- 型定義を公開できること。 

  * プログラマがデータ型を定義。 

- インスタンスに対する操作が利用出来ること。 

  * 「do(data)」ではなく「data.do()」。 

- 内部のデータを保護し、上記の操作のみがアクセス出来ること。 

  * 情報隠蔽。 

- 複数のインスタンスを作れること。 

  * マルチプルインスタンス。 

*** モジュールとの関連

- モジュールで情報隠蔽までは可能だった。（パルナスの規則） 
- しかし複数インスタンスが作れない。 
- これを満たすのがADT。 

*** クラスとの関連

- クラスは，抽象データ型を実現するもの
- これに加えて，下記を特徴として持つ:
  - *継承* 
  - *ポリモーフィズム* ((s-:?))


** オブジェクト指向の本懐 - Strategic Choice
http://d.hatena.ne.jp/asakichy/20090421/1240277448

*** オブジェクト指向前 -- オブジェクト指向の本懐（２）・

**** 機能分解  

「構造化プログラミング」時代と呼ばれ、
機能分解（functional decomposition）の手法がとられていました。

- 問題を小さな機能にブレークダウンしていき、複雑さを回避しようとするアプローチで
  す。

- 図にするとピラミッドストラクチャのようになります。

- ブレークダウンされるごとに凝集度は高まり、見通しも良くなるので自然と複雑度は下がります。

しかし、ここには落とし穴がありました。

- このアプローチでは、結果的に「メイン」モジュールが必要となります。

  機能の組合わせとその呼び出し順を正し
  く制御する、大きな責任を持ったモジュールです。

- こういった構造になっていると、モジュールの変更が制御できなくなります。
  
  「他の関数」「データ」「やり取り」「順番」等、注意を払うべき項目が多
  すぎるからです。

- 機能やデータを変更すると、他の機能や他のデータに影響が及び、それがま
  た他の機能に影響を及ぼすという修正の連鎖が「芋蔓式」に発生し、「将棋
  倒し」が起こります。

- その中でも特に影響が大きいのが「データ」の変更についてで、

  データが機能に従属して拡散してしまっているため（方々で使っているだけ
  でなく、引数による上下渡り歩きも含む）、影響範囲の見極めが非常に困難
  になります。

**** 好ましくない副作用

この時代、多くのバグが、変更によって生み出されていました。

- 変更による不具合のことを「好ましくない副作用」といいます。

- 機能に注力することは、発見しにくい副作用を生み出す近道になってしまう
  のです。

- そして保守作業とデバッグ作業にかかる時間の大半は、バグの除去に充てら
  れる時間ではなく、バグの発見、および修正によって生み出された好ましく
  ない副作用の回避手段を考え出す時間に充てられていました。

つまり、機能分解は、ソフトウェアライフサイクルに常備されている「変更」
というイベントにおいて、例えばバグ修正時であれば二次バグ、機能追加時で
あればデグレードの発生など、常に危険に晒されている手法だということです。

そして、本来使うべき開発そのものの時間ではなく、この副作用の収束に多く
の時間を取られるという形で問題が顕在化したのです。

**** オブジェクト指向へ

変更は必ず発生するものです。

どう変わるかはわかりませんが、どこが変わりそうかはある程度予想できるの
です。

そこでオブジェクト指向が登場します。

**** 機能とデータ

書籍「オブジェクト指向入門」の中でトップダウン機能分解の弊害に言及して
います。

#+BEGIN_QUOTE

    オブジェクト指向でないアプローチでは何の抵抗もされずに、機能がデー
    タを支配するが、その後データが「復讐」を始めた。復讐はサボタージュ
    の形で現れた。アーキテクチャの基礎そのものを攻撃することによって、
    データはシステムを変更に耐えられないようにした。

#+END_QUOTE

トップダウンの機能階層図は一見きれいですが、実はごちゃ混ぜのデータ転送
が含まれており、変更時は管理不能に陥ってしまいます。

**** デグレードの原因

変更して、その変更が原因で、元の機能に不具合が発生してしまうのがデグレー
ドです。このデグレードが発生した時、私は「もう少し気をつけて修正すれば」
とか「もっと慎重に修正すればよかった」と反省してしまいます。しかし、そ
もそもの根本原因は、修正方法よりもその設計にあることが多いという実感が
あります。

そこに気が付いて、「割れ窓理論」（＠書籍「達人プログラマー」）に陥らな
いよう、変更に強い設計に改善していかなければなりません。

そのためのオブジェクト指向だと思っています。

*** オブジェクト指向黎明期の誤解 -- オブジェクト指向の本懐（３）・

[[http://d.hatena.ne.jp/asakichy/20090424/1240533845][オブジェクト指向黎明期の誤解 - Strategic Choice]]

オブジェクト指向も最初から正しく活用されていたわけではありませんでした。

**** 代表的な誤解

- オブジェクトとはデータ＋操作である。

- カプセル化とはデータの隠蔽である。

- 継承は特殊化と再利用の手段である。

これらはもっともらしく見えますが、本質ではありません。

#+BEGIN_QUOTE
((s-:)) 実装寄りの見方なんですね。
#+END_QUOTE


**** オブジェクト指向の正しい理解

正しい理解は以下になります。

- オブジェクトとは責務である。

- カプセル化とは流動的要素の隠蔽である。

- 継承はオブジェクトを分類する手段である。

#+BEGIN_QUOTE
((s-:)) 概念・仕様レベルの見方ですね。
#+END_QUOTE


***** カプセル化の意味

「カプセル化、情報隠蔽、データ隠蔽」という用語は、余りにも意味が揺れて
いるため、はっきりとしたことは言えないようです。

#+BEGIN_QUOTE
((s-:)) すべての機能をモジュールの中に閉じ込め，公開インタフェースを通
してのみ，利用可能にすること。
#+END_QUOTE


***** オブジェクト指向のウソについて

オブジェクト指向の黎明期は、その特徴について以下のように喧伝されていました。

    - 現実世界をそのままモデリング（クラス化）できる。

    - 実装は簡単で、属人性も排除できる。

    - 差分プログラミングで簡単に再利用できる。

しかし、これらはウソないし本質ではないことは明らかです。

1. モデリング

   - 例えばコンパイラを作ろうとしたら現実にある
     ものは1つもでてきません。
#+BEGIN_QUOTE
     ((s-:)) いっぱいでてきますよ。文法，構文木，生成規則，... 
#+END_QUOTE


   - モデリングは「捨象」です。つまり、抽象化してほとんどの部分を捨て
     てしまいます。「そのまま」クラスにはなりません。

     #+BEGIN_QUOTE
     ((s-:)) 本質的なものだけを残すのがモデリングで，それはクラスに
     なります。
     #+END_QUOTE

   - デザインパターンにおいて、その登場クラスのほとんどは「人工品」で、
     現実世界には存在しません。

     #+BEGIN_QUOTE
     ((s-:)) 人工物も一度できれば現実です。
     #+END_QUOTE

2. 実装は簡単で、属人性も排除できる

   - 言語仕様的に便利になった部分（典型的にはC→Javaのメモリ管理）で従
     来よりは品質上がるのでしょうが、

     #+BEGIN_QUOTE
     ((s-:)) 簡単さは，なんといっても再利用が簡単になることじゃない
     かなぁ。
     #+END_QUOTE

   - 余りにも実装寄りの話でオブジェクト指向の本質とは全く関係ありませ
     んので、根拠に乏しいと思います。

     #+BEGIN_QUOTE
     ((s-:)) 属人性を，メッセージングで解決することでは？
     #+END_QUOTE

3. 差分プログラミングで簡単に再利用できる

   - 「よく似た既存クラスがあれば、それを継承し、違う部分だけを実装すれ
     ば再利用できる」という主張で、確かにそういった一面はあると思います。
     しかしこれも実装面から見た話ですし、

     #+BEGIN_QUOTE
     ((s-:)) 差のみを書くことには，積極的な意味があると思います。
     #+END_QUOTE

   - 差分プログラミングそのものはオブジェクト指向（言語）でなくても可
     能です。

   - さらに、継承を紡いでいく拡張には設計的にも実装的にも問題点があり
     ます。

     #+BEGIN_QUOTE
     ((s-:)) 問題の構造がそうなら，継承を紡いでいく拡張が正しいのだと
     思います。
     #+END_QUOTE

*** ソフトウエア開発プロセスの観点 -- オブジェクト指向の本懐（４）

 オブジェクト指向の考察の前提知識， 
 マーチン・ファウラー「UMLモデリングのエッセンス」で提唱

**** 概念(conceptual) 

  - 調査対象領域における概念を表現。 
  - 実装とは関係なく導き出される。 
  - 「私は何に対して責任があるのか？」 

**** 仕様(specification) 

  - ソフトウェアを考慮。 
  - 実装ではなく、インターフェイスの考慮 。 
  - 「私はどのように使用されるのか？」 

**** 実装(implementation) 

 - ソースコード自体を考慮。 
 - 上の2つを考えた後。 
 - 「私はどのように自身の責任を全うするのか？」 

 この観点の使い分けが非常に重要

 - 概念レベルでコミュニケーションを取とると、お互いの詳細は知らなくて良
   いことになります。

 - 設計はまずここで考えることになります。すなわちソフトウェア以下は考慮
   しません。

 - すると設計アウトプットにおいて、使用者に概念をそのままにして実装を変
   更できるため、結果的に使用者に対して（発生しやすい変更である）実装変
   更から守ることになります。

**** オブジェクトとソフトウエア開発プロセスの観点の間のマッピング

 ソフトウェア開発プロセスの観点とオブジェクト指向設計がよくマッチするから。
 以下にオブジェクトと観点のマッピングを示す:

***** 概念レベル 
      - オブジェクトは責任の集合 

***** 仕様レベル 
      - オブジェクトはその他のオブジェクトや自ら起動することが出来るメ
        ソッドの集合

***** 実装レベル 
      - オブジェクトはコードとデータ、それらの相互演算処理

 そしてこの観点の使い分けがわかると、既存の開発手法から「オブジェクト指
 向（の本質）」にパラダイムシフトし易くなります。


*** オブジェクト指向パラダイム -- オブジェクト指向の本懐（５）

**** オブジェクトとは責任である

オブジェクト指向では、機能に分解するのではなく、 *オブジェクト * に分解
します。

オブジェクトとは「データ＋操作」ではありません。

- 決して「賢いデータ」程度の物ではないのです。

- これは実装の観点からしか見ていない、狭いものの見
  方です。

それではオブジェクトとは何か。

- オブジェクトとは *責任* です。責務を備えた実体です。

- それは *概念レベル*，*仕様レベル* から考察した結果導き出されるもので
  す。実装レベルを混ぜてはいけません。

- *オブジェクトがどう実装されるか* ではなく
  *オブジェクトが何を実行するのか*に着目しなければならないのです。

**** 開発の手順

オブジェクト指向に沿ったソフトウェア開発の手順はこうなります。

1. 詳細をすべて考慮することなく、予備的な設計を行う
2. その設計を実装する

つまり、

1. まず概念レベル（＝責任）で考えることになります。

2. そして、責任を果たすために、他のオブジェクトが使用するためのインター
   フェイスを考えます。

   これを *公開インターフェイス* といいます。

   実装をそのインターフェイスの背後に隠蔽することで、実装とそれを使用
   するオブジェクトを分離しているのです。

実装レベルで考えているだけだと、結局機能分解の時と同じ問題が発生します。

- つまり、変更から守られないということです。

- 差分プログラミング的な、誤解されたオブジェクト指向もこの範疇に入ります。

一方、概念レベルでコミュニケーションをはかり、別のレベルで（実装）要求
を遂行する、という風に分けて考えると、

- リクエストする側は何が起こるかの概略だけ知っていればよいことになります。

- つまり、その概略（責任・インターフェイス）をそのままに、実装詳細の変
  更から、リクエスト側を守ることができるということです。

**** 補足

***** 変更はいつするのか？

 書籍「達人プログラマー」では、DRY原則の説明の中で、メンテナンスについてこういっています。

 #+BEGIN_QUOTE

     メンテナンスとは「バグの修正と機能拡張であり、アプリケーションがリ
     リースされた時から始まるものである」という考えは間違いです。

     プログラマーは常に「メンテナンス・モード」であり、理解は日々変わっ
     ていくものです。

     設計やコーディング中でも新たな要求が発生するため、メンテナンスと開
     発工程は分けて考えられるものではなく、メンテナンスはすべての開発工
     程を通じて行う日常業務なのです。

 #+END_QUOTE

 いわゆる製品リリース後をメンテナンスと捉えるのではなく、新しい製品の開
 発中も含めてメンテナンスと言っています。

 つまり * 変更は常時 * ということです。


***** 変更に本当につよいのか？

 私はオブジェクト指向が変更に強いと言われても最初はなかなか実感が湧きま
 せんでした。なぜならその実例がないからです。

 書籍のサンプルには、当たり前ですが「仕様変更」や「追加要求」がありませ
 ん。変更に強く、それが目的あると言われてもピンとこないのも無理はないの
 です。

 しかし、それをやっと実感できたのが「デザインパターンとともに学ぶオブジェ
 クト指向のこころ」を読んだ時でした。




*** オブジェクト指向技術 - オブジェクト指向の本懐（６）
オブジェクト指向の「見方」はわかりました。

次はどうやって実現するかの「手段」部分です。

**** クラスとは

オブジェクトの共通する作業やデータをオブジェクト毎に持たせるのは効率的
ではありません。そこで「クラス」を使用します。クラスには以下の要素が含
まれています。

- オブジェクトが保持するデータ項目
- オブジェクトが実行出来るメソッド
- データ項目やメソッドにアクセスするための方法

**** 型としてのクラス

クラスは「抽象データ型（abstract data type : ADT)」の機能を持っていま
す。抽象データ型の表現方法がクラスといってもいいかもしれません。
抽象データ型は以下の特徴をもっています。

    - 型定義を公開できること。
        - プログラマがデータ型を定義。
    - インスタンスに対する操作が利用出来ること。
        - 「do(data)」ではなく「data.do()」。
    - 内部のデータを保護し、上記の操作のみがアクセス出来ること。
        - 情報隠蔽。
    - 複数のインスタンスを作れること。
        - マルチプルインスタンス。

**** 継承の用途

ある型のグループを包含するような汎用の型、つまり抽象型の必要性がで
てきます。これがいわゆる抽象クラス（基底クラス）と呼ばれるもので、それ
を継承しているそれぞれの型は具象クラスと呼ばれます。

抽象クラスは、それが表現している概念を具体化したクラスの実装を格納する
ための場所を提供する、という意味です。

つまり、抽象クラスによって関連のあるクラス群に名前を割り当てる方法が与
えられ、関連のあるクラス群を１つの概念として扱えるようになるわけです。
継承はこのように「オブジェクトの分類」に使用します。

**** 継承の問題点

「継承は特殊化と再利用の手段である」というのは本質ではありません。濫用
すると問題があります。

例をあげます。図形で5角形を表現するPentagonクラスがあるとします。ここ
で継承を使って「縁」機能を持つPentagonBorderを作成します。すると、以下
のような不具合が発生します。

    - 凝集度が低下する可能性がある
        - Pentagonの責任にBorderは関係ない。
    - 再利用の可能性が低下する
        - 縁機能ロジックが他の図形で再利用出来ない。
    - 変化に追随できない
        - 違った観点の変更に対応出来ない。
        - 次に「網掛け」機能が必要になったら、クラスの組合わせが爆発してくる。

継承はかつて実装的側面で語られることが多かったといいます。しかし、いわ
ゆる「差分プログラミング」と称して推奨された特化の継承にはこのような問
題点もあったわけです。

これ以外にも、継承に関して多くの問題点が指摘されています。そのキーはや
はり「責任」という概念だと思います。オブジェクトは「責任」であり、さら
に責任とは「責任をもった者同士の委譲である」といいます。

継承は同じ責任内で働くため、委譲をうまく取り扱えません。

**** カプセル化とは

カプセル化は、オブジェクトが自らのことに対して責任を持ち、必要のない物
は見せない、という事です。

カプセル化はあらゆる種類の隠蔽を意味しています。例えば以下のようなこと
も含んでいます:

    - 派生クラス
        - ポリモーフィズムにより、実際の具象クラスを知らなくても良い。
        - 「型のカプセル化」（抽象が具象を隠してる）といえる。

    - 実装
        - 実装する側は、インターフェイスが決まっているので、呼び出し側
          を気にしないで変更出来る。
        - 「メソッド（実装）のカプセル化」（メソッドの実装を隠せる）といえる。

    - 設計の詳細
        - 使用する方から、その詳細を気にしなくても良いようにする。
        - 「メソッド（使用）のカプセル化」（メソッドの実装を気にしない）
          といえる。

    - 実体化の規則
        - 別途実体化専門の役割がいて、使用する側は気にしなくても良い。
        - 「生成のカプセル化」といえる。

    - サービス
        - アダプタオブジェクトの背後の何かを隠し、実際に動作しているサー
          ビスクラスを使用する側は気にしなくて良い。
        - 「オブジェクトのカプセル化」といえる。

**** オブジェクト指向技術の目的

オブジェクト指向技術を使うとき重要なのは「変更に強いソフトウェアを作る」
という目的意識です。

「変更に強いソフトウェアを作る」には、流動的要素をカプセル化します。

そこ以外の部分を再利用することができます。

**** オブジェクトの変遷

分析・設計時は責任を考えながらオブジェクトを考え、ソースコードではそれ
がクラスになり、実行時にはそのクラスのインスタンスとなります。クラスの
インスタンスはオブジェクトとも言いますので、ややこしいです。

**** 継承のポテンシャル

継承はパワフルで、その種類も豊富です。

- 「オブジェクト指向プログラqミング入門」では「継承の形態（7.3）」で8種
  類の継承が、

- 「オブジェクト指向入門」では「継承の使用（24.5）」で12カテゴリの正し
  い継承の使い方が紹介されています。

今の私は、様々な情報から

- 「継承のようなクラス間の静的な関係より、オブジェクト間の動的で柔軟な
  関係の方がよい」

- 「役割を継承でつくるとクラスが爆発する」

- 「多重継承なんて○○○」など「継承＜委譲」と洗脳されています

が、継承もしっかり理解して使えば、思っている以上に強力な武器なのか
もしれません。

http://cdn-ak.f.st-hatena.com/images/fotolife/g/glass-_-onion/20090528/20090528180021.png

***** 継承の種類   [[http://glassonion.hatenablog.com/entry/20090528/1243500914][継承の種類 - A Day In The Life]]

継承の方法を12種類に分類している

-  モデル継承

   -  部分継承
   -  拡張継承
   -  制約継承
   -  ビュー継承

-  バリエーション継承

   -  型バリエーション継承
   -  ファンクショナルバリエーション継承
   -  無効化継承

-  ソフトウェア継承

   -  具体化継承
   -  構造継承
   -  実装継承
   -  共有性質継承

      -  定数継承
      -  マシン継承

**** マルチプルインスタンス

データ項目をオブジェクト毎に保持し、メソッドは共通に使用できる仕組みは
マルチプルインスタンスが実現しています。このマルチプルインスタンスにつ
いては「疑りぶかいあなたのためのオブジェクト指向再入門＠前橋さん」に詳
しく説明されています。その中で「オブジェクト指向の本質はマルチプルイン
スタンスにこそある」と主張されていて、その結論を導いた道程が詳しく書い
てあります。

*** [[http://d.hatena.ne.jp/asakichy/20090428/1240878836][オブジェクト指向分析 -- オブジェクト指向の本懐（７）]]

**** 共通性/可変性分析 （commonality/variability analysis）

クラスを抽出していく方法。

- 問題領域の「どこ」が流動要素となるのかを識別し（共通性）、

- その後、それらが「どのように」変化するかを識別します（可変性）。

 それには

- まず「ファミリ構成員」を探します。

  これが共通性です。

- そして次に構成員がどのように違っているかを明らかにします。

  これが可変性です。可変性は共通性のコンテキストの中でのみ意味を持ちま
  す。

つまり、

- 問題領域中の特定部分に流動的要素がある場合、

  - 共通性分析によってそれらをまとめる概念が定義できることになり、

  - これが抽象クラスです。

この後、

- 可変性分析によって洗い出された流動的要素が

  具象クラスです。

**** 共通性/可変性分析と観点とクラスの関係

 「共通性/可変性分析」は

- 「ソフトウェア開発の観点」と

- 「クラス階層」にあてはめることができます。

***** AbstractClassは、

これらのオブジェクトが行わなければならないこと（概念上の観点）に着目す
ることで、それらの呼び出し方法（仕様上の観点）を決定することができます。

***** ConcreteClassは、

これらのクラスを実装する際、正しい実装と分割が可能になるよう、APIは十
分な情報の提供を保証しなければなりません。

***** 「仕様上の観点」は、

共通性/可変性分析どちらの観点も含んでいることにな
ります。

***** 仕様上の観点と概念上の観点の関係

- 仕様上の観点によって、ある概念に存在するケースすべてを取り扱うため
  のインターフェイスが洗い出せます。

- つまり共通性によって、概念上の観点が定義されます。

***** 仕様上の観点と実装上の観点の関係

- ある仕様が与えられた場合、その特定ケース（可変性）における実装方法
  を決定することができます。

**** 動詞/名詞抽出作戦

オブジェクト指向黎明期、要求仕様の文章から「動詞」と「名詞」を抽出し、
それを元にクラスを設計していた。

- これは要求仕様に（＝現実世界に）全てのクラスが埋まっているわけではな
  いので、当然うまくいかないことになります。

  - ((s-:)) 完全ではないけれど，とっかかりには最適な方法だと，僕は思っ
    ている。

- 要求仕様に完全網羅性は期待できませんし、自然言語で書かれていて、かつ
  その書式で変更されていくものなので、これを基に設計をするのは労多くし
  て功少なしです。

  - ((s-:)) では何を基に？ 

「オブジェクト指向入門」での抽象クラスを見つける方法についての言及:

#+BEGIN_QUOTE

   抽象を見つける方法は、知的発見（いわゆるユリイカ、そのための確実な
   方法は存在しない）の過程で見いだすか、あるいは誰かがすでに解決策
   を見つけている場合には、その人の抽象を再利用するかである。

#+END_QUOTE

より確実である後者は、まさにデザインパターンのことを言っているのでは
ないでしょうか。

*** オブジェクト指向の本懐 -- オブジェクト指向の本質]オブジェクト指向の本懐（８）

**** オブジェクト指向の本懐

オブジェクト指向の本懐は、

複雑さに勝ち、かつ「変更に勝つ」ことです。

この変更を考慮する設計アプローチがオブジェクト指向の本質です。


変更を考慮すると言っても、変更「内容」を正確に予測しようとしてはいけま
せん。

「どこに」変更が発生するかを予測するのが正しい姿勢です。

その変更「地点」を「流動的要素」と呼び、その取り扱いを考慮するアプロー
チです。

具体的なアプローチ法は、GoF本で紹介されている以下の原則が参考になります。

    - 実装を用いてプログラミングするのではなく、インターフェイスを用いて
      プログラミングしてください。

    - クラスの継承よりもオブジェクトの集約を多用してください。

    - 何を流動要素とするべきかを考察してください。

このようにデザインパターンの原則がオブジェクト指向の本質に近しくなって
います。

デザインパターンのテーマもやはり

- 「設計変更を強いる可能性のある物」が何かを考えるのではなく

- 「再設計をせずに何を変更可能にするのか」を考えることです。

- デザインパターンはオブジェクト指向上達のショートカットと言っています。

  オブジェクト指向のメリットをデザインパターンで釣り上げることができる
  のです。

まさに邦題通り「オブジェクト指向のこころ」は「デザインパターンで学べ」
ということです。


書籍「Code Complete」での 流動的要素への準備の手順

- どのように（How）変わるかではなく、

- どこが（Where）変わるのかを特定し、

- 分離し、囲い込む



** オブジェクト指向設計原則 - Strategic Choice
http://d.hatena.ne.jp/asakichy/20090122/1232879842

** プログラミング原則 Unix思想 - Strategic Choice
http://d.hatena.ne.jp/asakichy/searchdiary?word=%2A%5BUnix%BB%D7%C1%DB%5D

** ソフトウェア開発の真実とウソ - Strategic Choice
ohttp://d.hatena.ne.jp/asakichy/20131007/1381097627

** ソフトウェア開発原則一覧 - Strategic Choice
http://d.hatena.ne.jp/asakichy/20100205/1265329796

** 七つの設計原理 - Strategic Choice
http://d.hatena.ne.jp/asakichy/20090806/1249526499

** 漏れのある抽象化の法則 - Strategic Choice
http://d.hatena.ne.jp/asakichy/20160729/1469743543



