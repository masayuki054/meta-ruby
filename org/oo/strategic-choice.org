* Strategic Choice を読もう

** 記事一覧
http://d.hatena.ne.jp/asakichy/archive

** 構造化プログラミング


■[構造化プログラミング]構造化プログラミング入門

構造化プログラミング

構造化とは、構造のない、いわば行き当たりばったりのものを、指針に基づいた構造へと整理する作
 業。 

 * オブジェクト指向も、オブジェクトという構造に整理するという1つの構造化であるといえる。 

現在でも見通しの良い整理されたコードを書くにあたって、構造化プログラミングは有効に作用する。

定義

 1つの入り口と1つの出口を持つようなプログラムは「順次・反復・分岐」の3つの基本的な論理構造
 によって記述できる

基本手段

   - 基本3構造 

     * 順次（連接） 
     * 反復（繰り返し） 
     * 分岐 

   - 段階的詳細化 

     * 言葉どおりに捉えれば段階的に詳細にしていくということ 
     * つまりトップダウンで詳細化するということ 
     * 基準が必要 

     * 凝集度 
     * 結合度 

取上理由

   - 構造化プログラミングにおけるトップダウンの機能分解には、確かに問題がある。 

     * この問題がオブジェクト指向の動機にもなっている。 

   - ただし、構造化プログラミングの実装部分のエッセンス（特に凝集度・結合度の考え方）は今でも参考
     になる。 

     * [構造化プログラミング]段階的詳細化 
     * [構造化プログラミング]凝集度 
     * [構造化プログラミング]結合度 


** パルナスの規則

> モジュールの利用者には、そのモジュールを利用するために必要なすべての
> 情報を与え、それ以外の情報は一切見せないこと。

> モジュールの作成者には、そのモジュールを実装するために必要なすべての
> 情報を与え、それ以外の情報は一切見せないこと。

*** 解釈

インターフェイスと実装の分離を行い、情報隠蔽またはカプセル化を実現する。 

*** なんで？

システムの部分同士は最小かつ明快なつながりで結ばれていることが望ましい。

- 内部を知らなくても使える（再利用） 
- 利用者に影響を与えず実装を入れ替えることが出来る（保守） 




** 抽象データ型 - Strategic Choice

http://d.hatena.ne.jp/asakichy/20090225/1235547089

abstract data type (ADT)

*** どういうこと？

- 型定義を公開できること。 

  * プログラマがデータ型を定義。 

- インスタンスに対する操作が利用出来ること。 

  * 「do(data)」ではなく「data.do()」。 

- 内部のデータを保護し、上記の操作のみがアクセス出来ること。 

  * 情報隠蔽。 

- 複数のインスタンスを作れること。 

  * マルチプルインスタンス。 

*** モジュールとの関連

- モジュールで情報隠蔽までは可能だった。（パルナスの規則） 
- しかし複数インスタンスが作れない。 
- これを満たすのがADT。 

*** クラスとの関連

- クラスは，抽象データ型を実現するもの
- これに加えて，下記を特徴として持つ:
  - *継承* 
  - *ポリモーフィズム* ((s-:?))


** オブジェクト指向の本懐 - Strategic Choice
http://d.hatena.ne.jp/asakichy/20090421/1240277448

*** ソフトウエア開発プロセスの観点 -- オブジェクト指向の本懐（４）

 オブジェクト指向の考察の前提知識， 
 マーチン・ファウラー「UMLモデリングのエッセンス」で提唱

**** 概念(conceptual) 

  - 調査対象領域における概念を表現。 
  - 実装とは関係なく導き出される。 
  - 「私は何に対して責任があるのか？」 

**** 仕様(specification) 

  - ソフトウェアを考慮。 
  - 実装ではなく、インターフェイスの考慮 。 
  - 「私はどのように使用されるのか？」 

**** 実装(implementation) 

 - ソースコード自体を考慮。 
 - 上の2つを考えた後。 
 - 「私はどのように自身の責任を全うするのか？」 

 この観点の使い分けが非常に重要

 - 概念レベルでコミュニケーションを取とると、お互いの詳細は知らなくて良
   いことになります。

 - 設計はまずここで考えることになります。すなわちソフトウェア以下は考慮
   しません。

 - すると設計アウトプットにおいて、使用者に概念をそのままにして実装を変
   更できるため、結果的に使用者に対して（発生しやすい変更である）実装変
   更から守ることになります。

**** オブジェクトとソフトウエア開発プロセスの観点の間のマッピング

 ソフトウェア開発プロセスの観点とオブジェクト指向設計がよくマッチするから。
 以下にオブジェクトと観点のマッピングを示す:

***** 概念レベル 
      - オブジェクトは責任の集合 

***** 仕様レベル 
      - オブジェクトはその他のオブジェクトや自ら起動することが出来るメ
        ソッドの集合

***** 実装レベル 
      - オブジェクトはコードとデータ、それらの相互演算処理

 そしてこの観点の使い分けがわかると、既存の開発手法から「オブジェクト指
 向（の本質）」にパラダイムシフトし易くなります。

*** オブジェクト指向黎明期の誤解 -- オブジェクト指向の本懐（３）・

[[http://d.hatena.ne.jp/asakichy/20090424/1240533845][オブジェクト指向黎明期の誤解 - Strategic Choice]]

オブジェクト指向も最初から正しく活用されていたわけではありませんでした。

**** 代表的な誤解

- オブジェクトとはデータ＋操作である。

- カプセル化とはデータの隠蔽である。

- 継承は特殊化と再利用の手段である。

これらはもっともらしく見えますが、本質ではありません。

((s-:)) 実装寄りの見方なんですね。

**** オブジェクト指向の正しい理解

正しい理解は以下になります。

- オブジェクトとは責務である。

- カプセル化とは流動的要素の隠蔽である。

- 継承はオブジェクトを分類する手段である。

((s-:)) 概念・仕様レベルの見方ですね。

***** カプセル化の意味

「カプセル化、情報隠蔽、データ隠蔽」という用語は、余りにも意味が揺れて
いるため、はっきりとしたことは言えないようです。

((s-:)) すべての機能をモジュールの中に閉じ込め，公開インタフェースを通
してのみ，利用可能にすること。

***** オブジェクト指向のウソについて

オブジェクト指向の黎明期は、その特徴について以下のように喧伝されていました。

    - 現実世界をそのままモデリング（クラス化）できる。

    - 実装は簡単で、属人性も排除できる。

    - 差分プログラミングで簡単に再利用できる。

しかし、これらはウソないし本質ではないことは明らかです。

1. モデリング

   - 例えばコンパイラを作ろうとしたら現実にある
     ものは1つもでてきません。

     - ((s-:)) いっぱいでてきますよ。文法，構文木，生成規則，... 

   - モデリングは「捨象」です。つまり、抽象化してほとんどの部分を捨て
     てしまいます。「そのまま」クラスにはなりません。

     - ((s-:)) 本質的なものだけを残すのがモデリングで，それはクラスに
       なります。

   - デザインパターンにおいて、その登場クラスのほとんどは「人工品」で、
     現実世界には存在しません。

     - ((s-:)) 人工物も一度できれば現実です。

2. 実装は簡単で、属人性も排除できる

   - 言語仕様的に便利になった部分（典型的にはC→Javaのメモリ管理）で従
     来よりは品質上がるのでしょうが、

     - ((s-:)) 簡単さは，なんといっても再利用が簡単になることじゃない
       かなぁ。

   - 余りにも実装寄りの話でオブジェクト指向の本質とは全く関係ありませ
     んので、根拠に乏しいと思います。

     - ((s-:)) 属人性を，メッセージングで解決することでは？

3. 差分プログラミングで簡単に再利用できる

   - 「よく似た既存クラスがあれば、それを継承し、違う部分だけを実装すれ
     ば再利用できる」という主張で、確かにそういった一面はあると思います。
     しかしこれも実装面から見た話ですし、

     - ((s-:)) 差のみを書くことには，積極的な意味があると思います。

   - 差分プログラミングそのものはオブジェクト指向（言語）でなくても可
     能です。

   - さらに、継承を紡いでいく拡張には設計的にも実装的にも問題点があり
     ます。

     - ((s-:)) 問題の構造がそうなら，継承を紡いでいく拡張が正しいのだ
       と思います。

** オブジェクト指向設計原則 - Strategic Choice
http://d.hatena.ne.jp/asakichy/20090122/1232879842

** プログラミング原則 [Unix思想] - Strategic Choice
http://d.hatena.ne.jp/asakichy/searchdiary?word=%2A%5BUnix%BB%D7%C1%DB%5D

** ソフトウェア開発の真実とウソ - Strategic Choice
ohttp://d.hatena.ne.jp/asakichy/20131007/1381097627

** ソフトウェア開発原則一覧 - Strategic Choice
http://d.hatena.ne.jp/asakichy/20100205/1265329796

** 七つの設計原理 - Strategic Choice
http://d.hatena.ne.jp/asakichy/20090806/1249526499

** 漏れのある抽象化の法則 - Strategic Choice
http://d.hatena.ne.jp/asakichy/20160729/1469743543



