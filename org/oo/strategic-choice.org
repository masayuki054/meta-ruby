* Strategic Choice を読もう

** 記事一覧
http://d.hatena.ne.jp/asakichy/archive

** 構造化プログラミング


■[構造化プログラミング]構造化プログラミング入門

構造化プログラミング

構造化とは、構造のない、いわば行き当たりばったりのものを、指針に基づいた構造へと整理する作
 業。 

 * オブジェクト指向も、オブジェクトという構造に整理するという1つの構造化であるといえる。 

現在でも見通しの良い整理されたコードを書くにあたって、構造化プログラミングは有効に作用する。

定義

 1つの入り口と1つの出口を持つようなプログラムは「順次・反復・分岐」の3つの基本的な論理構造
 によって記述できる

基本手段

   - 基本3構造 

     * 順次（連接） 
     * 反復（繰り返し） 
     * 分岐 

   - 段階的詳細化 

     * 言葉どおりに捉えれば段階的に詳細にしていくということ 
     * つまりトップダウンで詳細化するということ 
     * 基準が必要 

     * 凝集度 
     * 結合度 

取上理由

   - 構造化プログラミングにおけるトップダウンの機能分解には、確かに問題がある。 

     * この問題がオブジェクト指向の動機にもなっている。 

   - ただし、構造化プログラミングの実装部分のエッセンス（特に凝集度・結合度の考え方）は今でも参考
     になる。 

     * [構造化プログラミング]段階的詳細化 
     * [構造化プログラミング]凝集度 
     * [構造化プログラミング]結合度 


** パルナスの規則

> モジュールの利用者には、そのモジュールを利用するために必要なすべての
> 情報を与え、それ以外の情報は一切見せないこと。

> モジュールの作成者には、そのモジュールを実装するために必要なすべての
> 情報を与え、それ以外の情報は一切見せないこと。

*** 解釈

インターフェイスと実装の分離を行い、情報隠蔽またはカプセル化を実現する。 

*** なんで？

システムの部分同士は最小かつ明快なつながりで結ばれていることが望ましい。

- 内部を知らなくても使える（再利用） 
- 利用者に影響を与えず実装を入れ替えることが出来る（保守） 




** 抽象データ型 - Strategic Choice

http://d.hatena.ne.jp/asakichy/20090225/1235547089

abstract data type (ADT)

*** どういうこと？

- 型定義を公開できること。 

  * プログラマがデータ型を定義。 

- インスタンスに対する操作が利用出来ること。 

  * 「do(data)」ではなく「data.do()」。 

- 内部のデータを保護し、上記の操作のみがアクセス出来ること。 

  * 情報隠蔽。 

- 複数のインスタンスを作れること。 

  * マルチプルインスタンス。 

*** モジュールとの関連

- モジュールで情報隠蔽までは可能だった。（パルナスの規則） 
- しかし複数インスタンスが作れない。 
- これを満たすのがADT。 

*** クラスとの関連

- クラスは，抽象データ型を実現するもの
- これに加えて，下記を特徴として持つ:
  - *継承* 
  - *ポリモーフィズム* ((s-:?))


** オブジェクト指向の本懐 - Strategic Choice
http://d.hatena.ne.jp/asakichy/20090421/1240277448

*** オブジェクト指向前 -- オブジェクト指向の本懐（２）・

**** 機能分解  

「構造化プログラミング」時代と呼ばれ、
機能分解（functional decomposition）の手法がとられていました。

- 問題を小さな機能にブレークダウンしていき、複雑さを回避しようとするアプローチで
  す。

- 図にするとピラミッドストラクチャのようになります。

- ブレークダウンされるごとに凝集度は高まり、見通しも良くなるので自然と複雑度は下がります。

しかし、ここには落とし穴がありました。

- このアプローチでは、結果的に「メイン」モジュールが必要となります。

  機能の組合わせとその呼び出し順を正し
  く制御する、大きな責任を持ったモジュールです。

- こういった構造になっていると、モジュールの変更が制御できなくなります。
  
  「他の関数」「データ」「やり取り」「順番」等、注意を払うべき項目が多
  すぎるからです。

- 機能やデータを変更すると、他の機能や他のデータに影響が及び、それがま
  た他の機能に影響を及ぼすという修正の連鎖が「芋蔓式」に発生し、「将棋
  倒し」が起こります。

- その中でも特に影響が大きいのが「データ」の変更についてで、

  データが機能に従属して拡散してしまっているため（方々で使っているだけ
  でなく、引数による上下渡り歩きも含む）、影響範囲の見極めが非常に困難
  になります。

**** 好ましくない副作用

この時代、多くのバグが、変更によって生み出されていました。

- 変更による不具合のことを「好ましくない副作用」といいます。

- 機能に注力することは、発見しにくい副作用を生み出す近道になってしまう
  のです。

- そして保守作業とデバッグ作業にかかる時間の大半は、バグの除去に充てら
  れる時間ではなく、バグの発見、および修正によって生み出された好ましく
  ない副作用の回避手段を考え出す時間に充てられていました。

つまり、機能分解は、ソフトウェアライフサイクルに常備されている「変更」
というイベントにおいて、例えばバグ修正時であれば二次バグ、機能追加時で
あればデグレードの発生など、常に危険に晒されている手法だということです。

そして、本来使うべき開発そのものの時間ではなく、この副作用の収束に多く
の時間を取られるという形で問題が顕在化したのです。

**** オブジェクト指向へ

変更は必ず発生するものです。

どう変わるかはわかりませんが、どこが変わりそうかはある程度予想できるの
です。

そこでオブジェクト指向が登場します。

**** 機能とデータ

書籍「オブジェクト指向入門」の中でトップダウン機能分解の弊害に言及して
います。

#+BEGIN_QUOTE

    オブジェクト指向でないアプローチでは何の抵抗もされずに、機能がデー
    タを支配するが、その後データが「復讐」を始めた。復讐はサボタージュ
    の形で現れた。アーキテクチャの基礎そのものを攻撃することによって、
    データはシステムを変更に耐えられないようにした。

#+END_QUOTE

トップダウンの機能階層図は一見きれいですが、実はごちゃ混ぜのデータ転送
が含まれており、変更時は管理不能に陥ってしまいます。

**** デグレードの原因

変更して、その変更が原因で、元の機能に不具合が発生してしまうのがデグレー
ドです。このデグレードが発生した時、私は「もう少し気をつけて修正すれば」
とか「もっと慎重に修正すればよかった」と反省してしまいます。しかし、そ
もそもの根本原因は、修正方法よりもその設計にあることが多いという実感が
あります。

そこに気が付いて、「割れ窓理論」（＠書籍「達人プログラマー」）に陥らな
いよう、変更に強い設計に改善していかなければなりません。

そのためのオブジェクト指向だと思っています。

*** オブジェクト指向黎明期の誤解 -- オブジェクト指向の本懐（３）・

[[http://d.hatena.ne.jp/asakichy/20090424/1240533845][オブジェクト指向黎明期の誤解 - Strategic Choice]]

オブジェクト指向も最初から正しく活用されていたわけではありませんでした。

**** 代表的な誤解

- オブジェクトとはデータ＋操作である。

- カプセル化とはデータの隠蔽である。

- 継承は特殊化と再利用の手段である。

これらはもっともらしく見えますが、本質ではありません。

((s-:)) 実装寄りの見方なんですね。

**** オブジェクト指向の正しい理解

正しい理解は以下になります。

- オブジェクトとは責務である。

- カプセル化とは流動的要素の隠蔽である。

- 継承はオブジェクトを分類する手段である。

((s-:)) 概念・仕様レベルの見方ですね。

***** カプセル化の意味

「カプセル化、情報隠蔽、データ隠蔽」という用語は、余りにも意味が揺れて
いるため、はっきりとしたことは言えないようです。

((s-:)) すべての機能をモジュールの中に閉じ込め，公開インタフェースを通
してのみ，利用可能にすること。

***** オブジェクト指向のウソについて

オブジェクト指向の黎明期は、その特徴について以下のように喧伝されていました。

    - 現実世界をそのままモデリング（クラス化）できる。

    - 実装は簡単で、属人性も排除できる。

    - 差分プログラミングで簡単に再利用できる。

しかし、これらはウソないし本質ではないことは明らかです。

1. モデリング

   - 例えばコンパイラを作ろうとしたら現実にある
     ものは1つもでてきません。

     - ((s-:)) いっぱいでてきますよ。文法，構文木，生成規則，... 

   - モデリングは「捨象」です。つまり、抽象化してほとんどの部分を捨て
     てしまいます。「そのまま」クラスにはなりません。

     - ((s-:)) 本質的なものだけを残すのがモデリングで，それはクラスに
       なります。

   - デザインパターンにおいて、その登場クラスのほとんどは「人工品」で、
     現実世界には存在しません。

     - ((s-:)) 人工物も一度できれば現実です。

2. 実装は簡単で、属人性も排除できる

   - 言語仕様的に便利になった部分（典型的にはC→Javaのメモリ管理）で従
     来よりは品質上がるのでしょうが、

     - ((s-:)) 簡単さは，なんといっても再利用が簡単になることじゃない
       かなぁ。

   - 余りにも実装寄りの話でオブジェクト指向の本質とは全く関係ありませ
     んので、根拠に乏しいと思います。

     - ((s-:)) 属人性を，メッセージングで解決することでは？

3. 差分プログラミングで簡単に再利用できる

   - 「よく似た既存クラスがあれば、それを継承し、違う部分だけを実装すれ
     ば再利用できる」という主張で、確かにそういった一面はあると思います。
     しかしこれも実装面から見た話ですし、

     - ((s-:)) 差のみを書くことには，積極的な意味があると思います。

   - 差分プログラミングそのものはオブジェクト指向（言語）でなくても可
     能です。

   - さらに、継承を紡いでいく拡張には設計的にも実装的にも問題点があり
     ます。

     - ((s-:)) 問題の構造がそうなら，継承を紡いでいく拡張が正しいのだ
       と思います。

*** ソフトウエア開発プロセスの観点 -- オブジェクト指向の本懐（４）

 オブジェクト指向の考察の前提知識， 
 マーチン・ファウラー「UMLモデリングのエッセンス」で提唱

**** 概念(conceptual) 

  - 調査対象領域における概念を表現。 
  - 実装とは関係なく導き出される。 
  - 「私は何に対して責任があるのか？」 

**** 仕様(specification) 

  - ソフトウェアを考慮。 
  - 実装ではなく、インターフェイスの考慮 。 
  - 「私はどのように使用されるのか？」 

**** 実装(implementation) 

 - ソースコード自体を考慮。 
 - 上の2つを考えた後。 
 - 「私はどのように自身の責任を全うするのか？」 

 この観点の使い分けが非常に重要

 - 概念レベルでコミュニケーションを取とると、お互いの詳細は知らなくて良
   いことになります。

 - 設計はまずここで考えることになります。すなわちソフトウェア以下は考慮
   しません。

 - すると設計アウトプットにおいて、使用者に概念をそのままにして実装を変
   更できるため、結果的に使用者に対して（発生しやすい変更である）実装変
   更から守ることになります。

**** オブジェクトとソフトウエア開発プロセスの観点の間のマッピング

 ソフトウェア開発プロセスの観点とオブジェクト指向設計がよくマッチするから。
 以下にオブジェクトと観点のマッピングを示す:

***** 概念レベル 
      - オブジェクトは責任の集合 

***** 仕様レベル 
      - オブジェクトはその他のオブジェクトや自ら起動することが出来るメ
        ソッドの集合

***** 実装レベル 
      - オブジェクトはコードとデータ、それらの相互演算処理

 そしてこの観点の使い分けがわかると、既存の開発手法から「オブジェクト指
 向（の本質）」にパラダイムシフトし易くなります。


*** オブジェクト指向パラダイム -- オブジェクト指向の本懐（５）

**** オブジェクトとは責任である

オブジェクト指向では、機能に分解するのではなく、 *オブジェクト * に分解
します。

オブジェクトとは「データ＋操作」ではありません。

- 決して「賢いデータ」程度の物ではないのです。

- これは実装の観点からしか見ていない、狭いものの見
  方です。

それではオブジェクトとは何か。

- オブジェクトとは *責任* です。責務を備えた実体です。

- それは *概念レベル*，*仕様レベル* から考察した結果導き出されるもので
  す。実装レベルを混ぜてはいけません。

- *オブジェクトがどう実装されるか* ではなく
  *オブジェクトが何を実行するのか*に着目しなければならないのです。

**** 開発の手順

オブジェクト指向に沿ったソフトウェア開発の手順はこうなります。

1. 詳細をすべて考慮することなく、予備的な設計を行う
2. その設計を実装する

つまり、

1. まず概念レベル（＝責任）で考えることになります。

2. そして、責任を果たすために、他のオブジェクトが使用するためのインター
   フェイスを考えます。

   これを *公開インターフェイス* といいます。

   実装をそのインターフェイスの背後に隠蔽することで、実装とそれを使用
   するオブジェクトを分離しているのです。

実装レベルで考えているだけだと、結局機能分解の時と同じ問題が発生します。

- つまり、変更から守られないということです。

- 差分プログラミング的な、誤解されたオブジェクト指向もこの範疇に入ります。

一方、概念レベルでコミュニケーションをはかり、別のレベルで（実装）要求
を遂行する、という風に分けて考えると、

- リクエストする側は何が起こるかの概略だけ知っていればよいことになります。

- つまり、その概略（責任・インターフェイス）をそのままに、実装詳細の変
  更から、リクエスト側を守ることができるということです。

**** 補足

***** 変更はいつするのか？

 書籍「達人プログラマー」では、DRY原則の説明の中で、メンテナンスについてこういっています。

 #+BEGIN_QUOTE

     メンテナンスとは「バグの修正と機能拡張であり、アプリケーションがリ
     リースされた時から始まるものである」という考えは間違いです。

     プログラマーは常に「メンテナンス・モード」であり、理解は日々変わっ
     ていくものです。

     設計やコーディング中でも新たな要求が発生するため、メンテナンスと開
     発工程は分けて考えられるものではなく、メンテナンスはすべての開発工
     程を通じて行う日常業務なのです。

 #+END_QUOTE

 いわゆる製品リリース後をメンテナンスと捉えるのではなく、新しい製品の開
 発中も含めてメンテナンスと言っています。

 つまり * 変更は常時 * ということです。


***** 変更に本当につよいのか？

 私はオブジェクト指向が変更に強いと言われても最初はなかなか実感が湧きま
 せんでした。なぜならその実例がないからです。

 書籍のサンプルには、当たり前ですが「仕様変更」や「追加要求」がありませ
 ん。変更に強く、それが目的あると言われてもピンとこないのも無理はないの
 です。

 しかし、それをやっと実感できたのが「デザインパターンとともに学ぶオブジェ
 クト指向のこころ」を読んだ時でした。


** オブジェクト指向設計原則 - Strategic Choice
http://d.hatena.ne.jp/asakichy/20090122/1232879842

** プログラミング原則 [Unix思想] - Strategic Choice
http://d.hatena.ne.jp/asakichy/searchdiary?word=%2A%5BUnix%BB%D7%C1%DB%5D

** ソフトウェア開発の真実とウソ - Strategic Choice
ohttp://d.hatena.ne.jp/asakichy/20131007/1381097627

** ソフトウェア開発原則一覧 - Strategic Choice
http://d.hatena.ne.jp/asakichy/20100205/1265329796

** 七つの設計原理 - Strategic Choice
http://d.hatena.ne.jp/asakichy/20090806/1249526499

** 漏れのある抽象化の法則 - Strategic Choice
http://d.hatena.ne.jp/asakichy/20160729/1469743543



