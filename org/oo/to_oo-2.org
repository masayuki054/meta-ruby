#+title: オブジェクト指向
#+SETUPFILE: ~/COMM/public_html/org-html-theme/index-bigblow-header.setup
#+include: ~/COMM/Lects/meta-ruby/site/info/common-header.org

* オブジェクト指向に至る軌跡

** オブジェクト指向以前

    オブジェクト指向プログラミング、あるいはオブジェクト指向言語は、
    それに至るまでの様々なアイデアを統合し、再編され、また現実
    的な制約の中で歪みながら生まれてきたものだったりする。

    プログラミングパラダイムは，
    現実世界のプログラミングという人間活動の中で生じた
    課題をどのように整理していくかという中で生まれてきた。

*** Done ソフトウェア危機
    CLOSED: [2015-11-30 月 06:54] SCHEDULED: <2015-10-26 月>

    [[http://ja.wikipedia.org/wiki/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E5%8D%B1%E6%A9%9F][ソフトウェア危機]] (wikipedia) とは

     1960年代の後半、コンピュータが進歩するにつれて、より複雑
     なソフトウェアが求められ始める時代、その複雑さをコントロールするた
     めの道具やアイデアはあまり多くなかった。

    プロジェクトは、複雑化する一方なのに、管理手法もなければ、データ型
    は基本的な数値でしかなく、変数はメモリアロケーションそのものだった。

    また、プログラムの流れは、gotoやjump命令のようにプログラムカウンタ
    を直にコントロールする抽象度の低いもので制御されることが多かった。

    プログラムはフローチャートで記述され、それをマシン語としてパンチす
    るといったプロジェクトX的な世界のことを考えれば、その理解が正しいの
    かもしれない。

    なんにせよ、そういった当時の人からすると逼迫していたが、今から見る
    となんとも牧歌的な世界観の中で、構造化プログラミングという概念が生
    まれる。

*** Done 構造化プログラミング
    CLOSED: [2015-11-30 月 06:54] SCHEDULED: <2015-10-26 月>

     ダイクストラは構造化プログラミングを提案した

     ときどき、勘違いされているが構造化プログラミングとは「手続き型言語」
     のことでもなければ「gotoを使わないプログラミング」のことでもない。

***** Todo 構造化プログラミングとは
      SCHEDULED: <2015-10-25 日>

      [[http://ja.wikipedia.org/wiki/%E6%A7%8B%E9%80%A0%E5%8C%96%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0][構造化プログラミング(wikipedia)]]

      - 構造化プログラミングではプログラミング言語が持つステートメントを
	直接使ってプログラムを記述するのではなく、
      - それらを抽象化したステートメントを持つ仮想機械を想定し、
      - その仮想機械上でプログラムを記述する。

      - 普通、抽象化は1段階ではなく階層的である。
	- 各階層での実装の詳細は他の階層と隔離されており、
	- 実装の変更の影響はその階層内のみに留まる(Abstract data
          structures)。
	- 各階層はアプリケーションに近い抽象的な方から土台に向かって順
          序付けられている。
	- この順序は各階層を設計した時間的な順番とは必ずしも一致しない

      つまり、現代風に言い換えると「レイヤリングアーキテクチャ」のよう
      なもので、ある土台の上にさらに抽象化した土台をおき、その上にさら
      に・・・というようにプログラムをくみ上げていく考え方のことだ。

      これは、現在のプログラミングにおいても当たり前となっている考え方
      だ。

      だから、我々は、ひとつのアーキテクチャないし関数の中で異なる抽象
      化レイヤの実装を同居することをさける。
   
      一方、耳目を集めやすいgoto文有害論とともに構造化技法の一部である
      構造化定理(任意のフローチャートは、for文とif文で記述できる)が注目
      され、手続き型プログラミング言語を現代の形に押し上げていった。

*** Done モジュラプログラミング
    CLOSED: [2015-11-30 月 06:55]

     こういった背景のなか、プログラムは大きく複雑になり続ける。至極自然
     な流れとして、それを分割しようとしていく。

***** 凝集度と結合度

      モジュールの分割には、大きな指針がなかった。現在でもやろうと思え
      ば全然関係のない機能を１つのモジュールに詰め込むことはできる。

      熟練したプログラマとそうでないプログラマで、作り出すモジュールの
      品質は違う。その品質の尺度として、凝集度と結合度という概念がしば
      らくして生まれた。

      結合度：よいコラボレーションとわるいコラボレーションを定義した
      http://ja.wikipedia.org/wiki/%E7%B5%90%E5%90%88%E5%BA%A6

      凝集度：よい機能群のまとめ方とわるい機能のまとめ方を定義した
      http://ja.wikipedia.org/wiki/%E5%87%9D%E9%9B%86%E5%BA%A6

      これらは「関心の分離」を行うためにどのようにするべきかという指針でもあった。
      http://ja.wikipedia.org/wiki/%E9%96%A2%E5%BF%83%E3%81%AE%E5%88%86%E9%9B%A2

      この「関心」とはそのモジュールの「責任」「責務」と言い換えてもい
      いかもしれない。この責任とモジュールが一致した状態にできるとその
      モジュールは凝集度が高く、結合度を低くすることができる。

      それぞれ悪い例と良い例を見ていき、「責任」「責務」の分解とは何か
      をとらえていこう。

***** 悪い結合、良い結合

      悪い結合としては、あるモジュールが依存しているモジュールの内部デー
      タをそのまま使っていたり（内容結合）、同じグローバル変数（共通結
      合）をお互いに参照していたりというようなつながり方だ。

      こうなってしまうとモジュールは自分の足でたっていられなくなる。つ
      まり、片方を修正するともう片方も修正せざるをえなくなったり、予想
      外の動作を強いられることになる。

      逆に良い結合としては、定められたデータの受け渡し(データ結合)やメッ
      セージの送信（メッセージ結合）のように内部構造に依存せず、情報の
      やり取りが明示的になっている状態を言う。

      これはまさにカプセル化とメッセージパッシングのことだよね、と思っ
      た方は正しい。オブジェクト指向は良い結合を導くために考えだされた
      のだから。

***** 悪い凝集、良い凝集

       凝集度が低い状態とは，つまり悪い凝集とは，何か，

       - 暗合的凝集 :: アトランダムに選んできた処理を集めたモジュールは
                       悪い。何を根拠に集めたのかわからないものも悪い凝集だ。

       - 論理的凝集 :: 論理的に似ている処理だからという理由だけで集めて
                       はいけない。

       たとえば、入出力の処理だからといって、

 #+BEGIN_SRC java
function open(type,name){
    switch(type){
    case "json": ... break;
    case "yaml": ... break;
    case "csv" : ... break;
    case "txt" : ... break;
        :
    }
    return result;

}
 #+END_SRC

       openという関数にif文やswitch文を大量に入れて、あらゆるopen処理を
       まとめた関数をイメージしてもらいたい。（その論理的な関係を一つの
       記述にまとめたいと思うこと自体は悪い発想じゃないが、同じ場所に書
       くことで、もっと大事なデータとの関係が危うくなってしまう。その矛
       盾をうまく解決するのが同じメッセージをデータ構造ごとに異なる解釈
       をさせるポリモーフィズムだ。）

       そういった種類のものがメンテナンスしづらいというのはイメージしや
       すいだろう。

       - 時間的凝集 :: 他にも同じようなタイミングで実施されるからといっ
                       て、モジュール化するのもの問題がある。たとえば、
                       initという関数の中ですべてのデータ構造の初期化を
                       するイメージをしてほしい。

       一方、良い凝集とはなんなのか、それは

       - 通信的凝集 :: とあるデータに触れる処理をまとめることであるとか、

       - 情報的凝集 :: 適切な概念とデータ構造とアルゴリズムをひとまとめ
                       にすること。

       - 機能的凝集 :: それによって、ひとつのうまく定義されたタスクをこ
                       なせるように集めることである。

***** 状態と副作用の支配

       よいモジュール分割とはなにか

       - それは、処理とそれに関連するデータの関係性を明らかにして支配し
         ていくことの重要性だ。

         できれば、完全にデータの存在を隠蔽できてしまえると良いが、現実
         のプログラムではそうは行かない場合も多い。

       こういった実務プログラミングの中で何が難しいかというと、それが状
       態と副作用を持つことだ。

       たとえば、
 #+BEGIN_SRC java
function add(a,b){
    return a+b;
}
 #+END_SRC

       このような副作用を持たない関数はテストもしやすく、バグが入り込む隙が少ない。
       たとえば、計算機のレジスタ機能をこの関数に導入し、

 #+BEGIN_SRC java
var r = 0;
function add(a,b){
    r = a+ (isUndefined(b)||r)
    return r
}
 #+END_SRC

       このようにすると途端に考慮するべき事柄が増える。関連する状態や副
       作用を含めて、関数を大別すると次のようになる。

       オブジェクト指向に至るモジュラプログラミングは、こういった状態や
       副作用に対して，積極的に命名，可視化，粗結合化をしていくことで
       「関心の分離」を実現しようとした。

       たとえば、現在でもC言語のプロジェクトなどでは，構造体とそれを引
       数とする関数群ごとにモジュールを分割し，大規模なプログラミングを
       行っている。構造体と関数群

 #+BEGIN_SRC c
typedef struct {
    :
} Person;

void person_init(person*p,...){
    :
}

char * person_get_name(person *p){
    :
}

void person_set_name(person *p,char *name){
    :
}

 #+END_SRC

       よくあるのは、上記のように構造体の名前のprefixとしてつけ、構造体
       のポインタを第一引数として渡す手法だ。

       その名残なのか、正確なところはよく知らないが、pythonやperlのオブ
       ジェクト指向では、自分自身を表すデータが、第一引数として関数に渡
       される。

 #+BEGIN_SRC python
class Person(object):
    def __init__(self, a, b):
        self.a = a
        self.b = b

 #+END_SRC

 #+BEGIN_SRC perl
package Person {
    sub new(){
        my ($class,$a,$b) = @_;
        my $self = bless{},$class;
        $self->init($a,$b);
        return $self;
    }
    sub init {
        my ($self,$a,$b) = @_;
        $self->{a} = $a;
        $self->{b} = $b;
    }
}

 #+END_SRC

       あくまで関数の純粋性を犠牲にしないように発展を続けた関数型プログ
       ラミングと、状態や副作用をデータ構造として主役にしていった手続き
       型プログラミングの分かれ目として理解すると面白い。

