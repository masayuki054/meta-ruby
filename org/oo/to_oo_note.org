** オブジェクト指向に至るまで
*** ソフトウェア危機

    [[http://ja.wikipedia.org/wiki/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E5%8D%B1%E6%A9%9F][ソフトウェア危機]] 

コンピュータが進歩するにつれて、より複雑なソフトウェアが求められ始める
その複雑さをコントロールするための道具やアイデアが不足

プロジェクト管理手法もなければ、
抽象度の低いデータ型，変数，制御構造

*** 構造化プログラミング

      [[http://ja.wikipedia.org/wiki/%E6%A7%8B%E9%80%A0%E5%8C%96%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0][構造化プログラミング(wikipedia)]]

      つまり、現代風に言い換えると「レイヤリングアーキテクチャ」のよう
      なもので、ある土台の上にさらに抽象化した土台をおき、その上にさら
      に・・・というようにプログラムをくみ上げていく考え方のことだ。

      だから、我々は、ひとつのアーキテクチャないし関数の中で異なる抽象
      化レイヤの実装を同居することをさける。
   
*** モジュラプログラミング

     大きく複雑になるプログラムの分割

***** 凝集度と結合度

      結合度：よいコラボレーションとわるいコラボレーションを定義した
      http://ja.wikipedia.org/wiki/%E7%B5%90%E5%90%88%E5%BA%A6

      凝集度：よい機能群のまとめ方とわるい機能のまとめ方を定義した
      http://ja.wikipedia.org/wiki/%E5%87%9D%E9%9B%86%E5%BA%A6

      これらは「関心の分離」を行うためにどのようにするべきかという指針でもあった。
      http://ja.wikipedia.org/wiki/%E9%96%A2%E5%BF%83%E3%81%AE%E5%88%86%E9%9B%A2

      この「関心」とはそのモジュールの「責任」「責務」と言い換えてもい
      いかもしれない。この責任とモジュールが一致した状態にできるとその
      モジュールは凝集度が高く、結合度を低くすることができる。

***** 悪い結合、良い結合

      悪い結合としては、あるモジュールが依存しているモジュールの内部デー
      タをそのまま使っていたり（内容結合）、同じグローバル変数（共通結
      合）をお互いに参照していたりというようなつながり方だ。

      こうなってしまうとモジュールは自分の足でたっていられなくなる。つ
      まり、片方を修正するともう片方も修正せざるをえなくなったり、予想
      外の動作を強いられることになる。

      逆に良い結合としては、定められたデータの受け渡し(データ結合)やメッ
      セージの送信（メッセージ結合）のように内部構造に依存せず、情報の
      やり取りが明示的になっている状態を言う。

      これはまさにカプセル化とメッセージパッシングのことだよね、と思っ
      た方は正しい。オブジェクト指向は良い結合を導くために考えだされた
      のだから。

***** 悪い凝集、良い凝集

       凝集度が低い状態とは，つまり悪い凝集とは，何か，

       - 暗合的凝集 :: アトランダムに選んできた処理を集めたモジュールは
                       悪い。何を根拠に集めたのかわからないものも悪い凝集だ。

       - 論理的凝集 :: 論理的に似ている処理だからという理由だけで集めて
                       はいけない。

       - 時間的凝集 :: 他にも同じようなタイミングで実施されるからといっ
                       て、モジュール化するのもの問題がある。たとえば、
                       initという関数の中ですべてのデータ構造の初期化を
                       するイメージをしてほしい。

       一方、良い凝集とはなんなのか、それは

       - 通信的凝集 :: とあるデータに触れる処理をまとめることであるとか、

       - 情報的凝集 :: 適切な概念とデータ構造とアルゴリズムをひとまとめ
                       にすること。

       - 機能的凝集 :: それによって、ひとつのうまく定義されたタスクをこ
                       なせるように集めることである。

***** 状態と副作用の支配

       よいモジュール分割とはなにか

       - それは、処理とそれに関連するデータの関係性を明らかにして支配し
         ていくことの重要性だ。

         できれば、完全にデータの存在を隠蔽できてしまえると良いが、現実
         のプログラムではそうは行かない場合も多い。

       こういった実務プログラミングの中で何が難しいかというと、それが状
       態と副作用を持つことだ。

       オブジェクト指向に至るモジュラプログラミングは、こういった状態や
       副作用に対して，積極的に命名，可視化，粗結合化をしていくことで
       「関心の分離」を実現しようとした。

       たとえば、現在でもC言語のプロジェクトなどでは，構造体とそれを引
       数とする関数群ごとにモジュールを分割し，大規模なプログラミングを
       行っている。

*** 抽象データ型

    よいモジュール化の肝
    - 状態と副作用を隠蔽し、
    - データとアルゴリズムをひとまとめにする

    それらを言語的に支援するために抽象データ型という概念が誕生した。

    抽象データ型は、今で言うクラス
    - すなわちデータとそれに関連する処理をひとまとめにしたデータ型のこ
      とだ。

    - 抽象データ型のポイントは、その内部データへのアクセスを抽象データ
      型にひもづいた関数でしか操作することができないという考え方だ。

   
   内部構造を隠し，型とインタフェースを公開する。

   - 公開するヘッダと非公開のヘッダを分けることで、情報の隠蔽を行い抽象
     データ型としての役目を成り立たせている。

***** 抽象データ型の情報隠蔽とカプセル化

      言語機能として外部からのアクセスを制限できるようにした。

      カプセル化やブラックボックス化というのは情報隠蔽よりも広い概念で
      はあるが、これらの機能によって、「悪い結合」を引き起こさないよう
      にしている。

      これによって、複雑化した要求を抽象化の階層を定義していくという現
      代的なプログラミングスタイルが確立した。



** オブジェクト指向?

   simula
   - オブジェクト、
   - クラス（抽象データ型）、
   - 動的ディスパッチ、
   - 継承
   - ガーベジコレクト

   Simulaの優れたコンセプトをもとに，２つの，今でも使われている，C言語
   拡張が生まれた。
  
   一つはC++。もう一つはObjective-Cである。

   SimulaのコンセプトをもとにSmalltalkという言語というか環境が爆誕した。

   Smalltalkは、Simulaのコンセプトに「メッセージング」という概念を加え、
   それらを再統合した。Smalltalkはすべての処理がメッセージ式として記述
   される「純粋オブジェクト指向言語」だ。

   そもそもオブジェクト指向という言葉はここで誕生した。

   オブジェクト指向という言葉の発明者であるアランケイは後に「オブジェク
   ト指向という名前は失敗だった」と述べている。メッセージングの概念が軽
   視されて伝わってしまうからだという。

   何にせよ、このSmalltalkの概念をもとにC言語を拡張したのがObjective-C
   だ。



** Simula & C++のオブジェクト指向

   C++のオブジェクト指向

 #+BEGIN_QUOTE
   継承と多態性を付加した抽象データ型のスーパーセット
 #+END_QUOTE

*** どの処理を呼び出すか決めるメカニズム

    さて、継承と多態を足した抽象データ型といっても、なんだか良くわからない。

    特に多態がいまいちわかりにくい。オブジェクト指向プログラミングの説明で

 #+BEGIN_SRC c++
 string = number.StringValue
 string = date.StringValue

 #+END_SRC

    これで、それぞれ違う関数が呼び出されるのがポリモーフィズムですよと
    呼ばれる。

    これだけだとシグネチャも違うので、違う処理が呼ばれるのも当たり前に
    見える。
   
    では、こう書いてみたらどうか

 #+BEGIN_SRC c++
string = stringValue(number) // 実際にはNumberToStringが呼ばれる
string = stringValue(date)   // 実際にはDateToStringが呼ばれる

 #+END_SRC

    このようにしたときに、すこし理解がしやすくなる。引数の型によって呼
    ばれる関数が変わる。こういう関数を polymorphic (poly-複数に morphic-
    変化する) な関数という。

    これをみたときに"関数のオーバーロード"じゃないか？と思った人は鋭い。
    http://ja.wikipedia.org/wiki/%E5%A4%9A%E9%87%8D%E5%AE%9A%E7%BE%A9

    多態とは異なる概念とされるが、引数によって呼ばれる関数が変わるとい
    う意味では似ている。しかし、次のようなケースで変わってくる。

 #+BEGIN_SRC c++
function toString(IStringValue sv) string {
    return StringValue(sv)
}

 #+END_SRC

    IStringValueはStringValueという関数を実装しているオブジェクトを表す
    インターフェースだ。これを受け取ったときに、関数のオーバーロードで
    は、どの関数に解決したら良いか判断がつかない。関数のオーバーロード
    は、コンパイル時に型情報を付与した関数を自動的に呼ぶ仕組みだからだ。

 #+BEGIN_SRC c++
stringValue(number:Number) => StringValue-Number(number)
stringValue(date :Date)  => StringValue-Date(date)

function toString(IStringValue sv) string {
    return StringValue(sv) => StringValue-IStringValue (無い！)
}

 #+END_SRC

    それに対して、動的なポリモーフィズムを持つコードの場合、次のように
    動作してくれるので、インターフェースを用いた例でも予想通りの動作を
    する。

 #+BEGIN_SRC c++
function StringValue(v:IstringValue){
    switch(v.class){ //オブジェクトが自分が何者かということを知っている。
    case Number: return StringValue-Number(number)
    case Date   : return StringValue-Date(date)
    }
}

 #+END_SRC

    このようにどの関数を呼び出すのかをデータ自身に覚えさせておき、実行
    時に探索して呼び出す手法を *動的分配*，*動的ディスパッチ* と呼ぶ。

    このように動的なディスパッチによる多態性はどのような意味があるのか。

    それはインターフェースによるコードの再利用と分離である。

    特定のインターフェースを満たすオブジェクトであれば、それを利用した
    コードを別のオブジェクトを作ったとしても再利用できる。

    これによって、悪い凝集で例に挙げた論理的凝集をさけながら、
    汎用的な処理を記述することができるのだ。

    オブジェクト指向がはやり始めた当時は、再利用という言葉が比較的バズっ
    たが、現在的に言い換えるなら、インターフェースに依存した汎用処理と
    して記述すれば、結合度が下がり、テストが書きやすくなったり、仕様変
    更に強くなったりする。


**** 動的ディスパッチ

      動的ディスパッチのキモは、オブジェクト自身が自分が何者であるか知っ
      ており、また、実行時に関数テーブルを探索して、どの関数を実行する
      かというところにある。

      こうなってくると、多態を実現するためには、３つの要素が必要だとわかる。
     
      - データに自分自身が何者か教える機能
      - メソッドを呼び出した際にそれを探索する機能
      - オブジェクト自身を参照できるように引数に束縛する機能

**** 継承と委譲

***** 継承

***** 委譲

   このようにメソッドの動的な探索に対して、どのような機構をつけるのかというのが
   オブジェクト指向では重要な構成要素と言える。

   rubyの module やその include, prepend、特異メソッド，特異クラスなどは
   まさにその例だ。


*** オブジェクト指向の要素

     - 抽象データ型：データと処理をひもづける
     - 抽象データ型：情報の隠蔽を行うことができる
     - オブジェクト：データ自身が何者か知っている
     - 動的多態：オブジェクト自身のデータと処理を自動的に探索する
     - 探索先の設定：継承、委譲

     ということになる。


** Smalltalk & Objective-Cのオブジェクト指向

 アランケイによるオブジェクト指向の定義：

 #+BEGIN_QUOTE
 パーソナルコンピューティングに関わる全てを『オブジェクト』とそれらの
 間で交わされる『メッセージ送信』によって表現すること
 #+END_QUOTE

*** 仮想機械としてのオブジェクト

    - アランケイの世界観 :: 
         コンピュータを抽象化するとしたら、データと処理と命令セットをも
         つ仮想機械で抽象化されるべき

    - 構造化プログラミング :: 
	仮想機械として階層的に抽象化すべき

    - オブジェクト指向 :: 
         オブジェクトを独立した機械と見なし、それに対してメッセージを送
         り、自ら持つデータの責任は自らが負う。

    Smalltalkの実行環境もまた仮想機械として作られている。

*** メッセージング

    Smalltalkでメッセージ送信は下記のように記述する:

 #+BEGIN_SRC ruby
receiver message
 #+END_SRC

    メッセージングは通信。

    - アドレスさえ知っていれば、メッセージは自由に送れる。

    - レシーバはメッセージを受け取リ，その解釈はレシーバ自身が行う

    このメッセージらしさが出てくる特徴をいくつか紹介しよう。

**** 動的な送信

     メッセージの内容もまたオブジェクトなので、動的に作成し送ることができる。

 #+BEGIN_SRC ruby :session ruby :results output

class A
  def hello
    p "hello"
  end
end

a = A.new
# 動的にメソッドを作成
method = "he" + "ll" + "o"
# それを呼び出す
a.send(method)
 #+END_SRC

**** メッセージ転送  [[https://ja.wikipedia.org/wiki/%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E8%BB%A2%E9%80%81][(Wikipedia)]]

     受け取ったメッセージは、仮にメソッド定義がなかったとしても自由に取
     り扱うことができる。

     - rubyの method_missing は，メソッドがない時に呼ばれるメソッド。
       メソッドの未定義を知ることができ，その処理を他のオブジェクトにま
       かせるのが，メッセージ転送。

       proxy.rb

 #+BEGIN_SRC ruby :session ruby :results output

class Proxy
  def method_missing(name, *args, &block)
    target.send(name, *args, &block)
  end

  def target
    @target ||= []
  end
end

Proxy.new << 1

'end'

 #+END_SRC

**** 非同期送信

     メッセージの送信と結果の受信を別々に行なう。

     並列計算が可能になる。

*** オブジェクト指向という言葉が意味していること

     http://www.infoq.com/jp/news/2010/07/objects-smalltalk-erlang

     オブジェクト指向プログラミングの3つの主義は、

      - メッセージ送信に基づいて、

      - オブジェクト間で分離し、
       
      - ポリモーフィズムを持つ

