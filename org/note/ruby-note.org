* Ruby紹介

  [[http://docs.ruby-lang.org/ja/2.0.0/doc/index.html][Ruby リファレンスマニュアル (Ruby 2.0.0)]] より

** はじめに

   - Rubyは手軽なオブジェクト指向プログラミングのためのインタプリタ言語
   - Rubyはテキスト処理やシステム管理のための豊富な機能を持っています。 
   - Rubyは単純で、分かりやすく、簡単に拡張できます。

*** Rubyの特長

    - インタプリタ
	
      Rubyはインタプリタ言語です。プログラムを実行するためにコンパイル
      する必要はありません。

    - 変数に型が無い (動的型付け)

      Rubyの変数はどのような型のデータも格納する事ができますので、 変
      数の型について心配する必要はありません。 半面、コンパイル時のチェッ
      クは弱くなります。

    - 変数宣言が不要
	
      Rubyでは変数を宣言無しで使う事ができます。 変数の種類(ローカル変
      数、グローバル変数、インスタンス変数など)は 変数名から知る事がで
      きます。

    - 単純な文法
	
      Rubyの文法はEiffelからわずかに影響を受けた単純なものです。

    - ユーザによるメモリ管理が不要
	
      Rubyはメモリ管理を自動的に行います。 どこからもアクセスされなく
      なったオブジェクトは インタプリタに組み込みのガーベージコレクタ
      によって回収されます。

    - 全てがオブジェクト
    
      Rubyははじめから純粋なオブジェクト指向言語として設計されています。
      整数のような基本的なデータ型をはじめとして、 全てのデータをオブ
      ジェクトとして統一的に取り扱えます。

    - クラス、継承、メソッド
    
      Rubyは クラス、継承、メソッドのようなオブジェクト指向言語として
      基本的な機能は 当然持っています。

    - 特異メソッド
    
      ある特定のオブジェクトにメソッドを付加することができます。 たと
      えば、GUIのあるボタンを押された時の動作を メソッドとして記述する
      ような使い方ができますし、 これを応用してプロトタイプベースの オ
      ブジェクト指向プログラミングも可能です(やりたければね)。

    - モジュールによるMix-in
    
      Rubyは多重継承は複雑さの源であるという見地から、 意図的に多重継
      承を持っていませんが、 モジュールを使ってクラス階層を横断して実
      装を共有できます。 この機能を"Mix-in"と呼びます。

    - ブロック付きメソッド呼び出し(イテレータ)
    
        制御構造の抽象化を援助するブロック付きメソッド呼び出しという機能があります。

    - クロージャ
    
      手続きをオブジェクトとして扱う機能があります。 このオブジェクト
      化された手続きのことをクロージャと呼びます。

    - 強力な文字列操作/正規表現
    
      Perlをお手本とした強力な文字列操作や正規表現検索の機能があります。

    - 多倍長整数
    
      組み込みの多倍長整数機能がありますので、 メモリが許す限り、非常
      に大きな整数の演算もできます。 たとえば、400の階乗なども簡単に計
      算できます。

    - 例外処理機能
    
      例外処理機能は例外的な状況への対処が簡単に書けます。

    - OSへの直接アクセス
    
      Rubyは(UNIXの)ほとんどのシステムコールの呼び出し機能を持っていま
      す。 Rubyだけでシステムプログラミングも可能です。

    - ダイナミックローディング

      OSが許せば、オブジェクトファイルを実行時に読み込む機能が提供され
      ます。
	



* Rubyの原理

- 原典: [[http://docs.ruby-lang.org/ja/2.0.0/doc/spec~2fobject.html][オブジェクト]]  (ruby-lang.org)
- 原典:  [[http://docs.ruby-lang.org/ja/2.0.0/doc/spec~2fclass.html][クラス (Ruby 2.0.0)]]

** オブジェクト

   ここに，ruby の基本原理， が書かれていると，((s-:)) は思う。

*** オブジェクトとは

- Ruby で扱える全ての値はオブジェクトです。 
- Rubyのオブジェクトに対して可能な操作はメソッド呼び出しのみです。
- あるオブジェクトが反応できるメソッドは、
  そのオブジェクトが所属するクラスによって一意に決定します。
- 所属するクラスはオブジェクト生成時に決まり、その後は特異クラスの導入
  以外、所属クラスが変わることはありません。
- またオブジェクトは、特定のクラスに対比して、その「インスタンス」とも呼ばれます。
- オブジェクトの生成は、一般には、別のオブジェクトのメソッドを呼び出すことによって行われます。

*** クラス

- クラスは自身に所属するオブジェクトが反応できるメソッドを決定します。
- 所属するオブジェクトに対してあるメソッドを呼び出すことができるなら、
  そのメソッドが「クラスに定義されている」と言います。
- またメソッドはクラスとメソッド名によって一意に決定します。

- クラスは必ずただひとつの「スーパークラス」を持ち、
- スーパークラスであるメソッドが定義されていれば自クラスでもそのメソッ
  ドが同じ内容で定義されていることになります。
  これを「継承」と呼びます。

- 継承は推移するので、スーパークラスのスーパークラスが持つメソッドもま
  た自クラスにおいて定義されていることになります。

**** モジュール

- ちょっと特殊でクラスではない。しかし機能は同じ。

*** メソッド

- メソッドは実行することができます。その実行を開始することを通常「呼び
  出す」と言います。
- また呼び出すときにはオブジェクトを渡すことができ、そのオブジェクトを
  「引数」と呼びます。
- いくつの引数を受け取ることができるかはメソッドの定義時に決定し、変更
  することはできません。



** Todo クラス

*** クラスとオブジェクト

- Ruby プログラムからはクラスもまたオブジェクトとして扱うことができる。

- 以下の基本操作が可能:
  -  メソッドの存在を問い合わせる
  -  メソッドを定義する
  -  メソッドの定義を取り消す

*** モジュール

- Ruby プログラムからはクラスもまたオブジェクトとして扱うことができる。

- 以下の基本操作が可能:
  -  メソッドの存在を問い合わせる
  -  メソッドを定義する
  -  メソッドの定義を取り消す

クラスと同じだが，インスタンスを作ること，はできない。


*** 特異クラス

あるオブジェクトだけに定義されたクラス (by ((s-:)))


* 言語上のこと

** [[http://docs.ruby-lang.org/ja/2.0.0/doc/s][変数と定数 (Ruby 2.0.0)]]
*** 変数 http://www.rubylife.jp/ini/var/          変数 - Ruby入門

*** 変数への代入 

   変数への代入
   : 変数 ~ 値

   多重代入
   ： 変数1, 変数2, 変数3 ~ 値1, 値2, 値3

#+BEGIN_SRC ruby :session ruby :results output
x1 ~ 10

x1, x2, x3 ~ 1, 2, 3

x1, x2, x3 ~ [1, 2, 3]

'end'
#+END_SRC   

#+RESULTS:
: 10
: [1, 2, 3]
: [1, 2, 3]

*** 変数の種類

   http://docs.ruby-lang.org/ja/2.0.0/doc/s 変数と定数 (Ruby 2.0.0)

   - グローバル変数 
   - ローカル変数
     
   - インスタンス変数
   - クラス変数
   - 定数

**** Ruby予約語


： BEGIN    class    ensure   nil      self     when
： END      def      false    not      super    while
： alias    defined? for      or       then     yield
： and      do       if       redo     true
： begin    else     in       rescue   undef
： break    elsif    module   retry    unless
： case     end      next     return   until

変数名としては使用できません。 

 - 自己代入 
 - 多重代入 

*** スコープ
   講義後半で説明します。

   Block/Module
    - ローカル変数
    - グローバル変数 

    Object
    - インスタンス変数

    Class
    - クラス変数

    Module/Class (?) - ((*自信なし*))
    - 定数
  
** [[http://www.rubylife.jp/ini/method/][メソッド - Ruby入門]]

** Rubyにおけるトップレベル 

  http://www.rubylife.jp/ini/method/index1.html
*** トップレベル 



#+BEGIN_SRC ruby :session ruby :results output
print("Hello¥n")
'end'
#+END_SRC

    
    クラス定義の外側の部分はトップレベルと呼ばれています。

    ruby が実行されると, トップレベルに記述されたプログラムが順に実行
    されて行きます。

*** selfとmain

#+BEGIN_SRC ruby :session ruby :results output
self
'end'
#+END_SRC

#+RESULTS:
: main

    では「main」と言うオブジェクトの元になっているクラスは何かを確認し
    てみます。オブジェクトに対して「class」メソッドを実行するとそのオ
    ブジェクトをのクラスを返します。

#+BEGIN_SRC ruby :session ruby :results output
self
self.class
'end'
#+END_SRC

#+RESULTS:
: main
: Object

    「main」オブジェクトの元になっているクラスは「Object」クラスと表示
    されます。

*** トップレベルに定義されたメソッド


   ップレベルの中にもメソッドを定義することが出来ます。

   トップレベルに定義されたメソッドは*「Kernel」モジュール*の中に追加
   されることになっています。

  「Kernel」モジュールは全てのクラスの元になっている「Object」クラス
  に読み込まれています。

  その為、トップレベルに定義されたモジュールは、「Kernel」モジュール
  の中で既に定義されている「print」メソッドなどと同じようにどのクラス
  内からでも呼び出すことができます。

  またメソッドを呼び出す際に、呼び出し元のオブジェクト(レシーバーと呼
  ばれています)を省略できるので、あたかも関数のように使用することが可
  能です。

  よって特定のクラス内ではなくトップレベルの位置にメソッドを定義すれ
  ば、関数のように使用できるメソッドを定義することが可能となります。


** メソッドの定義と呼び出し 


: def メソッド名(引数1, 引数2, ...)
:  実行する処理
:  実行する処理
: end

#+BEGIN_SRC ruby :session ruby :results output
public
(def printHello
  print("Hello\n")
end).class

printHello
self.printHello

'end'
#+END_SRC

#+RESULTS:
: Object
: Symbol
: Hello
: nil
: Hello
: nil


** メソッドの呼び出し

   定義されたメソッドを呼び出すと、処理がメソッド内に移りメソッド内に
   記述された処理が実行されます。そしてメソッドの最後まで処理が終わる
   と、メソッドを呼び出した次の行へ処理が戻ります。

   メソッドを呼び出す時の書式は次の通りです。 


   : オブジェクト.メソッド名(引数1, 引数2, ...)

   メソッドはクラス内で定義され、そのクラスから作成されるオブジェクト
   (レシーバーと呼ばれます)に対して行わせたい処理を記述するものです。
   その為、メソッドを呼び出す時には対象となるオブジェクトと実行させる
   メソッド名を指定して呼び出します。

   
   : メソッド名(引数1, 引数2, ...)

   では定義されたメソッドを呼び出してみます。 


*** メソッド定義の位置

    メソッドは実際に呼び出されるよりも前に定義されていなければなりませ
    ん。例えば次のようなプログラムはエラーとなります。

    上記のようにメソッド呼び出しがメソッドの定義よりも前に実行されると
    「undefined local variable or method」と言うエラーが表示されます。

#+BEGIN_SRC ruby :session ruby :results output
x
'end'
#+END_SRC

#+RESULTS:
: NameError: undefined local variable or method `x' for main:Object
: 	from (irb):119
: 	from /home/staff/suzuki/.rbenv/versions/2.0.0-dev/bin/irb:11:in `<main>'


** 引数を付けたメソッド呼び出し 
** 引数のデフォルト値 

通常引数は呼び出し側とメソッド定義側で数が一致している必要がありますが、メソッ
ド定義側では引数にデフォルト値を設定することが可能です。書式は次の通りです。 


   : def メソッド名(変数1~デフォルト値1, 変数2~デフォルト値2, ...)
   :   実行する処理
   :   実行する処理
   : end

#+BEGIN_SRC ruby :session ruby :results output

def printHello(msg~"No msg", name~"No name")
  print(msg + "," + name + "¥n")
end

printHello("Hello", "Yamada")
printHello("Hello")
printHello()

def printHello(msg, name~"No name")
  print(msg + "," + name + "¥n")
end

printHello("Hello", "Yamada")
printHello("Hello")

'end'

#+END_SRC



** 引数を配列として受け取る 
** メソッドの戻り値 
** 多重代入を使って複数の戻り値を取得 

** [[http://www.rubylife.jp/ini/string/][文字列 - Ruby入門]]

** 文字列オブジェクト 
   #+BEGIN_SRC ruby :session ruby :results output both
String.new("こんにちは\n")
"こんにちは\n"
"こんにちは\n".class
String.class
'end'
   #+END_SRC
   
   #+RESULTS:
: "こんにちは\n"
: "こんにちは\n"
: String
: Class
   
** バックスラッシュ記法によるエスケープ 
** %Q、%qによる文字列の作成 
   
   #+BEGIN_SRC ruby :session ruby :results output data
require 'kconv'
print Kconv.toutf8(%Q[こんにちは"佐藤"さん\nお元気ですか]), "\n"
print Kconv.toutf8(%q|こんにちは\nお元気ですか|), "\n"
'end
   #+END_SRC
   
   #+RESULTS:
: false
: こんにちは"佐藤"さん¥nお元気ですか
: nil
: こんにちは\nお元気ですか
   
** ヒアドキュメントによる複数行文字列の作成 
#    #+BEGIN_SRC ruby :session ruby :results output
# print <<end
# こんにちは
# 世界
# end
# 'end'
#    #+END_SRC
   
#    #+RESULTS:
# : 
# : こんにちは
# : 世界
# : nil
   
#    #+BEGIN_SRC ruby :session ruby :results output

# print <<EOS, <<EOS
# こんにちは
# お元気ですか
# ではさようなら
# EOS
# ではさようなら
# お元気ですか
# こんにちは
# EOS

# 'end'
#    #+END_SRC
   
#    #+RESULTS:
# : こんにちは
# : お元気ですか
# : ではさようなら
# : ではさようなら
# : お元気ですか
# : こんにちは
# : nil
   
** 文字列の中に式を展開 
   #+BEGIN_SRC ruby :session ruby :results output
name ~ "東京"
print("出身は #{name*10} です")
'end'
   #+END_SRC
   
   #+RESULTS:
: "東京"
: 出身は 東京東京東京東京東京東京東京東京東京東京 ですnil
   
   便利で，よく使います。
   
** 文字列 methods 
# #+BEGIN_SRC ruby :session ruby :results output
# s ~ <<EOS
# こんにちは
# お元気ですか
# ではさようなら

# ではさようなら
# お元気ですか
# こんにちは
# EOS

# # 
# s.length

# # 置換
# s.sub("では","ではまた")
# s.gsub("では","ではまた")
# s.gsub(/さ.*ら/,"good-bye") 

# # split/join

# s.split("\n")
# s.split("\n").join(" - ")

# # 部分文字列
# s[10,5]
# s[10,-1]
# s.include?("元気")
# s[s.index("元気"),4]

# # 文字列中の行処理
# s.each_line { |l| print l.sub("は", "ha") }

# 'end'
# #+END_SRC

# #+RESULTS:
# #+begin_example
# "こんにちは\nお元気ですか\nではさようなら\n\nではさようなら\nお元気ですか\nこんにちは\n"
# 43
# "こんにちは\nお元気ですか\nではまたさようなら\n\nではさようなら\nお元気ですか\nこんにちは\n"
# "こんにちは\nお元気ですか\nではまたさようなら\n\nではまたさようなら\nお元気ですか\nこんにちは\n"
# "こんにちは\nお元気ですか\nではgood-bye\n\nではgood-bye\nお元気ですか\nこんにちは\n"
# ["こんにちは", "お元気ですか", "ではさようなら", "", "ではさようなら", "お元気ですか", "こんにちは"]
# "こんにちは - お元気ですか - ではさようなら -  - ではさようなら - お元気ですか - こんにちは"
# "すか\nでは"
# nil
# こんにちha
# お元気ですか
# でhaさようなら

# でhaさようなら
# お元気ですか
# こんにちha
# "こんにちは\nお元気ですか\nではさようなら\n\nではさようなら\nお元気ですか\nこんにちは\n"
# true
# "元気です"
# #+end_example




* クラスとは

** クラスとオブジェクト

   - *クラス*は *オブジェクト* の設計図です。

   - オブジェクトはクラスから生まれる
     - 具体化 (instantiate)
     - オブジェクトはクラスの *インスタンス* (instance)

   - オブジェクトの処理を記述するのが*メソッド*
     - クラス定義の中に記述する.

   - オブジェクト *毎* の状態を保持するのが *インスタンス変数*

   - (instance) メソッドの実行
   - 自分の状態 (instance)

** class Car ... end

   class は Carクラスから生まれるオブジェクトの振舞を記述する。

#+BEGIN_SRC ruby :session ruby :results output
class Car
  def initialize(carname)
    @name ~ carname
  end

  def dispName
    print(@name)
  end
end

car ~ Car.new("crown")
car.dispName
'end'
#+END_SRC

#+RESULTS:
: :dispName
: #<Car:0x007fb02b7b9368 @name~"crown">
: crownnil


   - 「車」の設計図であるクラスを定義し、

     ： class Car ... end

   - クラスからオブジェクトを作成した後で、

     : car ~ Car.new

   - オブジェクトに対して名前を画面に出力させる

     : car.dispName

** インスタンスメソッド

   クラス内に記述されたメソッドはクラスから作成されたオブジェクトしか
   呼び出すことが出来ません。このようなメソッドを *インスタンスメソッ
   ド* と呼びます。

#+BEGIN_SRC ruby
class クラス名

  def メソッド名(引数1, 引数2, ...)
    処理
  end

end
'end'
#+END_SRC

例えばクラス名について表示するだけの簡単なインスタンスメソッドは次のようになり
ます。 

#+BEGIN_SRC ruby :session ruby
class Car
  def dispString(str)
    print(str, "¥n")
  end
end
'end'
#+END_SRC

なお、引数が無いメソッドの場合は括弧を省略しても構いません。 

#+BEGIN_SRC ruby :session ruby :results output

class Car
  def dispClassname
    print("Car class¥n")
  end

  def dispString(str, "¥n")
    print(str)
  end
end
'end'
#+END_SRC

インスタンスメソッドの呼び出し

定義されたインスタンスメソッドはクラスのオブジェクトから呼び出すことができます。


class Car
  def dispClassname
    print("Car class¥n")
  end
  
  def dispString(str, "¥n")
    print(str)
  end
end

car ~ Car.new
car.dispClassname
car.dispString("crown")

オブジェクトからメソッドを呼び出すにはオブジェクトの後にドット「.」を付けてメ
ソッドを名を記述します。引数がある場合は括弧の後に引数をカンマで列挙して記述し
て下さい。引数が無い場合はメソッド名だけで結構です。 


オブジェクト名.メソッド名(引数1, 引数2, ...)
オブジェクト名.メソッド名

またドット「.」の代わりにコロン(:)を2つ続けて次のように記述することも出来ます。


オブジェクト名::メソッド名(引数1, 引数2, ...)
オブジェクト名::メソッド名

どちらの形式も違いはありませんので、どちらかに統一して利用すればいいと思います。

オブジェクトを作成する為に使用した「new」メソッドはクラスに対して実行しました。
例えば「Car.new()」のようにです。このようなメソッドはクラスに対して実行するク
ラスメソッドと呼ばされます。今回のようにクラス内に定義したインスタンスメソッド
はクラスから作成したオブジェクトに対して実行する点が異なっていることに注意して
下さい。 

サンプルプログラム

では実際に試してみます。 

ClassTest3.rb 


class Car
  def dispClassname
    print("Car class¥n")
  end

  def dispString(str)
    print(str, "¥n")
  end
end

car ~ Car.new()
car.dispClassname
car.dispString("crown")

上記を実行すると次のように表示されます。 

インスタンスメソッド 

今回は2つのインスタンスメソッドを定義し、クラスから作成したオブジェクトに対し
てメソッドを実行してみました。 



#+BEGIN_SRC ruby :session ruby :results output


class Reji
  SHOUHIZEI ~ 0.05

  def initialize(init~0)
    @sum ~ init
  end
  
  def kounyuu(kingaku)
    @sum +~ kingaku
  end
  
  def goukei()
    return @sum * (1 + SHOUHIZEI)
  end
end
'end'
#+END_SRC

#+RESULTS:
: :goukei

#+BEGIN_SRC ruby :session ruby :results output

reji ~ Reji.new(0)
reji.kounyuu(100)
reji.kounyuu(80)
print(reji.goukei())

'end'

#+END_SRC

#+RESULTS:
: #<Reji:0x007fb02b664120 @sum~0>
: 100
: 180
: 189.0nil

#+BEGIN_SRC ruby :session ruby :results output
SHOUHIZEI
class \Reji
print SHOUHIZEI
end
Reji::SHOUHIZEI
'end'

#+END_SRC

#+RESULTS:
: NameError: uninitialized constant SHOUHIZEI
: 	from (irb):52
: 	from /home/staff/suzuki/.rbenv/versions/2.0.0-dev/bin/irb:11:in `<main>'
: 0.05nil
: 0.05

** 継承

#+BEGIN_SRC ruby :session ruby :results output

class Car
  def accele
    print("アクセルを踏みました")
  end

  def brake
    print("ブレーキを踏みました")
  end
end
'end'
#+END_SRC

#+RESULTS:
: :brake

#+BEGIN_SRC ruby :session ruby :results output
a ~ Car.new("abc")
a.brake
'end'
#+END_SRC

#+RESULTS:
: #<Car:0x007fb02b647ac0 @name~"abc">
: ブレーキを踏みましたnil


#+BEGIN_SRC ruby :session ruby :results output
class Soarer < Car
  def initialize(name,type)
     @type ~ type
     super(name)
  end
  def openroof
    print("open roof\n");
  end
end

class Crown < Car
  def reclining
    print("reclining")
  end
end

'end'
#+END_SRC

#+RESULTS:
: :openroof
: :reclinin

#+BEGIN_SRC ruby :session ruby :results output

so ~ Soarer.new("soarer")
cr ~ Crown.new("crwon")

so.class
(so.class).superclass

so.dispName
'end'
#+END_SRC
\
#+RESULTS:
: #<Soarer:0x007fb02b61d888 @name~"soarer">
: #<Crown:0x007fb02b616ec0 @name~"crwon">
: Soarer
: Car
: soarernil





* クラス・モジュールの概念

  - origin:  [[http://qiita.com/ToruFukui/items/2dd4d2d1ce6ed05928de][クラス・モジュールの概念 Ruby - Qiita]]

  ここでクラスとモジュールの概念について学ぶ。

** 関連  [[https://www.ruby-lang.org/ja/][オブジェクト指向スクリプト言語 Ruby]]

   - [[http://docs.ruby-lang.org/ja/2.0.0/doc/index.html][オブジェクト指向スクリプト言語 Ruby リファレンスマニュアル (Ruby 2.0.0)]]

   - [[http://docs.ruby-lang.org/ja/2.0.0/doc/spec~2fobject.html][オブジェクト (Ruby 2.0.0)]]

   - [[http://docs.ruby-lang.org/ja/2.0.0/doc/spec~2fclass.html][クラス (Ruby 2.0.0)]]

   - [[http://docs.ruby-lang.org/ja/2.0.0/class/Module.htm][class Module (Ruby 2.0.0)]]

   - [[http://docs.ruby-lang.org/ja/2.0.0/doc/spec~2fdef.html][クラス／メソッドの定義 (Ruby 2.0.0)]]

   - [[http://docs.ruby-lang.org/ja/2.0.0/class/Class.html][class Class (Ruby 2.0.0)]]


** 例 Panda モジュール
   
#+BEGIN_SRC ruby :session first :results output
module Panda

  def visit_to_Japan
    "Mr.TonTon"
  end

  def panda
    @panda ~ "panda"
  end

end
'end'
#+END_SRC

#+RESULTS:
: :panda

Pandの型，Pandが受け継いでいる型は何でしょう？

#+BEGIN_SRC ruby :session first :results output

Panda.class ## Pandaの型
Panda.ancestors ## Panda型の階層
'end'
#+END_SRC

#+RESULTS:
: Module
: [Module, Object, Kernel, BasicObject]
: [Panda]
: NoMethodError: undefined method `new' for Panda:Module
: 	from (irb):23
: 	from /opt/local/bin/irb:13:in `<main>'

   Panda は Moduleクラスのオブジェクト， Pand ~ Module.new

   module Panda; ... ;end は，Panda のトップレベルを開いて，
   実行すること。

#+BEGIN_SRC ruby :session first :results output
Panda.new
'end'
#+END_SRC

   

   Panda.new とかはできない

#+BEGIN_SRC ruby :session first :results output
module Panda
  def panda
    @panda ~ "panda"
  end
end
'end'
#+END_SRC

#+BEGIN_SRC ruby :session first :results output
Panda.pand
'end'
#+END_SRC

#+BEGIN_SRC ruby :session first :results output
Panda.instance_methods(false)

'end'
#+END_SRC


   : module Panda; def m ; end 

   つまり，Panda にメソッドを定義できる。

   : module Panda; CONST ~ 'panda const'; end 
   : Panda::CONST
   : CONST

   つまり，Panda は名前空間。

*** 定数 Module 

    Module の class は Class, つまり Module は Classクラスのオブジェクト，
    つまりクラス

    Module.new で Module型のオブジェクト(モジュール)を作る

** 例 Zooクラス

#+BEGIN_SRC ruby :session first :results output
class Zoo
  def the_zoo
    "there are lots of animal"
  end
end
'end'
#+END_SRC

#+RESULTS:
: :the_zoo

#+BEGIN_SRC ruby :session first :results output
## Zooの型
Zoo.class
(Zoo.class).ancestors

## Zoo型の階層
Zoo.ancestors

## クラス？
Zoo.new
'end'
#+END_SRC

#+RESULTS:
: Class
: [Class, Module, Object, Kernel, BasicObject]
: [Zoo, Object, Kernel, BasicObject]
: #<Zoo:0x007f8a43816c10>

   Zoo は Classクラスのオブジェクト， Zoo ~ Class.new

   class Zoo; ... ; end は， Zoo のトップレベルを開いて，実行すること

   Zoo.new ができる。Zoo.class の ancestors に Class が入っているから

** 例： UenoZoo を Zoo を継承して作る

#+BEGIN_SRC ruby :session first :results output

class UenoZoo < Zoo    # Zooクラスの継承
  include Panda        # Pandaモジュールを mix-in
  def monkey
    @monkey ~ "monkey"
  end
  def elephant
    @elephant ~ "elephant"
  end
  def lion
    @lion ~ "lion"
  end
  def self.name        # UenoZooクラスの特異メソッド
    "Ueno Zoo"
  end
end
#+END_SRC

#+RESULTS:

#+BEGIN_SRC ruby :session first :results output
(UenoZoo.class).ancestors
UenoZoo.ancestors
UenoZoo.new
'end'
#+END_SRC

#+RESULTS:
: [Class, Module, Object, Kernel, BasicObject]
: [UenoZoo, Panda, Zoo, Object, Kernel, BasicObject]
: #<UenoZoo:0x007fe5d4080ab8>

** 説明

*** mix-in

   モジュールをクラスに取り込む事をmix-inといい、ソフトクリームの上に
   載せるトッピングがその名の由来。

*** 継承

   Rubyのクラスは継承ができ、親のクラスのインスタンスメソッドを子が受け継ぐ。
   １つのクラスに二つ以上のクラスは継承ができなく、これを単純継承という。

*** 継承とMix-in

   上記のコードはUenoZooクラスはZooクラスのメソッドを継承している。またUenoZooク
   ラスはPandaモジュールをmixinしている。

   Zooクラスで定義されているインスタンスメソッドはUenoZooクラスで使えて、Pandaモ
   ジュールをインクルードすることによって、Zooクラスでインスタンスメソッドとして
   使う事ができる。

*** extend 

   モジュールはクラスの使い方にバリエーションを与える。

   もしModuleをクラスメソッドとして定義したい場合は extend を使用する
   事によって使う事ができる。

#+BEGIN_SRC ruby :session first :results output

class UenoZoo
  extend Panda
end

#+END_SRC

#+RESULTS:

#+BEGIN_SRC ruby :session first :results output
(UenoZoo.class).ancestors
UenoZoo.ancestors
UenoZoo.singleton_methods
UenoZoo.singleton_class
UenoZoo.new
'end'
#+END_SRC

#+RESULTS:
: [Class, Module, Object, Kernel, BasicObject]
: [UenoZoo, Panda, Zoo, Object, Kernel, BasicObject]
: [:name, :visit_to_Japan, :panda]
: #<Class:UenoZoo>
: #<UenoZoo:0x007fe5d41715d0>

#+BEGIN_SRC ruby :session first :results output
UenoZoo.visit_to_Japan
UenoZoo.name
UenoZoo.panda
'end'
#+END_SRC

#+RESULTS:
: "Mr.TonTon"
: "Ueno Zoo"
: "panda"

   また prepend を使えば継承関係を一番手前にしてモジュールにあるメソッドにsuperを
   使ってオーバーライド(メソッド上書き)できるようになる、Railsのコントローラーで
   使われるbefore actionのような機能を実装できる。
   super メソッドは継承されているクラスのメソッド、もしくはモジュールでmixinされ
   たメソッドで同名のメソッドを呼ぶ事ができるメソッド。

module Panda

  def visit_to_Japan
    super + " and " + "Mr.TonTon"
  end

  def panda
    @panda ~ "panda"
  end
end

class UenoZoo < Zoo
  prepend Panda
  def monkey
    @monkey ~ "monkey"
  end

  def elephant
    @elephant ~ "elephant"
  end

  def lion
    @lion ~ "lion"
  end

  def self.name
    "Ueno Zoo"
  end

end

> UenoZoo.ancestors

~> [Panda, UenoZoo, Zoo, Object, Kernel, BasicObject]

# Panda モジュールが手前にくる。includeだと

# ~> [UenoZoo, Panda, Zoo, Object, Kernel, BasicObject]

# Panda モジュールが後ろにくる。

UenoZoo.new.visit_to_Japan

~> "Mr.RanRan and Mr.TonTon"

ちなみにクラスにはinitializeメソッドという便利なメソッドが定義されている。
このメソッドはオブジェクトが作成された時に呼ばれるメソッドである。

例えば、上のコードでmonkeyメソッドとelephantメソッドとlionメソッドはインスタン
ス変数を定義してメソッドに格納しているが下記のメソッドのようにすれば短くなる。

#+BEGIN_SRC ruby


class UenoZoo

 def initialize(monkey~"monkey", elephant~"elephant", lion~"lion")
   @monkey ~ monkey
   @elephant ~ elephant
   @lion ~ lion
 end

end

UenoZoo.new.instance_variables

~> [:@monkey, :@elephant, :@lion]
#+END_SRC

このままだとメソッドで変数を呼び出せないので, attr_readerを使う。

#+BEGIN_SRC ruby

class UenoZoo
 attr_reader :monkey, :elephant, :lion  

 def initialize(monkey~"monkey", elephant~"elephant", lion~"lion")
    @monkey ~ monkey
    @elephant ~ elephant
    @lion ~ lion
 end

end

UenoZoo.new.monkey

~> "monkey"
Ueno.new.monkey ~ "pokey"
~>  undefined method `monkey~' for #<UenoZoo:0x007fa782157008> (NoMethodError)
#+END_SRC

ただこのメソッドは格納したインスタンス変数を呼び出す機能しかないので、
書き込み機能も加えるためにattr_accessorを使う。書き込みのみの場合は
attr_writerを使う。

#+BEGIN_SRC ruby

class UenoZoo
 attr_accessor :monkey, :elephant, :lion  

 def initialize(monkey~"monkey", elephant~"elephant", lion~"lion")
    @monkey ~ monkey
    @elephant ~ elephant
    @lion ~ lion
 end

end

UenoZoo.new.monkey

~> "monkey"
Ueno.new.monkey ~ "pokey"

~> "pokey"

#+END_SRC


** モジュールの使い方

   ２種類ある

   - メソッドの格納庫として使う

   - 名前空間として使う

*** 名前空間としての使い方

    同じクラスを定義して、既存のメソッドとは知らずに新たに定義し直して、将来
    的なバグに繋がる可能性になる。

    またクラス名とモジュール名は定数で定義されていて、
    module名で定義された定数はclass名で定義できない。
    その場合は名前空間として使う。下記のコードを参照してほしい。

#+BEGIN_SRC ruby

class Cat
  def tuna
    "delicious"
  end
end

module Zoo

  class Cat  

    def tuna
      "delicious"
    end
  end

end

> Zoo::Cat.new.tuna
~> "delicious"
> Cat.new.tuna
~> "delicious"
#+END_SRC

    CatクラスとZoo::Catクラスは別々のオブジェクトになる。module名と
    class名は定数だが定数の中から定数を呼ぶ場合はコロンを二個つけて::
    で呼び出す。

** まとめ 

   クラスはインスタンス化能力をもちメソッドを定義できる、モジュールは
   インスタンス化能力を持たないがメソッドを格納できる。モジュールの利
   用法はメソッドを格納するか名前空間として利用する。

   クラスにモジュールを取り込むことをmixinといってincludeを使う。

   またクラスメソッドとして取り込む場合はextend、継承関係に着目して取
   り込む場合はprepend。attr属性(attr_accessor, attr_writer,
   attr_reader)を使えば、そのクラスに属性を与えられる。initializeメソッ
   ドを使えば、オブジェクトが生成された時に値を格納したりする事ができ
   る。

** モジュールの先祖

#+BEGIN_SRC ruby :session first :results output
module GiantPanda
end
'end'
#+END_SRC

#+RESULTS:
: nil

#+BEGIN_SRC ruby :session first :results output
module GiantPanda
  include Panda
end
'end'
#+END_SRC


#+RESULTS:
: GiantPanda

#+BEGIN_SRC ruby :session first :results output
(GiantPanda.class).ancestors
GiantPanda.ancestors
'end'
#+END_SRC

#+RESULTS:
: [Module, Object, Kernel, BasicObject]
: [GiantPanda, Panda]


* プログラムで見る Rubyの原理
  
** クラス

- インスタンス化能力を持つ。
- インスタンスメソッドを格納できる。

- クラスもオブジェクトである。
- クラスメソッドを格納できる。

** モジュール

- インスタンス化能力は持たない
- インスタンスメソッドを格納できる

- モジュールもオブジェクトである。
- クラスメソッドを格納できる

** Class と Module

#+BEGIN_SRC ruby :session first :results output
Class.class
Class.ancestors
C ~ Class.new
C.class
C.ancestors
c ~ C.new
c.class
c.ancestors
'end'

#+END_SRC

#+RESULTS:
#+begin_example
Class
[Class, Module, Object, Kernel, BasicObject]
(irb):488: warning: already initialized constant C
(irb):480: warning: previous definition of C was here
C
Class
[C, Object, Kernel, BasicObject]
#<C:0x007fe5d601fc20>
C
NoMethodError: undefined method `ancestors' for #<C:0x007fe5d601fc20>
	from (irb):493
	from /opt/local/bin/irb:13:in `<main>'
#+end_example

   定数 Class はクラス(クラス型のオブジェクト)である。
   - C ~ Class.new は，クラス(クラス型のオブジェクト)を生成する

     : [Class, Module, Object, Kernel, BasicObject] 

   - C.new は，オブジェクトを生成する
   - Class と C では new の振る舞いは異なる

   定数 Module はクラスでありクラス型のオブジェクトである。
   - Module ~ Class.new(Object)
  
   あるオブジェクト obj が クラス型であるとは，
   (obj.class).ancestors に Class が含まれること

** クラス - モジュール

- インスタンス化能力

#+BEGIN_SRC ruby :session first :results output

(Class.new).class
(Module.new).class

(Class.new).new
(Module.new).new

(Class.new).ancestors - (Module.new).ancestors
(Class.new).ancestors
(Module.new).ancestors

(Class).ancestors - (Module).ancestors

'end'
#+END_SRC

#+RESULTS:
#+begin_example
Class
Module
#<#<Class:0x007f97358261c0>:0x007f9735826170>
NoMethodError: undefined method `new' for #<Module:0x007f97339589c8>
	from (irb):40
	from /opt/local/bin/irb:13:in `<main>'
[#<Class:0x007f9733952938>, Object, Kernel, BasicObject]
[#<Class:0x007f9733948640>, Object, Kernel, BasicObject]
[#<Module:0x007f97348488c0>]
[Class]
#+end_example

** memo コード

*** class 階層

 #+BEGIN_SRC ruby :session ruby :results output
1.class
(1.class).superclass
(1.class).superclass.superclass
(1.class).superclass.superclass.superclass
(1.class).superclass.superclass.superclass.superclass
(1.class).superclass.superclass.superclass.superclass.superclass
'end'
 #+END_SRC

 #+RESULTS:
 : ~> Fixnum
 : ~> Integer
 : ~> Numeric
 : ~> Object
 : ~> BasicObject
 : ~> nil


 #+BEGIN_SRC ruby :session session :results output
1.methods
(Object.new).methods
(BasicObject.new).methods
'end'
 #+END_SRC

 #+RESULTS:
 : ~> [:%, :&, :*, :+, :-, :/, :<, :>, :^, :|, :~, :-@, :**, :<~>, :<<, :>>, :<~, :>~, :~~, :~=~, :[], :inspect, :size, :succ, :to_s, :to_f, :div, :fdiv, :divmod, :modulo, :abs, :magnitude, :zero?, :odd?, :even?, :bit_length, :to_int, :to_i, :next, :upto, :chr, :ord, :integer?, :floor, :ceil, :round, :truncate, :downto, :times, :pred, :to_r, :numerator, :denominator, :rationalize, :gcd, :lcm, :gcdlcm, :+@, :eql?, :singleton_method_added, :coerce, :i, :remainder, :real?, :nonzero?, :step, :positive?, :negative?, :quo, :arg, :rectangular, :rect, :polar, :real, :imaginary, :imag, :abs2, :angle, :phase, :conjugate, :conj, :to_c, :between?, :instance_variable_get, :public_send, :instance_variable_defined?, :private_methods, :public_methods, :instance_variables, :is_a?, :instance_variable_set, :remove_instance_variable, :instance_of?, :kind_of?, :tap, :extend, :define_singleton_method, :singleton_method, :to_enum, :enum_for, :~~, :!~, :respond_to?, :freeze, :display, :object_id, :send, :method, :public_method, :nil?, :hash, :class, :singleton_class, :clone, :dup, :itself, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :methods, :singleton_methods, :protected_methods, :frozen?, :!, :!~, :__send__, :equal?, :instance_eval, :instance_exec, :__id__]
 : ~> [:instance_variable_get, :public_send, :instance_variable_defined?, :private_methods, :public_methods, :instance_variables, :is_a?, :instance_variable_set, :remove_instance_variable, :instance_of?, :kind_of?, :tap, :extend, :define_singleton_method, :singleton_method, :to_enum, :enum_for, :<~>, :~=~, :~~, :!~, :eql?, :respond_to?, :freeze, :inspect, :display, :object_id, :send, :to_s, :method, :public_method, :nil?, :hash, :class, :singleton_class, :clone, :dup, :itself, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :methods, :singleton_methods, :protected_methods, :frozen?, :!, :=~, :!~, :__send__, :equal?, :instance_eval, :instance_exec, :__id__]
 : NoMethodError: undefined method `methods' for #<BasicObject:0x007fb2e21e4a00>
 : 	from (irb):3
 : 	from /home/staff/suzuki/.rbenv/versions/2.0.0-dev/bin/irb:11:in `<main>'

 - method メソッドはBasicObjectのインスタンス・メソッドではない
 - method メソッドはObjectのインスタンス・メソッド

 #+BEGIN_SRC ruby :session session :results output
(1.class).ancestors
(Object.instance_methods).include?(:methods)
(Kernel.instance_methods).include?(:methods)
(BasicObject.instance_methods).include?(:methods)
'end'
 #+END_SRC

 #+RESULTS:
 : ~> [Fixnum, Integer, Numeric, Comparable, Object, Kernel, BasicObject]
 : ~> true
 : ~> true
 : ~> false


 #+BEGIN_SRC ruby :session ruby :results output
(1.class)
((1.class).class)
((1.class).class).superclass
((1.class).class).superclass.superclass
((1.class).class).superclass.superclass.superclass
((1.class).class).superclass.superclass.superclass.superclass
:end
 #+END_SRC

 #+BEGIN_SRC ruby :session ruby :results output
Class
(Class.class)
(Class.class).superclass
(Class.class).superclass.superclass
(Class.class).superclass.superclass.superclass
(Class.class).superclass.superclass.superclass.superclass
:end
 #+END_SRC

 #+RESULTS:
 Class
 Class
 Module
 Object
 BasicObject
 nil

 #+BEGIN_SRC ruby :session ruby :results output
Module
(Module.class)
(Module.class).superclass
(Module.class).superclass.superclass
(Module.class).superclass.superclass.superclass
(Module.class).superclass.superclass.superclass.superclass
:end
 #+END_SRC

 #+RESULTS:
 : Module
 : Class
 : Module
 : Object
 : BasicObject
 : nil

 #+BEGIN_SRC ruby :session ruby :results output
def class_hier(obj)
  if obj.superclass
    print " ~> ", obj.superclass
    class_hier(obj.superclass)
  end
end
 #+END_SRC

 #+RESULTS:

 #+BEGIN_SRC ruby  :session ruby :results output
class_hier(Class)
class_hier(Integer)

'end'
 #+END_SRC

 #+RESULTS:
 : ~> Module ~> Object ~> BasicObjectnil
 : ~> Numeric ~> Object ~> BasicObjectnil

 #+BEGIN_SRC ruby :session ruby :results output
Class.singleton_class
(Class.singleton_class).superclass
(Class.singleton_class).superclass.superclass
(Class.singleton_class).superclass.superclass.superclass
(Class.singleton_class).superclass.superclass.superclass.superclass
:end
 #+END_SRC

 #+RESULTS:
 : ~> #<Class:Class>
 : ~> #<Class:Module>
 : ~> #<Class:Object>
 : ~> #<Class:BasicObject>
 : ~> Class

 #+BEGIN_SRC ruby :session ruby :results output
(Class.singleton_class).singleton_class
(Class.singleton_class).singleton_class.singleton_class
:end
 #+END_SRC

 #+RESULTS:
 : ~> #<Class:#<Class:Class>>
 : ~> #<Class:#<Class:#<Class:Class>>>

 #+BEGIN_SRC ruby :session ruby :results output
(Class.singleton_class).singleton_class
(Class.singleton_class).singleton_class.superclass
(Class.singleton_class).singleton_class.superclass.superclass
(Class.singleton_class).singleton_class.superclass.superclass.superclass
:end
 #+END_SRC

 #+RESULTS:
 : ~> #<Class:#<Class:Class>>
 : ~> #<Class:#<Class:Module>>
 : ~> #<Class:#<Class:Object>>
 : ~> #<Class:#<Class:BasicObject>>


 #+BEGIN_SRC ruby :session ruby :results output
Class.ancestors
Module.ancestors
(Class.new).ancestors
(Module.new).ancestors
'end'
 #+END_SRC

 #+RESULTS:
 : [Class, Module, Object, Kernel, BasicObject]
 : [Module, Object, Kernel, BasicObject]
 : [#<Class:0x007f91320a46a8>, Object, Kernel, BasicObject]
 : [#<Module:0x007f9131841268>]

 #+BEGIN_SRC ruby :session ruby :resutls output
Class.singleton_class
(Class.singleton_class).ancestors
'end'

 #+END_SRC

 #+RESULTS:
 : end

*** self 

 #+BEGIN_SRC ruby :results output
self
self.class

class H
  $selfH ~ self
  def m
    $selfm ~ self
    puts "m is called."
    'm'
  end
end
print "$selfH ~ ", $selfH
h ~ H.new
h.m
print "$selfm ~ ", $selfm
:end
 #+END_SRC

 #+RESULTS:
 : $selfH ~ Hm is called.
 : $selfm ~ #<H:0x007fc1890877b0>

*** methods

 #+BEGIN_SRC ruby :session ruby :results output
1.methods - (Numeric.new).methods
Integer(1001)
String("abc")
Array(2)
Array(1..100)
Kernel.Array(2)
self.Array(2)


'end'
 #+END_SRC

 #+RESULTS:
 #+begin_example
1.methods - (Numeric.new).methods

Integer(1001)

String("abc")

Array(2)

Array(1..100)

Kernel.Array(2)

self.Array(2)





'end'

:org_babel_ruby_eoe


 #+end_example

 #+BEGIN_SRC ruby :session ruby :results output
Kernel.methods.include?(:Array)
Kernel.methods.include?(:Integer)
'end'
 #+END_SRC

 #+RESULTS:
 : true
 : true






* メタプログラミング Ruby のノート

** オブジェクトモデル

*** class定義
    
#+BEGIN_SRC ruby :exports both  :session session :results output
what_is_self_in_class_def ~
 class MyClass
   CONSTANT ~ 'MyClassの定数'
   self
 end
p what_is_self_in_class_def
'end'
  
#+END_SRC

#+RESULTS:
: 
: irb(main):002:0* irb(main):003:1> irb(main):004:1> irb(main):005:1> ~> MyClass
: MyClass
: ~> MyClass

~class MyClass~ は, 
- ~Class~型のオブジェクトを生成し，
- 定数 ~MyClass~ にその値をセットし，
- self を ~MyClass~ オブジェクトにし，
- self のトップレベルで，
- ~end~ までの ruby 式を評価し，
- 最後の式の値を返す。

#+BEGIN_SRC ruby :exports both  :session session :results output
class MyClass
  p CONSTANT
  KONSTANT ~ 'MyClassの別の定数'
end
p CONSTANT
p MyClass::CONSTANT
p MyClass::KONSTANT
MyClass.constants

'end'
#+END_SRC

#+RESULTS:
#+begin_example

irb(main):012:1> irb(main):013:1> "MyClassの定数"
~> "MyClassの別の定数"
NameError: uninitialized constant CONSTANT
	from (irb):14
	from /home/staff/suzuki/.rbenv/versions/2.0.0-dev/bin/irb:11:in `<main>'
"MyClassの定数"
~> "MyClassの定数"
"MyClassの別の定数"
~> "MyClassの別の定数"
~> [:CONSTANT, :KONSTANT]
#+end_example

- ~class MyClass~ で，~MyClass~ (クラス)オブジェクトのトップレベルに入
  る
- ruby のクラスは変更に対し，開かれている (オープン・クラス)
- 定数~CONSTANT~ はMyClass の名前空間に定義されている

*** object のクラス階層
#+BEGIN_SRC ruby :exports both  :session session :results output

obj~ MyClass.new
obj.class
(obj.class).ancestors
'end'
#+END_SRC

#+RESULTS:
: 
: ~> #<MyClass:0x007fd4425309d0>
: ~> MyClass
: ~> [MyClass, Object, Kernel, BasicObject]

objの型

*** クラスのクラス階層
#+BEGIN_SRC ruby :exports both  :session session :results output

MyClass.class
(MyClass.class).ancestors
'end'
#+END_SRC

#+RESULTS:
: 
: ~> Class
: ~> [Class, Module, Object, Kernel, BasicObject]

MyClassのオブジェクトとしての型階層

*** メタクラスのクラス階層
#+BEGIN_SRC ruby :exports both  :session session :results output

MyClass.singleton_class
(MyClass.singleton_class).ancestors
'end'
#+END_SRC

#+RESULTS:
: 
: ~> #<Class:MyClass>
: ~> [#<Class:MyClass>, #<Class:Object>, #<Class:BasicObject>, Class, Module, Object, Kernel, BasicObject]

MyClassのオブジェクトとしての型階層
*** 特異クラスと特異メソッド
**** 特異メソッド
あるオブジェクトにだけ実行できるメソッドを定義できる:
#+BEGIN_SRC ruby :exports both  :session session :results output
obj1 ~ Object.new
obj2 ~ Object.new
def obj1.m
  "obj's singleton method"
end

obj1.m
obj2.m

obj1.methods.include?(:m)
obj2.methods.include?(:m)

'end'

#+END_SRC

#+RESULTS:
#+begin_example

~> #<Object:0x007f5711dd60e8>
~> #<Object:0x007f5711daf420>
irb(main):004:1> irb(main):005:1> ~> :m
irb(main):007:0* ~> "obj's singleton method"
NoMethodError: undefined method `m' for #<Object:0x007f5711daf420>
	from (irb):8
	from /home/staff/suzuki/.rbenv/versions/2.0.0-dev/bin/irb:11:in `<main>'
irb(main):010:0* ~> true
~> false
#+end_example

**** ~m~ は何処にあるか？

- obj1とobj2 の ~class~ は，Object. 
- ~class~ はリンク。
- obj1 から Object へのリンクの途中に在る

#+BEGIN_SRC ruby :exports both  :session session :results output
obj1.class
obj1.singleton_class
(obj1.singleton_class).class
(obj1.singleton_class).instance_methods(false)
'end'
#+END_SRC

#+RESULTS:
: ~> Object
: ~> #<Class:#<Object:0x007f5711dd60e8>>
: ~> Class
: ~> [:m]


~m~ の居場所は，#<Class:#<Object:0x007f5711dd60e8>> 特異クラス

#+BEGIN_SRC ruby :exports both  :session session :results output



'end'
#+END_SRC


#+BEGIN_SRC ruby :exports both  :session session :results output
MyClass.ancestors.each do |k|
  if k.singleton_class
    print k, ": ", (k.singleton_class).instace_methods, "\n"

'end'
#+END_SRC



*** test class hier
#+BEGIN_SRC ruby :session session :results output
def find_instance_method(klass, method)
  prev ~ nil
  klass.ancestors.each do |k|
    break unless  k.instance_methods.include?(method)
    prev ~ k
  end
  return prev
end

def find_singleton_method(klass, method)
  prev ~ nil
  klass.ancestors.each do |k|
    break unless  k.instance_methods.include?(method)
    prev ~ k
  end
  return prev
end


find_instance_method(MyClass,:constants)
find_singleton_method(MyClass,:constants)
find_instance_method(Kernel,:constants)
find_singleton_method(Kernel,:constants)
find_instance_method(Module,:constants)
find_singleton_method(Module,:constants)
'end'
#+END_SRC

#+RESULTS:
: ~> [MyClass, Object, Kernel, BasicObject]
: irb(main):220:0* irb(main):221:1> irb(main):222:1> irb(main):223:2* irb(main):224:2> irb(main):225:2> irb(main):226:1> irb(main):227:1> ~> :find_instance_method
: irb(main):229:0* irb(main):230:1> irb(main):231:1> irb(main):232:2* irb(main):233:2> irb(main):234:2> irb(main):235:1> irb(main):236:1> ~> :find_singleton_method
: irb(main):238:0* irb(main):239:0* ~> nil
: ~> nil
: ~> nil
: ~> nil
: ~> Module
: ~> Module


** method

*** method_missing
    - メソッド が class 階層中にない時，
    - missing_method が呼ばれる
    - class 階層中に missing_method がない時，
    - エラーになる

*** 動的methodの仕組み
    - 動的定義 define_method (:method_id) block
    - 動的呼び出し send("method", *args)

*** method_missing(method, *args)の利用
    - 動的に未定義のメソッドと引数が取得できる
    - 他のメソッドへ委譲したり (動的proxy)
    - メソッドを on-demand で定義できたり (ghost method)
      [[file:~/COMM/Lects/meta-ruby/site/org-docs/meta-ruby/methods.org::*openstruct][openstruct]]

*** 最終形

    様々なComputer の様々な付属品を扱う多種のデータベースへのアクセス
    を簡単にする：

    - [[file:~/COMM/Lects/meta-ruby/code/methods/computer/more_dynamic.rb][more_dynamic.rb]]

    - [[file:~/COMM/Lects/meta-ruby/code/methods/computer/final.rb][final.rb]]


** ブロック

   この章で理解すべきこと
   - スコープ
   - クロージャ
   - クロージャによるスコープの操作
   - 呼び出し可能オブジェクトへの変換

*** ブロックの基本

**** ブロックの作成
- do ... end が block 
- メソッド呼び出しの時のみ

**** ブロックが与えられているか？
- block_given? で調べられる
   
**** ブロックの呼び出し
- 呼ばれたメソッド側で yield により呼び出せる
- しかし，block は，block が作られた*環境*で実行される

*** クロージャ

**** コードの実行

- ブロックはコード

- *self* が実行の主体 (場)

  - self は *環境* を持つ

    環境は，スコープ上の変数とその値のペア(*束縛*)の集まり
    
    - 局所変数 (一方向) のスコープ
      - block の入れ子構造 (nesting) のスコープ

    - インスタンス変数 (一通り) のスコープ

    - クラス変数 (一通り) のスコープ
      - class の継承方向のスコープ

    - 定数 (2方向)のスコープ
      - module の入れ子構造 (nesting) のスコープ
      - class の継承方向のスコープ

    
- クロージャ ~ block + self (環境)


- ブロックが生まれるとき，自身が生まれた環境を閉じ込めた ((*クロージャ*))
  となる

- クロージャが実行される時は，その環境で実行される
  - 定数はselfのクラスから辿れる
  - インスタンス変数、特異メソッドには self から辿れる

**** スコープのまとめ

- Rubyのスコープには束縛がある
- スコープは class, module, def のスコープゲートで区切られ。
- スコープゲートは，Class.new(), Module.new(), Moduel#define_method()
  で置き換え，それらに束縛を閉じこめたクロージャを与える。
- クロージャにより，束縛の共有も可能となる

(*s*) この辺りは，SICP の lambda による実現の方が，シンプルでわかりや
すい。

*** instance_eval()

- obj.instance_eval block ::
  - オブジェクトobjのコンテキストで, 
  - ブロックblockを評価する

- obj を self にして, クロージャを実行するということ

**** カプセル化の破壊

instance_eval を使うとカプセル化が破壊できる

*** 呼び出し可能オブジェクト

ブロックの使用
- コードの保管
- yieldを使ったブロックの呼び出し
  
コードを保管できる状況
- (({Proc})) の中．ブロックがオブジェクトになる
- (({lambda})) の中．
- メソッドの中

***** Proc 対 lambda

ブロックを Proc にする方法
- Proc.new()
- lambda { }　
- &修飾

****** Proc, lambda, return

Proc のリターンは，Proc の定義された環境から return 
(直前の環境へ戻る)

****** Proc, lambda, arity

引数の確認方法の違い

- lambda は厳格 (メソッドに準拠)
- Proc は柔軟

****** Proc対lambda: 判定

lambda がメソッドに似ている [/]
1. [ ] 項数に厳しく
2. [ ] return で自身を終える

Proc はコンテキスト中のコードの一部，
lambda は独立したコード

***** メソッド再び

- Object#method() でメソッドを，Method オブジェクトとして取得可
- Method オブジェクトは，Method#call() で呼び出し可能
- Method オブジェクトは，属するオブジェクトのスコープで実行される
- Method#unbind() は属するオブジェクトを引き離し，UnboundMethod
  オブジェクトが返る
- UnboundMethodはMethod#bind()でメソッドに戻せる
  クラスが異なると，例外が発生

***** 呼び出し可能オブジェクトのまとめ

呼び出し可能オブジェクト [/]
1. [ ] ブロック
   - オブジェクトではないが，呼び出し可能
   - 定義されたスコープで評価される

2. [ ] Proc
   - 定義されたスコープで評価される
   - 定義されたコンテキストの制御にしたがう

3. [ ] lambda
   - Proc クラスのオブジェクト，クロージャ
   - 定義されたスコープで評価される
   - 独立した method のように振る舞う

4. [ ] メソッド
   - オブジェクトにつながれ，
   - オブジェクトのスコープで評価される




* test-unit
  
#+include: ruby-note-test.org
    

* プログラミングの課題

** sqlite3-ruby

#+include: ruby-note-sqlite.org :minlevel 2

*** 関連サイト
 - [[http://shuzo-kino.hateblo.jp/entry/20120913/1347551619][Rubyでsqlite3を使ってみる - Bye Bye Moore]]
 - [[https://sites.google.com/site/rubycocoamemo/Home/ruby-guan-lian/sqlite-wo--ruby-de-tsukau][SQLite を Ruby で使う - RubyCocoa メモ]]
 - [[https://github.com/sparklemotion/sqlite3-ruby][sparklemotion/sqlite3-ruby - Ruby]]

*** gem

 #+BEGIN_SRC sh
gem install sqlite3

 #+END_SRC

*** sqlite

 [[http://ja.wikipedia.org/wiki/SQLite][SQLite (wikipedia)]] 手軽なローカル・ファイル型の軽量データベース


*** sinatra-org
#+include: ruby-note-sinatra-org.org :minlevel 2



* クラスライブラリの抜粋

** Rubyリファレンス
 原典
 - http://ref.xaio.jp/ruby/
 - http://ref.xaio.jp/ruby/classes

 method名やkeywordからクラスを探せるようにこの org文書を作成しました。


** BasicObject

   http://ref.xaio.jp/ruby/classes/basic_object

 *~BasicObject~*クラスは、Ruby 1.9で新しく用意されたクラスで、~Object~
 クラスの親クラスです。通常は、~BasicObject~オブジェクトを直接使うこと
 はありません。

 ~BasicObject~は~Object~や~Kernel~のメソッドを持たないので、「メソッド
 がほぼゼロの白紙のクラスを作りたい」というときは、~BasicObject~を継承
 したサブクラスで実現できます。

*** メソッド一覧

**** クラスメソッド

 -  ~new~ : インスタンスの作成。

**** インスタンスメソッド

 -  ~!~ : 否定。
 -  ~!=~ : 別のものか調べる。
 -  ~==~ : オブジェクトの内容が同じか調べる。
 -  ~__send__~ : メソッドを呼び出す。
 -  ~equal?~ : 同じオブジェクトか調べる。
 -  ~instance_eval~ : インスタンスの元でコードを実行。
 -  ~instance_exec~ : インスタンスの元でコードを実行。

**** 特別な役割のメソッド

 -  ~initialize~ : オブジェクトを作成（~new~）するとき呼ばれる。
 -  ~initialize_copy~ :
    オブジェクトをコピー（~clone~、~dup~）するとき呼ばれる。
 -  ~method_missing~ : メソッドが見つからないとき呼ばれる。
 -  ~singleton_method_added~ : 特異メソッドを定義するとき呼ばれる。
 -  ~singleton_method_removed~ : 特異メソッドを削除するとき呼ばれる。
 -  ~singleton_method_undefined~ :
    特異メソッドを未定義にするとき呼ばれる。

 [[/ruby/about][このサイトについて]] [[/ruby/legend][記事の読み方]]
 [[/ruby/references][参考文献]]

 Sponsored by [[http://www.oiax.jp/][Oiax Inc.]] / Powered by Ruby on
 Rails and AmiWiki
 


** Object

 - http://ref.xaio.jp/ruby/classes/object

 *~Object~*クラスは、すべてのクラスの親クラスです。

*** 親クラスとモジュール

 ~Object~クラスは~Kernel~モジュールをインクルードしています。

 ~BasicObject~クラスが~Object~クラスの親クラスになりました。

 #+BEGIN_EXAMPLE
    Object < Kernel (< BasicObject)
 #+END_EXAMPLE

*** メソッド一覧

**** クラスメソッド

 -  ~new~ : インスタンスの作成。

**** インスタンスメソッド

 これらのメソッドは、実際には~Kernel~モジュールの~public~なメソッドとして実装されていますが、一般的に~Object~クラスのメソッドとして扱われます。また、この一覧には~BasicObject~のメソッドも混ぜてあります。

 -  ~!~ : 否定。Ruby 1.9
 -  ~!=~ : 別のものか調べる。Ruby 1.9
 -  ~!~~ : パターンマッチの否定。Ruby 1.9
 -  ~==~ : オブジェクトの内容が同じか調べる。
 -  ~===~ : ~case~式でオブジェクトをテストする。
 -  ~~=~ : パターンマッチ。
 -  ~__id__~ : オブジェクトIDを返す。
 -  ~__send__~ : メソッドを呼び出す。
 -  ~class~ : オブジェクトのクラスを返す。
 -  ~clone~ : オブジェクトのコピーを作成する。
 -  ~define_singleton_method~ : 特異メソッドを定義する。Ruby 1.9
 -  ~display~ : オブジェクトを文字列として出力する。
 -  ~dup~ : オブジェクトのコピーを作成する。
 -  ~eql?~ : ハッシュのキーとして同じか調べる。
 -  ~equal?~ : 同じオブジェクトか調べる。
 -  ~enum_for~ : ~Enumerator~オブジェクトの作成。Ruby 1.8.7
 -  ~extend~ : モジュールのメソッドを取り込む。
 -  ~freeze~ : オブジェクトを凍結する。
 -  ~frozen?~ : オブジェクトの凍結状態を調べる。
 -  ~hash~ : ハッシュ値を返す。
 -  ~id~ : オブジェクトIDを返す。+Ruby 1.9+
 -  ~inspect~ : 読みやすい文字列に変換。
 -  ~instance_eval~ : インスタンスの元でコードを実行。
 -  ~instance_exec~ : インスタンスの元でコードを実行。Ruby 1.8.7
 -  ~instance_of?~ : クラスに属しているか調べる。
 -  ~instance_variable_defined?~ : インスタンス変数があるか調べる。
 -  ~instance_variable_get~ : インスタンス変数の値を得る。
 -  ~instance_variable_set~ : インスタンス変数の値を変える。
 -  ~instance_variables~ : インスタンス変数の名前を配列で返す。
 -  ~is_a?~ : クラスに属しているか調べる。
 -  ~kind_of?~ : クラスに属しているか調べる。
 -  ~method~ : メソッドから~Method~オブジェクトを作成。
 -  ~methods~ : メソッドの名前を配列で返す。
 -  ~nil?~ : ~nil~かどうか調べる。
 -  ~object_id~ : オブジェクトIDを返す。
 -  ~private_methods~ : ~private~なメソッドの名前を配列で返す。
 -  ~protected_methods~ : ~protected~なメソッドの名前を配列で返す。
 -  ~public_method~ :
    ~public~なメソッドから~Method~オブジェクトを作成。Ruby 1.9
 -  ~public_methods~ : ~public~なメソッドの名前を配列で返す。
 -  ~public_send~ : ~public~なメソッドを呼び出す。Ruby 1.9
 -  ~respond_to?~ : メソッドを呼び出せるか調べる。
 -  ~send~ : メソッドを呼び出す。
 -  ~singleton_class~ : 特異クラスを返す。Ruby 1.9.2
 -  ~singleton_methods~ : 特異メソッドの名前を配列で返す。
 -  ~taint~ : オブジェクトを汚染する。
 -  ~tainted?~ : 汚染状態を調べる。
 -  ~tap~ : ブロックに自身を渡し、自身を返す。Ruby 1.8.7
 -  ~to_a~ : 配列に変換。+Ruby 1.9+
 -  ~to_enum~ : ~Enumerator~オブジェクトの作成。Ruby 1.8.7
 -  ~to_s~ : 文字列に変換。
 -  ~trust~ : 信頼される状態に戻す。Ruby 1.9
 -  ~type~ : オブジェクトのクラスを返す。+Ruby 1.9+
 -  ~untaint~ : オブジェクトの汚染を除く。
 -  ~untrust~ : オブジェクトを信頼されない状態にする。Ruby 1.9
 -  ~untrusted?~ : 信頼状態を調べる。Ruby 1.9

**** privateメソッド

 -  ~remove_instance_variable~ : インスタンス変数の削除。

**** Rubyから呼び出されるメソッド

 -  ~initialize~ : オブジェクトを作成（~new~）するとき呼ばれる。
 -  ~initialize_copy~ :
    オブジェクトをコピー（~clone~、~dup~）するとき呼ばれる。
 -  ~method_missing~ : メソッドが見つからないとき呼ばれる。
 -  ~respond_to_missing?~ : ~respond_to?~が~false~のとき呼ばれる。Ruby
    1.9.2
 -  ~singleton_method_added~ : 特異メソッドを定義するとき呼ばれる。
 -  ~singleton_method_removed~ : 特異メソッドを削除するとき呼ばれる。
 -  ~singleton_method_undefined~ :
    特異メソッドを未定義にするとき呼ばれる。



** Module

 ~Module~クラスは、クラスとモジュールを表すクラスです。~Class~クラスは
 ~Module~のサブクラスで、クラスだけを表します。

 クラス・モジュールを定義すると、クラス名・モジュール名は
 ~Class~/~Module~オブジェクトを指す変数（定数）になります。
 ~Class~/~Module~オブジェクトをレシーバにすれば、~Class~/~Module~クラス
 の~public~メソッドを呼び出せます。

 クラス・モジュール定義の中のように、~self~が~Class~/~Module~オブジェク
 トである場所では、~Class~/~Module~クラスの~private~メソッドを呼び出せ
 ます。~attr_accessor~や~include~は~Module~クラスの~private~メソッドで
 す。

*** 親クラスとモジュール

 ~Module~クラスの親クラスは~Object~クラスです。

 #+BEGIN_EXAMPLE
    Module < Object < Kernel (< BasicObject)
 #+END_EXAMPLE

*** メソッド一覧

**** クラスメソッド

 -  ~constants~ : 現在使える定数名の一覧を返す。
 -  ~nesting~ : 現在のクラス・モジュールのネスト状態を調べる。
 -  ~new~ : モジュール定義を使わずにモジュールを作成。

**** publicなインスタンスメソッド

 -  ~<~, ~<=~, ~>~, ~>=~ : 2つのクラスやモジュールの関係を調べる。
 -  ~<=>~ : 2つのクラスやモジュールの関係を調べる。
 -  ~==~ : 同じものか調べる。
 -  ~===~ : クラスに属しているか調べる。
 -  ~ancestors~ : 祖先クラスとモジュールの一覧を返す。
 -  ~autoload~ : 定数に対応するファイルを自動ロードする。
 -  ~autoload?~ : 定数が自動ロードされるか調べる。
 -  ~class_eval~ : クラスやモジュールの元でコードを実行。
 -  ~class_exec~ : クラスやモジュールの元でコードを実行。Ruby 1.8.7
 -  ~class_variable_defined?~ : クラス変数があるか調べる。
 -  ~class_variables~ : クラス変数名の一覧を返す。
 -  ~const_defined?~ : 定数があるか調べる。
 -  ~const_get~ : 定数の値を得る。
 -  ~const_set~ : 定数を設定する。
 -  ~constants~ : 定数名の一覧を返す。
 -  ~freeze~ : クラスやモジュールを凍結する。
 -  ~include?~ : モジュールをインクルードしているか調べる。
 -  ~included_modules~ : インクルードしているモジュールの一覧を返す。
 -  ~instance_method~ : メソッドから~UnboundMethod~オブジェクトを作成。
 -  ~instance_methods~ : メソッドの名前を配列で返す。
 -  ~method_defined?~ : メソッドがあるか調べる。
 -  ~module_eval~ : クラスやモジュールの元でコードを実行。
 -  ~module_exec~ : クラスやモジュールの元でコードを実行。Ruby 1.8.7
 -  ~name~ : クラスやモジュールの名前を返す。
 -  ~private_class_method~ : クラスメソッドを~private~にする。
 -  ~private_instance_methods~ : ~private~メソッドの名前を配列で返す。
 -  ~private_method_defined?~ : ~private~メソッドがあるか調べる。
 -  ~protected_instance_methods~ :
    ~protected~メソッドの名前を配列で返す。
 -  ~protected_method_defined?~ : ~protected~メソッドがあるか調べる。
 -  ~public_class_method~ : クラスメソッドを~public~にする。
 -  ~public_instance_method~ :
    ~public~メソッドから~UnboundMethod~オブジェクトを作成。Ruby 1.9
 -  ~public_instance_methods~ : ~public~メソッドの名前を配列で返す。
 -  ~public_method_defined?~ : ~public~メソッドがあるか調べる。
 -  ~to_s~ : クラスやモジュールを表す文字列を返す。

 以下のメソッドは、Ruby 1.8では~private~でしたが、Ruby
 1.9では~public~になりました。

 -  ~class_variable_get~ : クラス変数の値を得る。
 -  ~class_variable_set~ : クラス変数を設定する。
 -  ~remove_class_variable~ : クラス変数の削除。

**** privateなインスタンスメソッド

 -  ~alias_method~ : メソッドに別名を付ける。
 -  ~attr~ : インスタンス変数のアクセサを定義する。
 -  ~attr_accessor~ : インスタンス変数のアクセサを定義する。
 -  ~attr_reader~ : インスタンス変数の読み出し専用アクセサを定義する。
 -  ~attr_writer~ : インスタンス変数の書き込み専用アクセサを定義する。
 -  ~define_method~ : メソッドを定義する。
 -  ~include~ : モジュールをインクルードする。
 -  ~module_function~ : モジュールのメソッドをモジュール関数にする。
 -  ~private~ : メソッドを~private~にする。
 -  ~protected~ : メソッドを~protected~にする。
 -  ~public~ : メソッドを~public~にする。
 -  ~remove_const~ : 定数の削除。
 -  ~remove_method~ : メソッドの削除。
 -  ~undef_method~ : メソッドを未定義にする。

**** Rubyから呼び出されるメソッド

 -  ~append_features~ : インクルードされる前に呼ばれる。
 -  ~const_missing~ : 存在しない定数を参照したときに呼ばれる。
 -  ~included~ : インクルードされたあとで呼ばれる。
 -  ~extended~ : オブジェクトに取り込まれたあとで呼ばれる。
 -  ~extend_object~ : オブジェクトに取り込まれる前に呼ばれる。
 -  ~method_added~ : メソッドを定義したときに呼ばれる。
 -  ~method_removed~ : メソッドを削除したときに呼ばれる。
 -  ~method_undefined~ : メソッドを未定義にしたときに呼ばれる。


** Class

 ~Class~クラスは、クラスを表すクラスで、~Module~クラスのサブクラスです。

 クラスに関する機能のほとんどは、~Module~クラスに実装されていますので、~Module~クラスのほうを先に調べるといいでしょう。~Class~クラスの機能は、「~Module~の機能＋インスタンスの作成とクラスの継承」です。

*** 親クラスとモジュール

 ~Class~クラスの親クラスは~Module~クラスです。

 #+BEGIN_EXAMPLE
    Class < Module < Object < Kernel (< BasicObject)
 #+END_EXAMPLE

*** メソッド一覧

**** クラスメソッド

 -  ~new~ : クラス定義を使わずにクラスを作成。 

    Class.new で無名クラスを作る
**** インスタンスメソッド

 -  ~allocate~ : インスタンスの作成。
 -  ~new~ : インスタンスの作成と初期化。
 -  ~superclass~ : 親クラスを返す。

**** Rubyから呼び出されるメソッド

 -  ~inherited~ : クラスが継承されたときに呼ばれる。

 次のメソッドは~Module~クラスで定義されていますが、~Class~クラスでは未定義にされています：\\
  ~append_features~、~extend_object~

 [[/ruby/about][このサイトについて]] [[/ruby/legend][記事の読み方]]
 [[/ruby/references][参考文献]]

 Sponsored by [[http://www.oiax.jp/][Oiax Inc.]] / Powered by Ruby on
 Rails and AmiWiki


