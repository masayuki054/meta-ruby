** 2016.01.25 オブジェクトモデル

*** class定義
    
#+BEGIN_SRC ruby :exports both  :session session :results output
what_is_self_in_class_def =
 class MyClass
   CONSTANT = 'MyClassの定数'
   self
 end
p what_is_self_in_class_def
'end'
  
#+END_SRC

#+RESULTS:
: 
: irb(main):002:0* irb(main):003:1> irb(main):004:1> irb(main):005:1> => MyClass
: MyClass
: => MyClass

=class MyClass= は, 
- =Class=型のオブジェクトを生成し，
- 定数 =MyClass= にその値をセットし，
- self を =MyClass= オブジェクトにし，
- self のトップレベルで，
- =end= までの ruby 式を評価し，
- 最後の式の値を返す。

#+BEGIN_SRC ruby :exports both  :session session :results output
class MyClass
  p CONSTANT
  KONSTANT = 'MyClassの別の定数'
end
p CONSTANT
p MyClass::CONSTANT
p MyClass::KONSTANT
MyClass.constants

'end'
#+END_SRC

#+RESULTS:
#+begin_example

irb(main):012:1> irb(main):013:1> "MyClassの定数"
=> "MyClassの別の定数"
NameError: uninitialized constant CONSTANT
	from (irb):14
	from /home/staff/suzuki/.rbenv/versions/2.0.0-dev/bin/irb:11:in `<main>'
"MyClassの定数"
=> "MyClassの定数"
"MyClassの別の定数"
=> "MyClassの別の定数"
=> [:CONSTANT, :KONSTANT]
#+end_example

- =class MyClass= で，=MyClass= (クラス)オブジェクトのトップレベルに入
  る
- ruby のクラスは変更に対し，開かれている (オープン・クラス)
- ▼定数=CONSTANT= はMyClass の名前空間に定義されている


*** object のクラス階層
#+BEGIN_SRC ruby :exports both  :session session :results output

obj= MyClass.new
obj.class
(obj.class).ancestors
'end'
#+END_SRC

#+RESULTS:
: 
: => #<MyClass:0x007fd4425309d0>
: => MyClass
: => [MyClass, Object, Kernel, BasicObject]

objの型

*** クラスのクラス階層
#+BEGIN_SRC ruby :exports both  :session session :results output

MyClass.class
(MyClass.class).ancestors
'end'
#+END_SRC

#+RESULTS:
: 
: => Class
: => [Class, Module, Object, Kernel, BasicObject]

MyClassのオブジェクトとしての型階層

*** メタクラスのクラス階層
#+BEGIN_SRC ruby :exports both  :session session :results output

MyClass.singleton_class
(MyClass.singleton_class).ancestors
'end'
#+END_SRC

#+RESULTS:
: 
: => #<Class:MyClass>
: => [#<Class:MyClass>, #<Class:Object>, #<Class:BasicObject>, Class, Module, Object, Kernel, BasicObject]

MyClassのオブジェクトとしての型階層
*** 特異クラスと特異メソッド
**** 特異メソッド
あるオブジェクトにだけ実行できるメソッドを定義できる:
#+BEGIN_SRC ruby :exports both  :session session :results output
obj1 = Object.new
obj2 = Object.new
def obj1.m
  "obj's singleton method"
end

obj1.m
obj2.m

obj1.methods.include?(:m)
obj2.methods.include?(:m)

'end'

#+END_SRC

#+RESULTS:
#+begin_example

=> #<Object:0x007f5711dd60e8>
=> #<Object:0x007f5711daf420>
irb(main):004:1> irb(main):005:1> => :m
irb(main):007:0* => "obj's singleton method"
NoMethodError: undefined method `m' for #<Object:0x007f5711daf420>
	from (irb):8
	from /home/staff/suzuki/.rbenv/versions/2.0.0-dev/bin/irb:11:in `<main>'
irb(main):010:0* => true
=> false
#+end_example

**** =m= は何処にあるか？

- obj1とobj2 の =class= は，Object. 
- =class= はリンク。
- obj1 から Object へのリンクの途中に在る

#+BEGIN_SRC ruby :exports both  :session session :results output
obj1.class
obj1.singleton_class
(obj1.singleton_class).class
(obj1.singleton_class).instance_methods(false)
'end'
#+END_SRC

#+RESULTS:
: => Object
: => #<Class:#<Object:0x007f5711dd60e8>>
: => Class
: => [:m]


=m= の居場所は，#<Class:#<Object:0x007f5711dd60e8>> 特異クラス

#+BEGIN_SRC ruby :exports both  :session session :results output



'end'
#+END_SRC


#+BEGIN_SRC ruby :exports both  :session session :results output
MyClass.ancestors.each do |k|
  if k.singleton_class
    print k, ": ", (k.singleton_class).instace_methods, "\n"

'end'
#+END_SRC



*** test class hier
#+BEGIN_SRC ruby :session session :results output
def find_instance_method(klass, method)
  prev = nil
  klass.ancestors.each do |k|
    break unless  k.instance_methods.include?(method)
    prev = k
  end
  return prev
end

def find_singleton_method(klass, method)
  prev = nil
  klass.ancestors.each do |k|
    break unless  k.instance_methods.include?(method)
    prev = k
  end
  return prev
end


find_instance_method(MyClass,:constants)
find_singleton_method(MyClass,:constants)
find_instance_method(Kernel,:constants)
find_singleton_method(Kernel,:constants)
find_instance_method(Module,:constants)
find_singleton_method(Module,:constants)
'end'
#+END_SRC

#+RESULTS:
: => [MyClass, Object, Kernel, BasicObject]
: irb(main):220:0* irb(main):221:1> irb(main):222:1> irb(main):223:2* irb(main):224:2> irb(main):225:2> irb(main):226:1> irb(main):227:1> => :find_instance_method
: irb(main):229:0* irb(main):230:1> irb(main):231:1> irb(main):232:2* irb(main):233:2> irb(main):234:2> irb(main):235:1> irb(main):236:1> => :find_singleton_method
: irb(main):238:0* irb(main):239:0* => nil
: => nil
: => nil
: => nil
: => Module
: => Module


** 2016.02.01 method

*** method_missing
    - メソッド が class 階層中にない時，
    - missing_method が呼ばれる
    - class 階層中に missing_method がない時，
    - エラーになる

*** 動的methodの仕組み
    - 動的定義 define_method (:method_id) block
    - 動的呼び出し send("method", *args)

*** method_missing(method, *args)の利用
    - 動的に未定義のメソッドと引数が取得できる
    - 他のメソッドへ委譲したり (動的proxy)
    - メソッドを on-demand で定義できたり (ghost method)
      [[file:~/COMM/Lects/meta-ruby/site/org-docs/meta-ruby/methods.org::*openstruct][openstruct]]

*** 最終形

    様々なComputer の様々な付属品を扱う多種のデータベースへのアクセス
    を簡単にする：

    - [[file:~/COMM/Lects/meta-ruby/code/methods/computer/more_dynamic.rb][more_dynamic.rb]]

    - [[file:~/COMM/Lects/meta-ruby/code/methods/computer/final.rb][final.rb]]


** 2016.02.09 ブロック

   この章で理解すべきこと
   - スコープ
   - クロージャ
   - クロージャによるスコープの操作
   - 呼び出し可能オブジェクトへの変換

*** ブロックの基本

**** ブロックの作成
- do ... end が block 
- メソッド呼び出しの時のみ

**** ブロックが与えられているか？
- block_given? で調べられる
   
**** ブロックの呼び出し
- 呼ばれたメソッド側で yield により呼び出せる
- しかし，block は，block が作られた*環境*で実行される

*** クロージャ

**** コードの実行

- ブロックはコード

- *self* が実行の主体 (場)

  - self は *環境* を持つ

    環境は，スコープ上の変数とその値のペア(*束縛*)の集まり
    
    - 局所変数 (一方向) のスコープ
      - block の入れ子構造 (nesting) のスコープ

    - インスタンス変数 (一通り) のスコープ

    - クラス変数 (一通り) のスコープ
      - class の継承方向のスコープ

    - 定数 (2方向)のスコープ
      - module の入れ子構造 (nesting) のスコープ
      - class の継承方向のスコープ

    
- クロージャ = block + self (環境)


- ブロックが生まれるとき，自身が生まれた環境を閉じ込めた ((*クロージャ*))
  となる

- クロージャが実行される時は，その環境で実行される
  - 定数はselfのクラスから辿れる
  - インスタンス変数、特異メソッドには self から辿れる

**** スコープのまとめ

- Rubyのスコープには束縛がある
- スコープは class, module, def のスコープゲートで区切られ。
- スコープゲートは，Class.new(), Module.new(), Moduel#define_method()
  で置き換え，それらに束縛を閉じこめたクロージャを与える。
- クロージャにより，束縛の共有も可能となる

(*s*) この辺りは，SICP の lambda による実現の方が，シンプルでわかりや
すい。

*** instance_eval()

- obj.instance_eval block ::
  - オブジェクトobjのコンテキストで, 
  - ブロックblockを評価する

- obj を self にして, クロージャを実行するということ

**** カプセル化の破壊

instance_eval を使うとカプセル化が破壊できる

*** 呼び出し可能オブジェクト

ブロックの使用
- コードの保管
- yieldを使ったブロックの呼び出し
  
コードを保管できる状況
- (({Proc})) の中．ブロックがオブジェクトになる
- (({lambda})) の中．
- メソッドの中

***** Proc 対 lambda

ブロックを Proc にする方法
- Proc.new()
- lambda { }　
- &修飾

****** Proc, lambda, return

Proc のリターンは，Proc の定義された環境から return 
(直前の環境へ戻る)

****** Proc, lambda, arity

引数の確認方法の違い

- lambda は厳格 (メソッドに準拠)
- Proc は柔軟

****** Proc対lambda: 判定

lambda がメソッドに似ている [/]
1. [ ] 項数に厳しく
2. [ ] return で自身を終える

Proc はコンテキスト中のコードの一部，
lambda は独立したコード

***** メソッド再び

- Object#method() でメソッドを，Method オブジェクトとして取得可
- Method オブジェクトは，Method#call() で呼び出し可能
- Method オブジェクトは，属するオブジェクトのスコープで実行される
- Method#unbind() は属するオブジェクトを引き離し，UnboundMethod
  オブジェクトが返る
- UnboundMethodはMethod#bind()でメソッドに戻せる
  クラスが異なると，例外が発生

***** 呼び出し可能オブジェクトのまとめ

呼び出し可能オブジェクト [/]
1. [ ] ブロック
   - オブジェクトではないが，呼び出し可能
   - 定義されたスコープで評価される

2. [ ] Proc
   - 定義されたスコープで評価される
   - 定義されたコンテキストの制御にしたがう

3. [ ] lambda
   - Proc クラスのオブジェクト，クロージャ
   - 定義されたスコープで評価される
   - 独立した method のように振る舞う

4. [ ] メソッド
   - オブジェクトにつながれ，
   - オブジェクトのスコープで評価される




* memo コード

** class 階層

#+BEGIN_SRC ruby :session ruby :results output
1.class
(1.class).superclass
(1.class).superclass.superclass
(1.class).superclass.superclass.superclass
(1.class).superclass.superclass.superclass.superclass
(1.class).superclass.superclass.superclass.superclass.superclass
'end'
#+END_SRC

#+RESULTS:
: => Fixnum
: => Integer
: => Numeric
: => Object
: => BasicObject
: => nil


#+BEGIN_SRC ruby :session session :results output
1.methods
(Object.new).methods
(BasicObject.new).methods
'end'
#+END_SRC

#+RESULTS:
: => [:%, :&, :*, :+, :-, :/, :<, :>, :^, :|, :~, :-@, :**, :<=>, :<<, :>>, :<=, :>=, :==, :===, :[], :inspect, :size, :succ, :to_s, :to_f, :div, :fdiv, :divmod, :modulo, :abs, :magnitude, :zero?, :odd?, :even?, :bit_length, :to_int, :to_i, :next, :upto, :chr, :ord, :integer?, :floor, :ceil, :round, :truncate, :downto, :times, :pred, :to_r, :numerator, :denominator, :rationalize, :gcd, :lcm, :gcdlcm, :+@, :eql?, :singleton_method_added, :coerce, :i, :remainder, :real?, :nonzero?, :step, :positive?, :negative?, :quo, :arg, :rectangular, :rect, :polar, :real, :imaginary, :imag, :abs2, :angle, :phase, :conjugate, :conj, :to_c, :between?, :instance_variable_get, :public_send, :instance_variable_defined?, :private_methods, :public_methods, :instance_variables, :is_a?, :instance_variable_set, :remove_instance_variable, :instance_of?, :kind_of?, :tap, :extend, :define_singleton_method, :singleton_method, :to_enum, :enum_for, :=~, :!~, :respond_to?, :freeze, :display, :object_id, :send, :method, :public_method, :nil?, :hash, :class, :singleton_class, :clone, :dup, :itself, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :methods, :singleton_methods, :protected_methods, :frozen?, :!, :!=, :__send__, :equal?, :instance_eval, :instance_exec, :__id__]
: => [:instance_variable_get, :public_send, :instance_variable_defined?, :private_methods, :public_methods, :instance_variables, :is_a?, :instance_variable_set, :remove_instance_variable, :instance_of?, :kind_of?, :tap, :extend, :define_singleton_method, :singleton_method, :to_enum, :enum_for, :<=>, :===, :=~, :!~, :eql?, :respond_to?, :freeze, :inspect, :display, :object_id, :send, :to_s, :method, :public_method, :nil?, :hash, :class, :singleton_class, :clone, :dup, :itself, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :methods, :singleton_methods, :protected_methods, :frozen?, :!, :==, :!=, :__send__, :equal?, :instance_eval, :instance_exec, :__id__]
: NoMethodError: undefined method `methods' for #<BasicObject:0x007fb2e21e4a00>
: 	from (irb):3
: 	from /home/staff/suzuki/.rbenv/versions/2.0.0-dev/bin/irb:11:in `<main>'

- method メソッドはBasicObjectのインスタンス・メソッドではない
- method メソッドはObjectのインスタンス・メソッド

#+BEGIN_SRC ruby :session session :results output
(1.class).ancestors
(Object.instance_methods).include?(:methods)
(Kernel.instance_methods).include?(:methods)
(BasicObject.instance_methods).include?(:methods)
'end'
#+END_SRC

#+RESULTS:
: => [Fixnum, Integer, Numeric, Comparable, Object, Kernel, BasicObject]
: => true
: => true
: => false


#+BEGIN_SRC ruby :session ruby :results output
(1.class)
((1.class).class)
((1.class).class).superclass
((1.class).class).superclass.superclass
((1.class).class).superclass.superclass.superclass
((1.class).class).superclass.superclass.superclass.superclass
:end
#+END_SRC

#+BEGIN_SRC ruby :session ruby :results output
Class
(Class.class)
(Class.class).superclass
(Class.class).superclass.superclass
(Class.class).superclass.superclass.superclass
(Class.class).superclass.superclass.superclass.superclass
:end
#+END_SRC

#+RESULTS:
Class
Class
Module
Object
BasicObject
nil

#+BEGIN_SRC ruby :session ruby :results output
Module
(Module.class)
(Module.class).superclass
(Module.class).superclass.superclass
(Module.class).superclass.superclass.superclass
(Module.class).superclass.superclass.superclass.superclass
:end
#+END_SRC

#+RESULTS:
: Module
: Class
: Module
: Object
: BasicObject
: nil

#+BEGIN_SRC ruby :session ruby :results output
def class_hier(obj)
  if obj.superclass
    print " => ", obj.superclass
    class_hier(obj.superclass)
  end
end
#+END_SRC

#+RESULTS:

#+BEGIN_SRC ruby  :session ruby :results output
class_hier(Class)
class_hier(Integer)

'end'
#+END_SRC

#+RESULTS:
: => Module => Object => BasicObjectnil
: => Numeric => Object => BasicObjectnil

#+BEGIN_SRC ruby :session ruby :results output
Class.singleton_class
(Class.singleton_class).superclass
(Class.singleton_class).superclass.superclass
(Class.singleton_class).superclass.superclass.superclass
(Class.singleton_class).superclass.superclass.superclass.superclass
:end
#+END_SRC

#+RESULTS:
: => #<Class:Class>
: => #<Class:Module>
: => #<Class:Object>
: => #<Class:BasicObject>
: => Class

#+BEGIN_SRC ruby :session ruby :results output
(Class.singleton_class).singleton_class
(Class.singleton_class).singleton_class.singleton_class
:end
#+END_SRC

#+RESULTS:
: => #<Class:#<Class:Class>>
: => #<Class:#<Class:#<Class:Class>>>

#+BEGIN_SRC ruby :session ruby :results output
(Class.singleton_class).singleton_class
(Class.singleton_class).singleton_class.superclass
(Class.singleton_class).singleton_class.superclass.superclass
(Class.singleton_class).singleton_class.superclass.superclass.superclass
:end
#+END_SRC

#+RESULTS:
: => #<Class:#<Class:Class>>
: => #<Class:#<Class:Module>>
: => #<Class:#<Class:Object>>
: => #<Class:#<Class:BasicObject>>


#+BEGIN_SRC ruby :session ruby :results output
Class.ancestors
Module.ancestors
(Class.new).ancestors
(Module.new).ancestors
'end'
#+END_SRC

#+RESULTS:
: [Class, Module, Object, Kernel, BasicObject]
: [Module, Object, Kernel, BasicObject]
: [#<Class:0x007f91320a46a8>, Object, Kernel, BasicObject]
: [#<Module:0x007f9131841268>]

#+BEGIN_SRC ruby :session ruby :resutls output
Class.singleton_class
(Class.singleton_class).ancestors
'end'

#+END_SRC

#+RESULTS:
: end

** self 

#+BEGIN_SRC ruby :results output
self
self.class

class H
  $selfH = self
  def m
    $selfm = self
    puts "m is called."
    'm'
  end
end
print "$selfH = ", $selfH
h = H.new
h.m
print "$selfm = ", $selfm
:end
#+END_SRC

#+RESULTS:
: $selfH = Hm is called.
: $selfm = #<H:0x007fc1890877b0>

** methods

#+BEGIN_SRC ruby :session ruby :results output
1.methods - (Numeric.new).methods
Integer(1001)
String("abc")
Array(2)
Array(1..100)
Kernel.Array(2)
self.Array(2)


'end'
#+END_SRC

#+RESULTS:
#+begin_example
1.methods - (Numeric.new).methods

Integer(1001)

String("abc")

Array(2)

Array(1..100)

Kernel.Array(2)

self.Array(2)





'end'

:org_babel_ruby_eoe


#+end_example

#+BEGIN_SRC ruby :session ruby :results output
Kernel.methods.include?(:Array)
Kernel.methods.include?(:Integer)
'end'
#+END_SRC

#+RESULTS:
: true
: true

