* Duck Typingが生まれるまで 第4回（1）
  まつもと直伝 プログラミングのオキテ 

型について学びます。型には静的型と動的型の2種類があります。それぞれの歴
史的な背景から始め、利点、欠点について学びます。動的型の新しいプログラ
ミング・スタイルである *Duck Typing*も紹介します。

** 静的・動的 型

- 静的とは :: 「プログラムを実行しなくても、ソース・コードを見るだけで
              分かること」という意味です。プログラムの静的な部分とは、
              変数や手続きの名前と型、制御構造の構成などです。

- 動的とは :: 「プログラムを動かしてみないと分からないこと」という意味
              になります。プログラムの動的な部分とは変数などの具体的な
              値、実行時間、使用メモリー量などでしょう。


** なぜ型が必要なのか

プログラミング言語における「型」とは、データの種別を表します。例えば
「整数」や「文字列」は型になります。ハードウエアのレベルで考えると、コ
ンピュータは唯一の型、すなわち2進数だけを取り扱います。CPUを直接操作で
きるアセンブリ言語では、データの型は整数値だけであって、そのほかのデー
タはこの整数値の解釈によって表現されます。

- 「静的な型」:: 変数に格納されるデータの種別（型）を指定

  プログラムを実行しなくても人間の間違いを機械的に発見できる偉大な発明


** 動的な型はLispから生まれた

「データそのものに自身の種別についての情報を記録する」という戦略を採る
ことになりました。データ自身がデータ種別について「知っている」、このよ
うなデータ型を「動的な型」と呼びます。

* Duck Typingが生まれるまで 第4回（2）

** オブジェクト指向で開花した動的型

** 動的型と静的型の巡り合い

「継承されたクラス（サブクラス）のオブジェクトを継承元のクラス（スーパー
クラス）のオブジェクトと見なすことを許す」というものです。

具体的には、例えばString（文字列）というクラスがObject（オブジェクト）
というクラスのサブクラスだったとすれば、Stringクラスに所属するオブジェ
クトはObjectクラスのオブジェクトと見なしても差し支えない、という意味で
す（図5[拡大表示]）。

このルールにより、変数や式の型がコンパイル時に分かるという静的型の利点
と、実行時の型によって適切な処理へ進むポリモーフィズムが両立できるよう
になったのです。

変数や式の型がコンパイル時に分かるため、型の不整合によるエラーを実行前
に発見できます。これは大きなメリットです。さらに、型情報を使ってコンパ
イル時に大胆な最適化を行い、プログラムを高速化する余地も生まれました。

このような良い性質を帯びているためか、C++や1990年代になってC++の影響を
受けて生まれたJavaやC#などの静的型を持つオブジェクト指向言語が広く使わ
れるようになったのです。

** 静的型のメリット

静的型の最大のメリットは、やはり型の不整合によってコンパイル時にバグが
発見できることでしょう。もちろん、すべてのプログラム中の間違い（バグ）
をコンパイル時に発見するのは不可能ですが、バグは型の不整合を伴うことが
多いため、エラーを機械的に発見してくれる機能は、たとえ完全でなくても、
とてもありがたいことです。

一方、動的型の言語ではコンパイル時にせいぜい文法エラーしか見つけること
はできません。

プログラム中で型が明示的に指定されているということは、コンパイル時に利
用できる情報が多いということです。この情報を利用してコンパイラはプログ
ラムをより高速に実行できるよう工夫できます。

型情報についてはコンパイラにとどまりません。人間がプログラムを読むとき
にも、「この引数の型は何か」という情報がプログラム読解の大きなヒントに
なります。統合開発環境（IDE）には、この情報を利用してメソッド名などの自
動補完ができるものもあるようです。これも利用できる型情報があるために実
現できています。

最後に、変数や式それぞれが型を持つということは、変数などがどのような役
割を持つのかあらかじめきちんと考えることにつながります。プログラム記述
時に考えなければならないことは増えますが、単純に悪いこととは言えません。
むしろ、良いプログラム、信頼性の高いプログラムを書くためには必要なこと
であるとも捉えられます。

こうして見ると、静的型には良いところばかりのように思えますね。しかし、
欠点あるいは課題と呼ぶべき点もいくつかあります。

その一つが、型を指定しないとプログラムを書けないことです。もちろん、型
の指定は静的型の特徴の一つです。しかし、型はあくまでも補助的な情報でプ
ログラムの本質ではありません。本筋に集中したいときにいちいち型を指定す
るのは煩雑ですし、一部の型宣言はただ単にコンパイラを満足させるためでは、
という気持ちになることもあります。結果的にソース・コードの分量が多くな
り、本当に大事な部分が埋没してしまう可能性も否定できません。

もう一つは柔軟性の問題です。静的型があること自体、「この変数にはこの型
のオブジェクトが入る」という制限を課したことになります。このような制限
が将来の変化の足かせとなる可能性があります。前回学んだ多重継承やインタ
フェースを使うと、入り組んだ継承関係が生まれます。このとき指定すべき型
を適切に選択するのはそれなりに難しい課題でしょう。

まとめると、静的型はプログラムを書く人間が型宣言という形で積極的に情報
を与えることによって、コンパイラや将来そのプログラムを読む人間が楽をし
ようというアプローチであると言えます。

* Duck Typingが生まれるまで 第4回（3）
  
** 動的型のメリット

では、もう一方の動的型についてはどうでしょう。動的型を採用したプログラ
ミング言語の最大の利点は、ソース・コードが簡潔になることです。プログラ
ミング言語はより簡潔により多くのことをコンピュータに伝えるために進化し
てきました。きちんと動き、エラーも検出できるのであれば、プログラムの動
きの本質とは関係のない型指定などない方が良い、というのも一つの考え方で
す。

プログラムが簡潔に記述できれば、プログラムを書くときに、型のような処理
の本質に関係ない部分のことを考えなくても済みます。本質に集中した簡潔な
記述ができれば、生産性も向上することでしょう。

一方、いくら簡潔に記述できてプログラムが書きやすくなっても、型情報がな
ければ、プログラムを読解しにくくなるのではないか、という懸念もあります。
書きやすくても読みにくければ仕方がありません。これに対しては、処理の本
質に集中した簡潔なプログラムは、書きやすいだけでなく読みやすい傾向があ
ると答えられます。実際、動的型の言語（例えばRuby）のプログラムと、静的
型の言語（例えばJava）のプログラムを比べると、コード量で数倍の差がある
ことも珍しくありません。多くの人は動的型の言語の方が読みやすいことが多
い、と感じているようです。

簡潔な記述に対しては、プログラムの実行が遅くなるのではないかという懸念
もあります。実際、同様の処理を進めるプログラムを静的型の言語と動的型の
言語で実行すると、多くの場合、静的型の言語が勝ちます。

これに対しては、動的型に付き物の実行時の型チェックのコストも影響してい
るでしょう。さらに、静的型の言語はソース・コードを直接実行できる形式に
変換するコンパイル型処理系が多いのに対して、動的型の言語はソース・コー
ドを解釈しながら（一度内部表現に変換してから）実行するインタプリタ型処
理系が多いことも一因です。プログラムといっても、一般には実行性能が重要
でない局面も多く、コンピュータの性能向上により、そのような領域は増大し
ているとも言えます。

動的型のもう一つのメリットは、柔軟性です。動的型の言語で書かれたプログ
ラムでは変数などの型が宣言されていませんから、プログラム開発時に想定し
ていなかったデータを取り扱うことが容易です。この柔軟性のカギになる概念
が以下で解説するDuck Typingです。

動的型の最大のデメリットは、実際に実行してみないとエラーを発見できない
ことでしょう。静的型の言語がプログラム全体を機械的にチェックできるのに
比べると物足りなく感じます。

** 見かけにこだわるDuck Typing

動的型の柔軟性を表現する概念がDuck Typingです。これは西洋の格言に由来し
ます。

If it walks like a duck and quacks like a duck, it must be a duck.（ア
ヒルのように歩き、アヒルのように鳴くものはアヒルに違いない）

ここから、「アヒルのように振る舞うものは、その実体がなんであってもアヒ
ルと見なす」というルールを引き出すことができます。あるオブジェクトがど
のクラスに所属するオブジェクトかは一切考慮せず、どのように振る舞うか
（どのようなメソッドを持つか）だけに関心を払うのがDuck Typingです。
Duck Typingを言い出したのは「達人プログラマ」として知られるDave Thomas
です。

Duck Typingの具体例を見てみましょう。ファイルにログ・メッセージを出力す
るlog_puts（）という手続きがあるとしましょう。このメソッドは2つの引数
（出力先、メッセージ）を取るとします。静的型の言語（例えばC++）であれば
次のようなコードになるでしょう。

: void log_puts（ostream out, char* msg）;

log_puts（）手続きは、出力先outに時刻とメッセージを出力します。次のよう
に呼び出す例を取り上げます。

: log_puts（cout, "message"）;

例えば、以下のようなログをcout（C++の標準出力）に書き込むことになるでしょ
う。

: 2005-06-16 16:23:53 message

さて、ここでログの出力先をファイルではなく、文字列にしたくなったらどう
しましょうか。

出力先を指定する引数outはostreamであると決まっているので、簡単には変更
できません。結局、log_puts（）手続き全体をコピーして文字列を出力対象に
する別の手続きを用意するか、一時ファイルに出力しておいて、文字列に読み
込み直すかしかありません。

では、Duck Typingを使うとどのように柔軟なコードになるのでしょうか。
Duck Typingを使うと、次のようになります。

: log_puts（out, msg）

動的型ですからプログラム上で型は指定していません。C++の例と同様に以下の
ような呼び出しはSTDOUT（Rubyにおける標準出力）に同じようなログを書き込
みます。

: log_puts（STDOUT, "message"）

さて、先ほどと同じように文字列に対して出力したくなったとしましょう。
Duck Typingでは話がずっと簡単になります。「出力先（標準出力）と同じよう
に振る舞うものであれば、それを出力先に使ってもよい」のです。

Rubyには文字列に対してファイルと同じように入出力を行うStringIOというク
ラスが用意されています。StringIOを使って入出力を記述した例を図6[拡大表
示]に示します。

StringIOクラスとSTDOUTのクラス（IO）の間には継承関係がありません。しか
し、StringIOクラスはIOクラスの持つすべてのメソッドを備えています。です
から、StringIOクラスはほとんどの局面でIOと同じように使うことができます。

静的型の言語で同じことをしようと思えば、logを出力するのに必要な「振る舞
い」を用意したクラス（Javaの場合、インタフェース）を用意してlog_puts（）
の最初の引数の型に指定する必要があります。今回の例のように、この型が組
み込みの型であったら、「出力先」を表現する別のオブジェクトを新たに作る
必要があるでしょう。このような仕組みを最初から用意するのは大変ですし、
途中から導入するとなれば、プログラムのあちこちに大規模な改修が必要にな
るでしょう。

静的型は、プログラム開発者が型宣言としてたくさんの情報を提供するために、
エラーの検出が早く、確実に実行できます。そのかわり、型を設計した時点の
前提が変化すると、指定したたくさんの情報（型）を一貫性を保ちながらすべ
て更新しなければなりません。動的型は、最初からそのような指定を行ってい
ませんから、変化に強い傾向があります。

では、動的型の言語でDuck Typingを実践するにはどのような指針に従えばよい
のでしょうか。基本的な原則はたった1つ、最低限これだけを覚えておけば大丈
夫です。

●明示的な型チェックを避ける

プログラム中で、引数の型をチェックしたくなる場合もあります。例えば、図
7[拡大表示]のように、文字列を期待している部分があったとすると、Stringク
ラスのオブジェクトでなければ例外を発生させてエラーにしたい、という気持
ちが自然に生まれてきます。

しかし、Duck Typingを実践するときには、ここでぐっと我慢する必要がありま
す。クラスを基準としたチェックを行えば、静的型と同様に柔軟性を失ってし
まうからです。どうしてもチェックしたい場合でも、「あるクラスのオブジェ
クトか」ではなく「あるメソッドを持っているか」という条件でチェックして
ください（図8[拡大表示]）。

しかしながら、そもそもチェックを行わなくても、期待と違うオブジェクトな
らば「メソッドが見付からない」というエラーが発生するはずです。

** 動的型のデメリットを克服

動的型のデメリットとは大きくまとめると「エラー発見が実行時」、「読解す
るときのヒントが少ない」、「遅い」の3つになります。

最初の「エラー発見が実行時」という点は単体テストをきちんとこなすことで
克服できます。きちんとテストを進める習慣が定着していれば、コンパイル時
の型チェックがなくても信頼性が下がることはありません。

「プログラムの読解のためのヒントが少ない」点はドキュメントの整備が解決
になるでしょう。JavaにはJavaDoc、RubyにはRDocというソース・コード中にド
キュメントを同時に記述することでドキュメント維持の負担を減らす技術が存
在します。

最後に、「実行速度が遅い」点ですが、コンピュータの性能がこれだけ向上し
ている昨今、ほとんどのケースで実行効率よりも柔軟性や生産性の方が重要で
す。

** 動的プログラミング言語

現代では、プログラム開発に期待される生産性はますます高くなっています。
つまり、今までよりも多くの機能を、今までよりも短い時間で開発することを
求められます。

そのような短期間の開発に対応するため、プログラムを開発しながら、最適な
解を模索するような手法が広まりつつあります。これを「shooting a moving
target」と呼ぶことがあります。これまでのように、最初にあらゆる状況を考
慮して、仕様を決定してから開発に取り掛かるというやり方では対応しきれな
くなってきています。手早く開発できること、変化に素早く対応できることが
なによりも求められます。

このような「俊敏さ」を求められる開発では、Duck Typingに代表されるような
実行時の柔軟性が非常に役立ちます。Ruby、Python、Perl、PHPなど動的型を持
ち、実行時の柔軟性に優れた動的プログラミング言語が注目されているのはこ
のような理由があるのです。

