* 第2回 抽象データと継承

オブジェクト指向プログラミングを構成する3原則
- *ポリモーフィズム* 
- *データ抽象* と *継承*

ポリモーフィズムを *動的結合*, 
*データ抽象* を *情報隠ぺい*, *カプセル化* ともいう.

** Javaの誕生

Cとの互換性を強調したC++には、低レベルなことも記述できるというメリット
と、低レベルなことも記述しなければならないというデメリットが共存してい
ました。

その点を改善するべく1990年代になって登場したのがJavaです。JavaはC++から
Cへの互換性（とそれに伴う制約）を取り除き、その代わりにLispなどからより
良い機能をいくつか取り込んで誕生しました。

また、JVM（Java Virtual Machine）という仮想マシンを経由することで、1つ
のプログラムが再コンパイルなく、あらゆるプラットフォームで動作するとう
たわれていました。

今やJavaは1990年代に誕生した言語の中では最も成功した言語として世界中で
広く用いられています。


** オブジェクト指向分析・設計技法

UML（Unified Modeling Language）はオブジェクト指向アプローチで設計され
るソフトウエアのモデルを記述するための記法であり、またそれを用いた分析・
設計の方法論でもあります。

UMLは信頼性の高いソフトウエアをオブジェクト指向を用いて設計する際に有益
な方法ではありますが、UML全体はそれなりに複雑で周辺の概念の数も多く、初
心者には難しいという印象を与えてしまいました。


● その2

** 複雑さという敵

ソフトウエア開発の最大の敵は複雑さです。

ソフトウエアへの要求は増し、開発されるソフトウエアはどんどん複雑になっ
てきています。

年々性能が向上するコンピュータの処理能力の限界よりも、人間の理解力の限
界によるソフトウエア生産性の限界の方が、より厳しい制約になってきていま
す。これだけコンピュータが高速になった現在、多少性能が劣っても、より複
雑で、より大規模なソフトウエアをより速く開発できることが期待されている
のです。

** 構造化プログラミングの意味

プログラムの制御の流れ、つまり実行順序を「順接」、「分岐」、「反復」の
3種類だけに制限し、かつ共通する処理をサブルーチンとしてくくり出すことを
基本とした考え方です（図1[拡大表示]）。

構造化プログラミングが取った「制約」と「抽象化」こそ、ソフトウエアの複
雑さを人間が取り扱える範囲内に抑えるために非常に有効な手法なのです。

自由度と複雑性は減っても記述力は減っていないことになります。

抽象化の目的はいくつかのまとまりに名前を付けることで、内部の詳細を気に
せずに取り扱うことです。「ブラックボックス化」とも言います。ブラックボッ
クスでは入力と出力だけが決まっていて内部の処理を隠しています＊2。

ブラックボックスの内部を含めて考えるとシステム全体の複雑さは変化してい
ません。しかし、内部を考えなければ、システムの複雑さを人間の取り扱える
範囲に抑えることができます。

さらに、内部が隠されているということは、入力と出力が同じであれば、内部
の処理の方法をどのように変更しても外部に影響がない、つまり、将来の変更
に対して強いことを意味します。ソフトウエアに変更はつきものですから、こ
のような変化に強い性質は大変望ましいことです。

** データも抽象化

オブジェクト指向プログラミングは、データによる複雑さへの対抗手段として
登場した

抽象データとは、データと手続きをまとめたものです。データの中身は所定の
手続きを通さないと見えません。データとその取り扱い方法をまとめてブラッ
クボックス化できるわけです。

このスタックの操作をRubyで記述

それに対して図4のプログラムでは実装の変更に伴い、必ずプログラムの修正が
必要になります。スタックを利用している場所すべてを変更しなければならな
いので、プログラムの規模が大きくなればなるほど変更が大変になります。こ
れではプログラムを改善するためであっても、スタックの実装を変更したくな
いと尻込みしてしまうでしょう。「変化に強い」というのは抽象データの大き
な利点です。

もう一つの利点は、処理のイメージがつかみやすいことです。例えばスタック
にデータをプッシュする操作は、図3では次のように表現しています。

stack.push(5)

　一方、図4では以下のように記述しています。

stack[sp] = 5
sp += 1

図3の方が「スタックにプッシュする」という操作が直接的に表現できています。
データを操作する側は、図4のような処理の詳細ではなく、むしろ「何をしよう
しているか」に興味があります。そのため、処理の詳細が隠される抽象データ
の方がコードが明確になり、目的にかなうのです。

イメージしやすいのは個別の操作だけではありません。抽象データは「特定の
操作に反応するインテリジェントなデータ」としてとらえることができます。
各種の刺激に応じて反応を示す現実世界の実体との関連付けが容易になるとい
うメリットがあります。

抽象データにより、プログラムがとりあつかうデータが単なる数値や文字列の
ようなあまり具体性のないものから、人間の頭脳がイメージしやすいより具体
的なものに変化します。コードの「抽象化」によりイメージが「具象化」して
いるわけです。このようなインテリジェントなデータを、現実世界の実体（も
の）との対応から、しばしば「オブジェクト」と呼び、オブジェクト指向プロ
グラミングの名前の由来となっています。


● その3

** ひな形

プログラム中にオブジェクトが登場する場合、同じ動作をするものが多いでしょ
う。交通シミュレーション・プログラムでは車を表すオブジェクトや信号を表
すオブジェクトが数多く登場します。同じ種別のオブジェクトはみな同じ性質
を持っていますが、位置や色などそれぞれ状態が異なります。

抽象化の原則から言えば、同じものが数多く登場する場合にはグループ化して
まとめてしまうべきです。このことをDRY（Don't Repeat Yourself）原則と呼
ぶこともあります。

既に見てきたように、プログラムの重複は諸悪の根源です。重複があるとプロ
グラムの修正が広範囲に及びますから、修正コストが高くなります。変更カ所
が複数に及び、そのうちのたった1つでも修正を忘れてしまうとプログラムは正
常に動作しません。重複はプログラムの信頼性を低下させる可能性が高いとい
えます。

さらに言えば、重複のあるプログラムは冗長ですから、人間が読む時にプログ
ラムの「意図」を解釈するコストも増大します。コードの重複が多い図4のプロ
グラムが、重複のない図3のプログラムよりも意図を理解しにくかったことを思
い出してください。コンピュータはプログラムが読みにくいかどうか、重複が
あるかどうかなど気にしません。しかし、人間の方はプログラム開発する間、
数え切れないほどプログラムを読み、解釈し、心の中で挙動を想像しています。
ですから、プログラムが人間にとって読みやすいかどうかは生産性に直結しま
す。重複が多く冗長で読みにくいプログラムはそれだけで生産性を低下させま
す。プログラミング中のにコピー・アンド・ペーストを繰り返すのは、重複部
分を増やすために推奨されない行為だと言えるでしょう。

話題をオブジェクトに戻しましょう。同じ種類のオブジェクトがたくさん存在
している場合、重複を避けるため同種のオブジェクトをまとめる方法は大きく
分けて2つあります。

一つはクローン型です。元になるオブジェクトのコピーを作ることで、同種の
オブジェクトを作り出します。実はオブジェクト指向プログラミング言語では
クローン型は少数派です。SelfやIoなどの言語が採用しています。少々意外な
ことにJavaScriptもクローン型です。今や最も有名なクローン型オブジェクト
指向言語かもしれません。　もう一つはひな形を用意する方法です。例えるな
らば、たい焼きの型とたい焼きの関係でしょうか。型があれば同じ形のたい焼
きをたくさん作ることができます。このひな形にあたるものをオブジェクト指
向プログラミングでは「クラス」と呼びます。同じ種別のオブジェクトはそれ
ぞれ同じクラスに属し、操作や性質を共有します。

クローン型と違って、クラス型オブジェクト指向言語はひな形となるクラスと
ひな形から作られたオブジェクトを明確に区別します。たい焼きの型はたい焼
きそのものではないことと同じです。クラスとオブジェクトの関係についてさ
らに例を挙げると、整数クラスと数字の「1」オブジェクト、犬クラスと特定の
「ポチ」オブジェクトなどがあるでしょう。クラスと対比し、違いを際立たせ
るためにオブジェクトのことをしばしばインスタンスと呼びます。呼び方が違
うだけでこれまで説明したオブジェクトと同じものを指します。

クラス型オブジェクト指向言語であるRubyでは＊5、クラスを定義する際に
「class文」を使います。図3で登場したStackも、実はStackクラスです。
Stackクラスの定義を図5に示しました。

classの後ろに書かれているのがクラス名です。図5[拡大表示]では、Stackです。
Rubyではクラス名の先頭の文字を大文字にするというルールがあります。
classから対応する（末尾の）endまでがクラスの定義になります。ここでは3つ
の手続き、initialize、push、popが定義されています。

initializeは図3の2行目で呼び出されます。

: stack = Stack.new

スタックが作られる度に呼ばれる初期化のための手続きです。

図5では、@stack（スタックの実体となる配列）と@sp（配列のインデックス）
という2つの変数を初期化しています。Rubyでは「@」で始まる変数はオブジェ
クトごとに独立した値を持つ変数で、インスタンス変数と呼ばれます。複数の
スタックを作った場合には、それぞれ別の@stackと@spを持つことになります。

pushとpopはスタック操作の手続きです。図4にあるスタック操作を手続きにま
とめただけのものです。

図5のinitializeのようにクラスに対して定義されたオブジェクト内部の操作手
続きを「メソッド」と呼びます。

なお、説明を単純化するため、図5の例では領域チェックなどは行っていません。
実際にはインデックスが負にならないかどうかなどのチェックが必要になるで
しょう。

** 似た部分をくくり出す継承

　ソフトウエアの規模が拡大し、中に含まれるクラスが多くなってくると似た
性質を持つクラスが複数登場します。既に見てきたように同じことを何度も繰
り返すのはDRY原則に違反します。無駄ですし、理解の妨げにもなります。変更
のコストが高くなり、生産性も下がります。ですから、似たような性質を持つ
クラスが複数あるなら、オブジェクトと同様にクラスについても似た部分をく
くりだする「仕掛け」があれば良いでしょう。

「継承」とは似た部分をくくり出す仕掛けです。具体的には、継承はあるクラ
スの性質を受け継いだ新しいクラスを作る機能です。元になったクラスのこと
をスーパークラス、新しく作られるクラスのことをサブクラスと呼びます。サ
ブクラスはスーパークラスのすべてのメソッドを受け継いでいますし、必要で
あれば新しいメソッドを追加できます。さらに受け継いだメソッドを自分の要
求に合わせて置き換えることもできます。

図6[拡大表示]に、図5で定義したStackクラスを継承したFixedStackクラスを示
しました。class文のクラス名の後ろにある「＜ Stack」でスーパークラスを指
定しています。これはFixedStackクラスがStackクラスのサブクラスで、メソッ
ドなどのStackクラスの性質をそのまま受け継ぐことを意味しています

FixedStackクラスではinitializeメソッドとpushメソッドが置き換えられてい
ます。それぞれの定義の中で「super」を呼び出していますが、これは、スーパー
クラスの同じ名前のメソッド（super）を呼び出すことを意味します。このよう
な仕組みによってスーパークラスのメソッドの中身に立ち入ることなく、サブ
クラスだけでメソッドの動作を変更できます。

initializeメソッドはオブジェクトの初期化のときに呼ばれますから、以下の
ように書けば、initializeメソッドが10を引数として呼び出され、10が要素数
の上限としてインスタンス変数@limitに設定されます。

: stack = FixedStack.new(10)

図6では、末尾にスタックの先頭要素を取り除くことなく、単に参照するための
topメソッドを追加しています。スーパークラスに備わっていないメソッドを追
加した例と考えてください。

図6のように既存のクラスを利用して新しいクラスを作り出すことを「差分プロ
グラミング」と呼びます。抽象化によって共通部分をスーパークラスとしてく
くり出すことと、既存のクラスを利用して新しいクラスを作ることは同じ手法
の両面のようなものです。前者をボトムアップ・アプローチ、後者はトップダ
ウン・アプローチと呼びます。

さて、Rubyをはじめとする多くの言語では1つのクラスに対して、1つのスーパー
クラスが決まります。このような継承を「単純継承」と呼びます。継承につい
て、クラスを拡張するトップダウン・アプローチから考えると、1つのクラスか
らそれを拡張した別のクラスを作るということは、ごく自然なことです。

しかしながら、これまで見てきたような共通部分をくくり出すというボトムアッ
プ・アプローチから考えると、1つのクラスに1つのスーパークラスというのは
かなり厳しい制約です。実は、C++やLispなど複数のスーパークラスを持つこと
ができる言語もたくさんあります。そのような継承を「多重継承」と呼びます。
多重継承には利点はもちろん、欠点もあります。多重継承については次回扱う
ことにします。


