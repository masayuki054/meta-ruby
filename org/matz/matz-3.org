* 多重継承の光と影 第3回（1）
  2005/09/20

  - ネットワーク応用通信研究所　まつもと ゆきひろ
  - 出典：日経Linux 2005年7月号 　125ページより 
  （記事は執筆時の情報に基づいており、現在では異なる場合があります）

多重継承では，個々のクラスが複数のスーパークラスを持つ。

ReadWriteStreamのスーパークラスがWriteStreamに限定されてしまう。

** 概要

今回は継承についてより深く学びます。特になぜ多重継承が必要なのか、多重
継承にはどのような問題があり、JavaやRubyがどのように解決しているのかを
学びます。

** なぜ多重継承が必要なのか

単一継承はスーパークラスを1つしか持てません。これでは制限が厳しすぎると
感じることもあります。現実世界では、人はしばしば会社員であると同時に父
親であったり、プログラマであると同時にライターであったりします。

先月説明したように、継承をプログラムの共通部分をくくり出す抽象化の手段
として考えてみると、1つのクラスから抽象化（抽出）できる部分が1つだけと
いうのはプログラミングの上で大きな制約になります。このような発想から生
まれたのが多重継承です。単一継承と多重継承の違いはスーパークラスの数だ
けですから、多重継承は単純継承の完全なスーパーセットであり、自然な拡張
と考えることができます（図1[拡大表示]）。

多重継承が使える言語は、単一継承にある不自然な制約を受けません。例えば、
単一継承のみを提供する言語Smalltalkの例で考えてみましょう。Smalltalkの
クラス・ライブラリには単一継承によって不自然な形になっています。

Smalltalkでは、入出力を担うStreamクラスに3つのサブクラスがあります。入
力用のReadStream、出力用のWriteStream、双方向入出力向けの
ReadWriteStreamです。ReadWriteStreamはReadStreamの機能とWriteStreamの機
能の両方を持ちます。しかし、Smalltalkは単一継承だけしか使えませんから、
両方のクラスから継承することはできません。

結局、ReadWriteStreamをWriteStreamのサブクラスにした上で、ReadStreamの
コードをコピーし、ReadWriteStreamを実現しています（図2[拡大表示]）。プ
ログラムのメンテナンスという観点から、コードのコピーは避けるべきです。
言語の制約からコードをコピーが必要になるというのは望ましくありません。

一方、多重継承があれば、自然な発想に基づいてReadStreamクラスと
WriteStreamクラスの両方を継承したReadWriteStreamを作れます（図3[拡大表
示]）。

** 多重継承と単一継承は表裏一体

　このように多重継承と単一継承を比べて見ると、単一継承の特徴が際立ちます。

*** 継承関係が単純

　単一継承では、継承関係が単純な木構造になります。これは利点でもあり、欠点でもあります。クラスの関係が単純なため混乱を生みませんし、実装も簡単です。しかし、先ほどのSmalltalkのStreamのように、継承関係を越えたコードの共有ができず、コピーが必要になる場合があります。

　式や変数に型指定が行われるJavaのような静的型の言語においては、単一継承からくるもう一つの欠点も見えてきますが、これは後で説明しましょう。

　多重継承の特徴はちょうど逆です。多重継承には2つの優れた特性があります。

- 単一継承の自然な拡張

- 複数のクラスから機能を取り込むことができる

　多重継承は単一継承ができることなら何でも実現できます。しかし、クラスの関係が複雑になりがちという欠点があります。


** goto文と多重継承は似ている

　前回、構造化プログラミングについて学びました。gotoを用いて任意の場所
にジャンプできる構造よりも、分岐と繰り返しという制限された構造によって
プログラムを構築した方が望ましいと説明しました。分岐や繰り返しはgotoを
使って実現できますし、分岐などでは直接実現できない制御の流れもgotoなら
記述できます。gotoは分岐などよりも「記述力が高い」ということができます。

　しかし、gotoは機能が高いにもかかわらず望ましくないと言われます。goto
を使ったプログラムは、制御の流れがどこに移るのか一目で分からないことが
多く、人間にとって理解しにくいプログラムになりやすいのです。このような
制御が絡み合ったプログラムのことを「スパゲッティ・プログラム」と呼びま
す。

　多重継承についても同じことが言えます。多重継承は単一継承の拡張ですか
ら、単一継承を使ってできることはすべて実現できます。単一継承では解決が
難しい問題も解決できるでしょう。

　しかし、複数のスーパークラスからの継承を許すことで、クラスの関係が複
雑なネットワーク構造になります（単一継承は木構造）。このため、どのクラ
スがどのクラスの機能を利用しているのか分かりにくくなりますし、問題が発
生したとき、どのクラスとどのクラスが悪さをしているか見分けにくくなりま
す。

　このような絡み合った継承のことを俗に「スパゲッティ継承」と呼ぶことが
あります。もちろん、多重継承があるからといって、必ずスパゲッティ継承に
なるわけではありませんが、注意が必要なのは確かです。

* 多重継承の光と影 まつもと直伝　プログラミングのオキテ 第3回（2）

図4　多重継承の優先順位
メソッドを呼び出す優先順位がはっきりしない。


図5　親子関係にあるクラスの例
変数からはサブクラスにしかないメソッドDを呼び出せない。

** 多重継承から生まれる3つの問題

　もう少し、細かく見ていくと、多重継承の問題は以下の3点にまとまります。

- 構成の複雑化

  単一継承では、あるクラスのスーパークラスは簡単に決まります。直接上の
  スーパークラス、そのスーパークラス、そのまたスーパークラス、…と一列
  に並ぶ単純な関係です。多重継承では、あるクラスに複数のスーパークラス
  があり、その複数のスーパークラスそれぞれにさらに複数のスーパークラス
  があるので関係が複雑になってしまいます。

- 優先順位

  複雑な関係を持つスーパークラスがあるということは、クラス群の優先順位が
  一目で分からないということです。例えば図4[拡大表示]のようなクラス階層が
  あるとします。Dがあるメソッドを受け継ぐ順番は、D、B、A、C、Objectなのか、
  D、B、C、A、Objectなのか、あるいは全く違う順序なのかが分かりません。一
  つに決まらないのです。クラスの優先順位がはっきり定まる単一継承とは対照
  的です。

- 機能の衝突

  多重継承では複数のスーパークラスからメソッドなどの機能を受け継ぐこと
  から、受け継いだメソッドの名称が衝突することもあります。図4の例では、
  クラスBとクラスCに同じ名前のメソッドがあった場合、どちらが有効になる
  のでしょうか。一意に定めることはできません。

** 多重継承の問題を解決するには

ここまで多重継承の欠点を説明しましたが、SmalltalkのStreamの例をはじめと
して多重継承がなければ解決できない問題が残っています。

さらに、継承を抽象化の手段として考えるときには、なんからの形で多重継承
の役割を果たす機能が必要なのです。共通するクラスの機能をくくり出すとき
に、1つのクラスにつき1つだけしか抽出できないと言う制限は厳しすぎるから
です。

多重継承のメリットを享受しつつ、問題を避けたいというのであれば、なんと
か問題を解決する機能を考えるしかないでしょう。構造化プログラミングが
goto問題を解決した際の原則は、自由度の高いgotoの代わりに、gotoより制約
された3種類の制御構造を導入するというものでした。この3種類の制御構造は
制約されてはいますが、これらを組み合わせることで任意のアルゴリズムを記
述できます。これに従えば、より制約がきつい多重継承を導入すれよさそうで
す。

そこで、これらの問題を解決あるいは軽減するために登場した「制約された多
重継承」とでも呼ぶべき機能が、Javaにおけるインタフェースであり、Lispや
RubyにおけるMix-inです。ここからは、これらがどのような機能であり、どの
ようにこれらの欠点を改善するのか見てみましょう。

** 静的型言語と動的型言語の違い

最初に、Javaのインタフェースを調べてみましょう。

インタフェースの仕組みを説明する前に、まずJavaのようなタイプのオブジェ
クト指向言語と多重継承について説明しておきます。

オブジェクト指向言語は、大きく分けて「静的型言語」と「動的型言語」の2つ
に分かれます。変数や式に型情報が付けられているJavaのような言語のことを
静的型言語と呼びます。

静的型言語では型が異なる値を変数に代入できません。代入するとコンパイル・
エラーになります。型の不整合はコンパイル時に見つかりますから、実行時に
なって「型が合わない」というエラーは発生しません。実行しなくてもエラー
を見付けられる、これが静的型言語のメリットの一つです。

: String str;
: str = "abc"; // 問題なし
: str = 2; // コンパイル・エラー

オブジェクト指向言語では変数などの型をクラスで指定することが多いでしょ
う。上の例ではStringクラスです。しかし、オブジェクト指向言語を使う際、
この例のように変数に特定のクラスのオブジェクト（そのクラスのインスタン
ス）しか代入できないという制限は厳しすぎます。なぜなら、ポリモーフィズ
ムが働く余地がありません。ある変数に、必ず変数と同じクラスのオブジェク
トが入っているのなら、オブジェクトのクラスによってふさわしい挙動を選ぶ
（ポリモーフィズム）ことはあり得ないからです。

** 静的型言語の特徴

そこで、静的型を持つオブジェクト指向言語では、あるクラスの変数にはその
クラスのオブジェクトに加えて、サブクラスのオブジェクトが代入できるよう
に設計されています。これによってポリモーフィズムが実現できるわけです。

図5[拡大表示]のプログラムを見てください。末尾に出てくる変数polyの型は
Polygonですから、polyを介してPolygonクラスのメソッド（例えばメソッドC）
を呼び出すことができます。しかし、実際に代入されているのはPolygonクラス
のサブクラス＊2であるRectangeクラスです。従って、呼び出されるのは
Rectangeクラスで定義されているメソッドです。RectangeメソッドでPolygonク
ラスのメソッドが再定義されていない場合は、そのままPolygonクラスのメソッ
ドが呼び出されます。つまり、メソッドA'、B'、Cを呼び出せます。

しかしながら、polyはあくまでもPolygonクラスとしてプログラムに登場してい
ますから、たとえRectangeクラスのオブジェクトが代入されていると（人間に
は）明らかでも、poly変数を介する限りRectangeクラス固有のメソッド（メソッ
ドD）を呼び出すことができません。

言い換えれば、変数は実際に代入されているオブジェクトをのぞき見る窓のよ
うなものと言えます。変数に代入されているオブジェクトが持つメソッドがど
のようなものであっても、ある変数を介してメソッドを呼び出すときには、そ
の変数の型が「知っている」メソッドしか呼び出すことはできません。

メソッドDを呼び出してみると、静的型言語では無情にもコンパイル・エラーに
なってしまいます。

これはRubyのような変数や式に型のない動的型の言語とは対照的です。これら
の言語は変数を介して実際にオブジェクトのメソッドを呼び出してみて、見つ
からなければはじめてエラーにしています。

** 動的型言語の特徴

動的型言語では継承関係に関係なくメソッドを呼び出せます。例えばRubyでは
要素を順番に取り出すメソッドeachが用意されていて、配列、ハッシュ、文字
列などにeachが備わっています。

: obj.each {|x|
:  print x
: }


静的型言語では継承関係のあるメソッドしか呼べませんから、配列、ハッシュ、
文字列のすべてに対して呼び出しをかけられるのは、これらに共通するスーパー
クラス（恐らくはObject）に所属するメソッドだけです。

これが、後ほど説明するとした静的型言語における単一継承の欠点です。

静的型言語では、クラス階層の木を横断してメソッドを呼び出したい場合、そ
れらのオブジェクトすべてを表現できる「型」が必要です。そのような型がな
ければ、メソッドが呼び出しできる範囲が非常に狭くなるのです。静的型のオ
ブジェクト指向言語ではなんらかの形の多重継承が欠かせないことが分かりま
す。

** 静的型と動的型の比較

静的型と動的型は対照的です。両者の手法の違いは一長一短なのです。静的型
言語では、実際に実行しなくても漏れなく型の不整合が見付かりますから、プ
ログラムの論理エラーのうち、ある程度の割合を自動的に検出できます。

しかし、式や変数の一つひとつに型を指定する必要があるので、プログラムが
冗長になりがちですし、なんらかの継承関係があるものだけしか、ポリモーフィ
ズムの対象になりません。このような仕組みは、動的言語よりも制約が厳しく
柔軟性が低いと言えます。

動的型言語はちょうど反対です。いくつかのエラーは実行してみないと分かり
ませんから、プログラムの信頼性という観点で若干の不安があります。プログ
ラムに型の情報がないということは、プログラムが簡潔になる半面、他人が書
いたプログラムを解釈する際にヒントが少なくなります。

しかし、とりあえず同じ名前のメソッドを持っているオブジェクトを同じよう
に扱えます。つまり、型の階層について深く検討しなくてもプログラムを開発
できるということになります。生産性という面からは大変ありがたいことです
＊3。

* 多重継承の光と影 まつもと直伝　プログラミングのオキテ 第3回（3）

** 継承には2つの意味がある

- 「どのようなメソッドを持っているか」あるいは「どのように振る舞うか」
- 「どのようなデータ構造を使い、どのようなアルゴリズムで処理す
   るか」ということに着目した「実装の継承」

静的型言語では両者の区別が重要になります。

Javaでもこの2つを明確に区別しており、

- 実装の継承はスーパークラスとして「extends」で指定
- 仕様の継承の方はインタフェースと呼ばれるものを「implements」で指定

- クラス オブジェクトの実装を指定
- インタフェース オブジェクトの外見だけを指定

Javaでは「extends」（実装の継承）ではスーパークラスを1つだけしか指定で
きません。そのため、実装の継承では単一継承となります。クラス関係が木構
造に制限できるため、クラスライブラリの構成がシンプルになります。

一方、「implements」（仕様の継承）では複数のインタフェースを指定できま
す。インタフェースでは「オブジェクトをどのように扱いたいか」を指定しま
す。

** インタフェースにも不満がある

静的言語における多重継承の必要性を満たしながら、多重継承のデメリットで
あるデータ構造の衝突やクラス階層の複雑化などを回避しています。

しかし、インタフェースが完璧な解決策かと問われると、そうは言い切れない
でしょう。インタフェースに対して不満が残っているからです。ずばり「実装
を共有できないこと」が問題なのです。

多重継承の問題を回避するために、仕様の継承についてのみ多重継承を許した
のですから、実装の継承が単一継承しかないことに文句を言うのはどうか、と
も思いますが、一ユーザーとして不便なものはやっぱり不便です。Javaでは実
装の共有の問題への対応として、単一継承のまま、共通する機能を実装する別
クラスを作り、それを呼び出すCompositeパターンを推奨しています。

しかし、ただ単に継承の階層を越えてコードを共有したいだけなのに、わざわ
ざ別の独立したオブジェクトを作り、メソッドをそのオブジェクトにいちいち
転送するのも面白くない話です。実行効率も高いとはいえません。

** 実装を継承する方法

動的型言語には仕様の継承という概念がそもそも存在しません。解決しなけれ
ばならないのは、実装の多重継承だけです。

Lisp、Perl、Pythonでは単純に多重継承を提供しています。これで単一継承の
問題はなくなります。多重継承で起こりうる問題に関しては「気を付けて使っ
てね」という立場のようです。

** 多重継承を変形したMix-in

RubyはJavaとも他の動的型言語とも違った手法を採っています。Rubyはモジュー
ルを使ったMix-inという方法で多重継承の問題に対応しました。

Mix-inというのは元々Lisp界で始まった多重継承の使い方です。Mix-in手法に
は次の2つの条件があります。

- 通常の継承は単一継承に限る

- 2つめ以降の継承は、Mix-inと呼ばれる抽象クラスからに限定する

Mix-inクラスは以下のような特徴を備えた抽象クラスです。

- 単独でインスタンスを作らない

- 通常のクラスから継承しない

これらの規則に従うことで、クラス階層は単一継承と同じ木構成になりますし、
機能の共有を実現するには、共有する機能だけを持つMix-inをクラス階層木に
「差し込む」ことで達成できます。インタフェースを使って仕様の継承問題を
解決したJavaの手法を、実装の継承に対して適用したと考えることができるで
しょう。

Mix-inの実例を見てみましょう。図7[拡大表示]は、図2と図3で取り上げた
SmalltalkのStreamと同等の構造を、Mix-inで構築したものです。

Mix-inを用いたクラス構成では、Streamの下に3つのサブクラスを作るだけです。
その上で、実際の入出力機能はReadable（入力）、Writable（出力）という2つ
のMix-inに実装します。このMix-inをそれぞれのサブクラスに継承させること
で、入力、出力、入出力という3つのクラスを実現しています。

Streamのクラス階層だけを見るとスーパークラスのStream、入出力を担当する
サブクラスReadStream、WriteStream、ReadWriteStreamというように明快な木
構造になっています。クラスの構成がネットワーク状になっておらず、単純で
す。さらに、共有されるコードはMix-inにまとまっているので、コードのコピー
もうまく避けています。

Mix-inは、一般的な多重継承と比べてクラス構成を単純にできる優れたテクニッ
クと言えます。Mix-inというルールを導入して継承を制限し、多重継承をいわ
ば「飼いならす」わけです。

ちょうど構造化プログラミングが任意のgotoを制限して分岐とループを導入し
たのと同じです。Mix-inは多重継承を備えた言語ならどれでも使えるので、覚
えておくと良いテクニックでしょう。

** Mix-inを自由に使えるRuby

多重継承をそのまま導入している他の言語と比べ、RubyはMix-inを直接サポー
トしている点に特徴があります。RubyではMix-inの単位として「モジュール」
という構造が導入されているからです。モジュールは、まさにMix-inのための
性質を備えています。

- オブジェクトが作れない

- 通常のクラスから継承できない

では、RubyではMix-inをどのように使うかを見てみましょう（図8[拡大表示]）。
これは図7に示したStreamクラスを定義したRubyプログラムです。

Mix-inはmodule文で定義します。module文はクラスを定義するclass文とよく似
ていますが、スーパークラスを指定できません。メソッド定義などの方法はク
ラスと同じです。

モジュールをクラスに取り込むためにはincludeを使います。includeを使うと
そのモジュールで定義されているメソッドなどをクラスに継承します。あくま
でも継承であって、コピーされるわけではないので、自クラスで同名のメソッ
ドが定義されていた場合、自クラスのものが優先されます。

** まとめ

単一継承と単純継承についてさまざまな面から扱いました。最後にまとめて
おきましょう（表1[拡大表示]）。

いやあ、今回は本当に盛り沢山でしたね。次回は表1の内容を踏まえて、静的言
語と動的言語について、特に動的言語におけるDuck Typingについて学ぼうと思
います。
