* メタプログラミング
** 概要

今回は「プログラミングをプログラムする」メタプログラミングについて学び
ます。メタプログラミングを利用すると、動的にメソッドを追加するなど、実
際のアプリケーション作成に役立つ処理が簡単に実現できます。メタプログラ
ミングと小言語の関係についても解説を加えました。

今回はメタプログラミングを扱います。メタとはギリシャ語で「間に、後に、越える」などを意味する接頭辞「meta」に由来する言葉で、「超越」、「高階」などの意味があります。例えば、Rubyをはじめとする多くのオブジェクト指向プログラミング言語では、「クラスのクラス」のことを「メタクラス」と呼びますし、他のオブジェクトを支えるクラス・オブジェクトなどのことをメタオブジェクトと呼ぶこともあります。

メタプログラミングとは、プログラミングをプログラミングすることです。そ
んなことが何の役に立つのかと感じる方もいらっしゃるでしょう。今回は一見
して何の役に立つのか分からないメタプログラミングの能力の一端を紹介しま
す。

** メタプログラミング

　では、早速Rubyを用いてメタプログラミングの実例を見てみましょう。まずは動的にメソッドを生成する例です。

　Rubyのクラスに組み込まれた機能であるattr_accessorは、インスタンス変数にアクセスするメソッドを作り出します（図1）。図1に示した短いコードだけで、Personというクラスに対してnameメソッド、ageメソッドが生成されます。これらを使って代入もできます。

class Person
 attr_accessor :name, :age
end

図1●メタプログラミングの例
Rubyではattr_accessorを用いてインスタンス変数をアクセスするメソッド（ここでは、nameとage）を生成できる。

　ここで重要なことは、このattr_accessorはこのような機能を実現する文法ではなく、Moduleクラスが提供する単なるメソッドであり、その気になれば同じような働きをするメソッドを自分で定義できる、ということです。

　attr_accessorは内部的に次のような処理を行っています。

（1）引数のシンボルすべてに対して以下の処理を繰り返す。

（2）シンボルで指定された名前のメソッドを定義する。そのメソッドはシンボルの名前の先頭に「@」を付加したインスタンス変数の値を取り出す。

（3）シンボルで指定されたメソッド名の後ろに「=」を付加した名前のメソッドを定義する。そのメソッドは引数を1つ取り、その値をシンボルの名前の先頭に「@」を付加したインスタンス変数に設定する。

　簡単な手順のようですが、CやC++のようなプログラミング言語ではなかなかできないことです。なぜなら、C++などではプログラムの実行中、簡単には動的にクラスにメソッドを追加できないからです。Rubyでは図1のように簡単に実現できています。実際にはattr_accessorはCで実装されていますが、同じ処理をRuby自体で実現するならば図2のようになるでしょう。

: class Module
: 
:  def attr_accessor(*syms)
:   syms.each do |sym|
:   class_eval %{
:    def #{sym}
:     @#{sym}
:    end
:    def #{sym}=(val)
:     @#{sym}=val
:    end
:   }
:   end
:  end
: end
図2●attr_accessorをRuby自体で実装した例

　class_evalは文字列を受け取って、それをクラスの文脈で評価するメソッドです。図2では「%{」から対応する「}」までの間が文字列としてclass_evalに渡されています。文字列の中では「#{」と「}」で囲むことで式を埋め込むことができますから、変数symで示されるメソッド名が埋め込まれた文字列が評価され、ループの繰り返しごとに2つのメソッドが定義されることになります。ですから、次のような呼び出しがあると、

: attr_accessor :name

呼び出しの対象となったクラスにnameという名前でインスタンス変数@nameの値を取り出すメソッドを定義し、name=という名前でインスタンス変数@nameの値を設定するメソッドを定義します。

　メタプログラミング機能を持たない言語では、このような処理を実現しようとするとかなり手間がかかります。言語の文法そのものを拡張するか、マクロのようなプログラムを前処理するプリプロセッサを導入するかしかありません。いずれにしても通常の言語にとっては大げさなことになってしまいます。


* メタプログラミング リフレクション

** リフレクション

メタプログラミングの例として次にリフレクション（reflection）を取り上げましょう。英単語では「反射」とか「反省」を意味しますが、プログラミングの文脈で用いられた場合、実行中のプログラムの情報を取り出したり、変更したりする機能のことを指します。

Rubyの場合、表1に挙げたリフレクション機能を備えています。変数やメソッドの一覧を得たり、値を取得・変更したりするさまざまな手法が用意されていることが分かります。考えてみれば、2005年7月号で解説したMix-inを行うincludeですら、Rubyの文法ではなく、メソッドによって実現されています。Rubyでは動的にプログラムを操作するという性質が徹底されているのです。


表1●Rubyの備えるリフレクション機能

では、これらの機能を使うとどのようなことができるのか、具体的な事例を見ながら考えてみましょう。

** メタプログラミングの事例

　まずはリフレクションを用いた事例を紹介します。

　あるオブジェクトに対する呼び出しを別のオブジェクトに転送したい場合があるでしょう。Rubyでは委譲を行うためのライブラリとしてDelegetorが用意されています。Delegatorオブジェクトはメソッドの委譲先のオブジェクトを持ち、メソッド呼び出しを委譲先に転送します。デザイン・パターンで言うとProxyパターンの基礎部分を実現するものです。Delegatorを使うためには、SimpleDelegatorクラスを使います。

: require 'delegator'
: d = SimpleDelegator.new(a)

　これだけでオブジェクトdに対するメソッド呼び出しはすべてオブジェクトaに転送されます。転送されるだけではあまりうれしくないのですが、このオブジェクトに特異メソッド＊1を付加して一部だけ挙動を変えるなど、さまざまな使い道があります。

　以上の処理を他の言語、例えばJavaで実現するとしたらどうなるでしょうか。静的型を持つJavaでは型を合わせるため、aの型に対応してメソッドを転送する専用のDelegator用クラスを個別に用意する必要があります。aのクラスにいくつメソッドがあるかは分かりませんが、場合によっては非常に数が多くなることも考えられます。いずれにしても、おそらくは専用のツールで自動生成でもしないことには現実的ではないでしょう。

　DelegatorはRubyの動的型をリフレクションの組み合せによって初めて実現できているといえるでしょう。

** リフレクション機能を使う

それでは、Delegatorクラスを実現するためにRubyのリフレクション機能がどのように使われているかを見てみましょう。図3はSimpleDelegatorの実装の一部です。理解のために実際のものよりもかなり単純化してあります。

: class SimpleDelegator

:  # （a）メソッドの未定義化
:  preserved = ["__id__", "object_id", "__send__", "respond_to?"]
:  instance_methods.each do |m|
:  next if preserved.include?(m)
:  undef_method m
:  end
: 
:  # （b）オブジェクトの初期化
:  def initialize(obj)
:   @_sd_obj = obj
:  end
: 
:  # （c）method_missing
:  def method_missing(m, *args)
:    unless @_sd_obj.respond_to?(m)
:    super(m, *args)
:   end
:   @_sd_obj.__send__(m, *args)
:  end
: 
:  # （d）メソッド・チェック
:  def respond_to?(m)
:   return true if super
:   return @_sd_obj.respond_to?(m)
:  end
: end
図3●SimpleDelegatorの実装内容

　図3のコードは、大きく4つの部分に分かれています。まず、一番重要なところから説明しましょう。（c）で示した部分がDelegatorの心臓部です。Rubyはメソッド呼び出しを行った際に、オブジェクトがそのメソッドを知らない場合、まずmethod_missingという名前のメソッドを呼び出します。method_missingの第1引数は呼び出されていたメソッド名、残りがそのメソッドに渡されるはずだった引数です。method_missingのデフォルトの実装は例外を発生させますが、これをオーバーライドすることで未知のメソッドに対応させています。ここでは、次の2つの処理を進めています。

（1）委譲先のオブジェクトがそのメソッドを知らなかったら（respond_to?）、デフォルトの実装を呼び出し（super）、エラーを発生させる。

（2）そうでなければ、__send__を使って委譲先のメソッドを呼び出す。

　__send__というのはオブジェクトのメソッドを呼び出すメソッドです。このメソッドにはsendという別名がありますが、ありふれた名前でいかにも重複しそうなので__send__という名前の方を採用しています。

　SimpleDelegatorの残りの部分の実装は比較的簡単です。説明した通り、SimpleDelegatorはmethod_missingを使ってメソッドの転送を行っています。しかし、RubyのObjectクラスは比較的たくさんのメソッドを提供する「大きなクラス」です。Objectクラスは実に40ものメソッドを抱えています。SimpleDelegatorはObjectクラスのサブクラスですが、これら40もの「知っているメソッド」を転送できないのは困ります。そこで、（a）の部分で、instance_methodsで得られるメソッドの一覧を使って、必須のメソッド（__id__、object_id、__send__、respond_to?）を除いたメソッドを未定義化しています。

　（b）ではSimpleDelegatorの初期化の部分で委譲先を設定しています。（d）の部分ではrespond_to?が正しく反応するように、まずsuperを使って自分のメソッドを調べた後、委譲先のメソッドをチェックするようにしています。



* メタプログラミング 分散Rubyを実現する 
  まつもと直伝　プログラミングのオキテ 第6回

** 分散Rubyを実現する

　「呼び出されたメソッドをそのまま他のオブジェクトに転送する」Delegatorの機能はほかにもいろいろと応用できそうです。一例としてdRuby（Distributed Ruby、分散Ruby）を紹介します。

　dRubyはネットワーク経由でメソッドを呼び出すライブラリです。dRubyはサーバー上に存在するリモート・オブジェクトに対応するオブジェクト（Proxy）を作り出し、そのProxyへのメソッド呼び出しをネットワークを越えて転送します。

　呼び出されたメソッドはサーバー上のリモート・オブジェクトで実行され、戻り値が再びネットワークを経由して返ってきます。JavaでいうRMI（Remote Method Invocation）などと似たような仕組みですが、Rubyのメタプログラミング機能を利用して、明示的なインタフェースを定義することなく、任意のオブジェクトのメソッドをネットワーク経由で呼び出せます。

　C++やJavaでのリモート・メソッド呼び出しではIDL（Interface Definition Language）のような言語によってインタフェースを記述し、自動生成されるスタブをコンパイル・リンクしなくてはいけません。これと比較するとなんと簡単に扱うことができるのでしょう。これこそがメタプログラミングの力です。

　dRubyの最初の版は、わずか200行で実装されたのだそうです。これもメタプログラミングの力だと思います。ただし、現在ではdRubyはRubyに標準添付されており、総行数では2000行を越える大規模ライブラリに成長しています。

** データベースに応用する

　データベース分野でもメタプログラミングが使われています。

　Webアプリケーション・フレームワークRuby on Rails（RailsまたはRoRと呼ばれる）＊2にもメタプログラミングが隠れています（関連記事「生産性の高いWeb開発環境 Ruby on Rails」を参照）。具体的にはデータベース連携ライブラリ（ActiveRecord）が、メタプログラミング機能を使い、簡単にデータベース・レコードと対応するオブジェクトを定義しています。

　図4はActiveRecordを使ったデータベースの定義の例です。これとは別にデータベースにテーブルが定義されているとします。Userクラスに対応するもの（usersテーブル）だけを図5に示しました。

: class User < ActiveRecord::Base
:  has_one :profile
:  has_many :item
: end
: 
: class Profile < ActiveRecord::Base
:  belongs_to :user
: end
: 
: class Item < ActiveRecord::Base
:  belongs_to :user
: end
図4●ActiveRecordによるレコード定義の例

: CREATE TABLE `users` (
: 
:  `id` int(11) NOT NULL auto_increment,
:  `login` varchar(80) default NULL,
:  `password` varchar(40) default NULL,
:  PRIMARY KEY (`id`)
: 
: ) TYPE=MyISAM;
図5●図4で用いるusersテーブル定義の内容

　図4に示したわずかなコードから、ActiveRecordは、次のような処理を進めます。

（1）クラス（User）とクラス名を複数形にしたテーブル（users）を連携させる。

（2）テーブルのスキーマからレコード内容にアクセスする手段を用意する。

（3）has_one、belongs_toなどの関連指定から、関連するオブジェクトを取り出す手段を用意する。

　このような処理ができるのも、メタプログラミング機能によってクラス名を取り出したり、メソッドを実行時に追加したりできるおかげです。メタプログラミングを応用することで、Railsは生産性の高いWebアプリケーション・フレームワークだという評判が高まっています。

　もちろんRailsが万能で、他のあらゆるフレームワークよりも優れているというわけではありません。しかし、Rubyという言語の特徴を最大限に活用して、非常に高い生産性を確立しているのは確かです。

　Railsについての最新情報は、Webサイトから入手できます。このサイトでは「15分で分かるRails」といった雰囲気で実際にWebアプリケーションを作るビデオを視聴できます。目の前であっという間にWebアプリケーションを作ってしまう様子には感銘を受けます。これは必見です。英語ですが、雰囲気は伝わってきます。

** XMLを出力する

　最後に、XMLファイルを出力するためのライブラリを紹介しましょう。Jim Weirich氏が開発したXmlMarkupです。図6のようなプログラムでXMLを簡単に出力（図7）できます。

: require 'builder/xmlmarkup'
: 
: xm = Builder::XmlMarkup.new(:indent => 2)
: puts xm.html {
: 
:  xm.head {
:   xm.title("History")
:  }
:  xm.body {
:   xm.h1("Header")
:    xm.p {
:     xm.text!("paragraph with ")
:     xm.a("a Link", "href"=>"http://onestepback.org")}
:  }
: }
図6●XmlMarkupのプログラム例と出力内容

: <html>
:  <head>
:   <title>History</title>
:  </head>
:  <body>
:   <h1>Header</h1>
:   <p>
:   paragraph with <a href="http://onestepback.org">a Link</a>
:   </p>
:  </body>
: </html>
図7●図6の出力内容

Builder::XmlMarkupはDelegatorと同様にmethod_missingを用いるテクニックを使っています。メソッド呼び出しによってタグ付きのXMLを出力します。

タグの付いていないテキストにわざわざtext!を付けなければなりませんが、XMLという人間が書くには手間がかかるフォーマットを、Rubyのブロックを使ってうまく表現しています。


* メタプログラミング メタプログラミングと小言語

** メタプログラミングと小言語

ここまで紹介してきたようなメタプログラミング機能をあなたならどのように使いますか。

Glenn Vanderburg氏＊3によれば、メタプログラミング機能が最も活用できるのはDSL（Domain Specific Language）の分野なのだそうです。DSLとは特定の分野向けに機能を強化した小規模なプログラミング言語のことで、昔からあるアイディアです。ユーザーがアプリケーションを強化したり、カスタマイズしたりするために活用されるなど、最近再び注目されている考え方です。同氏によればDSLは問題分野に特化するため、表2のような機能を備えていることが望ましいのだそうです。


表2●小言語が備えるべき機能

このうち、「型」から「制御構造」まではRubyに元々備わっています。多くのDSLはミニ言語でこの辺り手を抜いていることが多いので、かえって使いやすいかもしれません。また、前回学んだようにRubyはブロックを使って制御構造を実現するメソッドを自分で定義できるというのも利点です。

残りの「宣言」から「階層データ」まではRuby自身に備わった機能で実現できます。この実現にはRubyのメタプログラミング機能が活躍するのです。

** Rubyの宣言

表2にある「宣言」について考えてみましょう。

今回、冒頭でattr_accessorをメタプログラミングの例として紹介しました。Rubyとして見たときには単なるメソッド呼び出しですが、宣言として考えることもできます。ActiveRecordの例でもhas_manyなど宣言として考えることができるメソッドの例はたくさんあります。

Rubyではメソッドがプログラム自身の状態を読み出したり、変更したりできるので、通常のメソッド呼び出しで、他の言語であれば「宣言」によって進めるような内容を実現できます。

外見の点からは、Rubyのメソッド呼び出しはかっこの省略ができる点、また「名前を表現するもの」として:fooのような「シンボル」が使える点でより宣言らしいプログラムの見かけが実現できています。

** Rubyの文脈依存

次は「文脈依存」です。文脈依存とは文脈によってある一定の範囲だけ語彙（ごい）をすりかえることです。少々人工的な例ですが、図8のようなプログラムを考えます。

: add_user {
: 
:  name "Charles"
:  password "hello123"
:  privilege normal
: 
: }
図8●文脈依存のプログラムの例

この例ではadd_userで指定したブロックの範囲内でだけ、nameやpasswordなどのメソッドが有効になっています。つまりadd_userのブロックの外側ではこれらのメソッドは見えないわけです。

Rubyレベルではこれはブロックの範囲内だけメソッドの受け取り手であるselfをすりかえることで実現しています。具体的には図9のようにinstance_evalメソッドを使います。

: def add_user(&block)
: 
:  u = User.new
:  # User class has name, password,
:  # privilege methods
:  u.instance_eval(&bock) if block
: 
: end
図9●図8でコンテキストをすりかえている処理

instance_evalメソッドがブロックを受け取ると、selfを置き換えた状態でブロックを実行します。結果として、図8の例ではブロックの範囲内でデフォルトのレシーバがUserクラスのインスタンスuになります。そのため、レシーバを指定せずに実行するメソッド（nameなど）としては、Userクラスのメソッドが呼び出されます。

** Rubyの単位

一般的なプログラミング言語では値として「スカラー値」を扱います。これは数そのものです。その数が表現している単位はプログラマ側で管理する必要があります。

一方、DSLで扱いたいのは単なる数ではなく「量」であることが多いのです。そのため、いくつかのDSL的アプローチに則ったライブラリでは「単位」を取り扱うように拡張されています。

例えばRuby on RailsではNumericクラスとTimeクラスに時間を扱うための単位メソッドが追加されています（基本単位は秒）。例えばある時間を表現するためには

: 3.years + 13.days + 2.hours

と書きます。するとこれは「3年と13日と2時間」を秒で表現した整数95803200
となります。また、次のようにして「今から4カ月後の月曜日」を表す時刻を得
ることができます。

: 4.months.from_now.monday

原稿執筆時に計算した結果は以下のようなものでした。

: Mon Dec 12 00:00:00 JST 2005

これは時刻と時間に関する例ですが、既存のクラスにメソッドを自由に追加できるRubyでは、このように単位を表現するメソッドを簡単に実現できます。

** Rubyの語彙

DSLが目的分野に特化しているというのは、結局、どれだけその目的分野で行われる処理を表現する語彙を持っているかということでしょう。ある分野で必要としているクラスやメソッド、手続きをRubyで定義するとは、Rubyをその分野向けの専用言語化することだと考えられます。そのようなクラスやメソッドのことをその分野における「語彙」と呼んでも良いでしょう。

「達人プログラマ」として知られるDave Thomas氏の言葉を借りれば「すべてアプリケーションを作る過程は結局言語をデザインすることである」のだそうです。その見方に従えばアプリケーションを作ることは、そのアプリケーションの問題領域の語彙をどんどん定義していき、最後にその語彙を使って問題解決手段を記述することにほかなりません。

Rubyのメソッド呼び出しやブロックなどの表現力を使うと、ユーザーにとってより自然な形で語彙を定義できます。また、語彙があらかじめ決定できない場合には、DelegatorやXmlMarkupのようにmethod_missingという手法を使って動的に語彙を追加・利用できます。

** Rubyの階層データ

最後に表2の末尾にある「階層データ」を説明します。先ほど紹介したXmlMarkupはまさに階層データの表現になっています。図6を再び眺めてみましょう。プログラムとして見たときには単なるブロック付きのメソッド呼び出しがネストしているだけのことですが、外見上も機能上も立派な階層データの表現です。

* メタプログラミング 言語内DSLに向く言語、向かない言語

** 言語内DSLに向く言語、向かない言語

まとめてみると、Rubyは非常にDSL向きな言語だと分かります。

まず、メソッド呼び出しにかっこを省略できることなど表現の多様性により、プログラムを宣言っぽく見せかけることができるので、宣言的な表記が可能になります。DSLで必要とされる機能の多くはデータ構造の表現や、設定など宣言的に表記されることが多く、宣言としての外見を提供できることは重要です。

さらに、メタプログラミング機能によって、プログラムの情報を取得・更新できるため、DSLに必要な機能をプリプロセッサやマクロを使うことなく実現できます。このように言語を拡張することなくDSLを実現するアプローチを「言語内DSL」と呼んでいます。

言語内DSLに向いた言語はRubyばかりではありません。Rubyが大きく影響を受けたLispやSmalltalkはRubyと同じように言語内DSLに適しているとされています。特にLispは固定的な文法が原則的にS式という構造データ表現しかありませんから、ほぼ任意の言語内言語を構築可能です。

Rubyならevalで文字列処理によってプログラムを構築するような局面でも、Lispならマクロによるリスト処理でプログラムを処理できます。Lispのことを「Programmable Programming Language」と呼ぶ人もいるほどです。

SmalltalkはLispほど極端ではありませんが、Rubyに負けないくらい動的で、かつメタプログラミング機能を持っています。Smalltalkでは元々制御構造もブロックを使って表現しているくらいですから、文法の拡張も思いのままです。

一方、他の手法を使わないと言語内DSLが実現しにくい言語もあります。例えばC++、Java、C#などの言語ではRuby、Lisp、Smalltalkと同じようなやり方ではDSLを実現できないでしょう。

しかし、このような言語でもDSLというアプローチを利用できないわけではありません。一つはコード生成です。これはDSLのための「ミニ言語」を用意して、それをC++、Java、C#などのターゲット言語に「コンパイル」するものです。このコンパイルにはしばしばRubyのようなテキスト処理に優れた言語が用いられます。「Code Generation inAction」＊4という書籍ではまるまる1冊このテーマが解説されています。

もう一つのDSLの実現方法はインタプリタを用意するものです。とはいえ、毎回アプリケーションごとに言語を文法から設計・実装するのも大変なので、定型の文法を採用して、ライブラリ・ルーチンを使って読み込みます。

具体的には文法にXMLを使って、DOM（Document Object Model）などのXML処理ライブラリを使って文法解釈を行います。Javaアプリケーションの設定ファイルにXMLが採用される理由の一つがこれです。XMLファイルによって、いちいちJavaプログラムをコンパイルすることなくアプリケーションの設定を変更したり、挙動をカスタマイズしたりできるようになります。

このような使われ方をしている場合、XMLはJava界のDSL、あるいはJavaアプリケーションのスクリプト言語と考えることができるでしょう。

今回はRubyを軸にメタプログラミング機能とその応用、特にDSLについて解説しました。Rubyの機能の応用範囲の広さについて感じていただけたのではないでしょうか。



