* 20分で始める Ruby の のーと

** インタラクティブRuby

irb の起動

: % irb
: irb(main):001:0>
<sTAB

#+BEGIN_SRC ruby :exports both

"Hello World"

#+END_SRC

#+RESULTS:
: Hello World

IRBが最後の式を実行した結果
を教えてくれている。 

"Hello World"と出力したいのであれば

#+BEGIN_SRC ruby :results output :exports both

puts "Hello World"

#+END_SRC

#+RESULTS:
: Hello World
: => nil

putsはRubyで何かを出力する基本的なコマンドです。 

=> nilは, このコマンドの評価結果です。 putsは必ずnilを返します。nil
は、「まったく何もない」ことを表すRubyの「値」です。

#+BEGIN_SRC ruby :exports both

3+2

#+END_SRC

#+RESULTS:
: => 5

#+BEGIN_SRC ruby :exports both

3*2

#+END_SRC

#+RESULTS:
: => 6

#+BEGIN_SRC ruby :exports both

3**2
#+END_SRC

#+RESULTS:
: => 9

平方根(square root)を求めるにはMathモジュールを使う:

#+BEGIN_SRC ruby :exports both

Math.sqrt(9)

#+END_SRC

#+RESULTS:
: =>3.0

** Math は一体なんでしょうか？

Math は数学のためのビルトインモジュール(標準で組み込まれているモジュー
ル)です。

#+BEGIN_SRC ruby :exports both

Math.class

#+END_SRC

#+RESULTS:
: Module

Rubyでは、モジュールには2通りの役割があります。これはその1つ目の役割、
関連するメソッドを馴染みのある名前でグループ化するものです。Math は
sin() や tan() といったメソッドも持っています。

#+BEGIN_SRC ruby :exports both :results code

(Math.methods)

#+END_SRC

#+RESULTS:
#+BEGIN_SRC ruby
[:atan2, :cos, :sin, :tan, :acos, :asin, :atan, :cosh, :sinh, :tanh, :acosh, :asinh, :atanh, :exp, :log, :log2, :log10, :sqrt, :cbrt, :frexp, :ldexp, :hypot, :erf, :erfc, :gamma, :lgamma, :<=>, :module_exec, :class_exec, :<=, :>=, :==, :===, :include?, :included_modules, :ancestors, :name, :public_instance_methods, :instance_methods, :private_instance_methods, :protected_instance_methods, :const_get, :constants, :const_defined?, :const_set, :class_variables, :class_variable_get, :remove_class_variable, :class_variable_defined?, :class_variable_set, :private_constant, :public_constant, :singleton_class?, :deprecate_constant, :freeze, :inspect, :module_eval, :const_missing, :prepend, :method_defined?, :class_eval, :public_method_defined?, :private_method_defined?, :<, :public_class_method, :>, :protected_method_defined?, :private_class_method, :to_s, :autoload, :autoload?, :instance_method, :public_instance_method, :include, :instance_of?, :public_send, :instance_variable_get, :instance_variable_set, :instance_variable_defined?, :remove_instance_variable, :private_methods, :kind_of?, :instance_variables, :tap, :public_method, :singleton_method, :is_a?, :extend, :define_singleton_method, :method, :to_enum, :enum_for, :=~, :!~, :eql?, :respond_to?, :display, :object_id, :send, :nil?, :hash, :class, :singleton_class, :clone, :dup, :itself, :taint, :tainted?, :untaint, :untrust, :trust, :untrusted?, :methods, :protected_methods, :frozen?, :public_methods, :singleton_methods, :!, :!=, :__send__, :equal?, :instance_eval, :instance_exec, :__id__]
#+END_SRC

その次はドット（.）です。

** このドットは何でしょうか？ 

これは、*レシーバ* の *メッセージ* を指定するためのものです。 

*メッセージ* とは何でしょうか？ この例では、sqrt(9)がメッセージになります。

これは「平方根(square root)」の省略形、 sqrtというメソッドにパラメータ
として9を与えて呼び出しています。 このメソッド呼び出しの実行結果は3.0
という値になります。 3 ではないことに気づいたかもしれません。 平方根は
たいてい整数にならないためです。 そのため、このメソッドは必ず小数（浮
動小数点数）を返します。


** 実行結果を変数に代入

#+BEGIN_SRC ruby :exports both
a = 3 ** 2

b = 4 ** 2

Math.sqrt(a+b)

#+END_SRC

#+RESULTS:
: => 5.0


** メソッドを定義

#+BEGIN_SRC ruby :exports both :session ruby

def hi
  puts "Hello World!"
end

#+END_SRC

#+RESULTS:
: :hi

=> :hi

** 簡潔で繰り返せるメソッド

それではこのメソッドを何度か実行してみましょう。
#+BEGIN_SRC ruby :exports both :results output :session ruby

hi

#+END_SRC

#+RESULTS:
: Hello World!
: => Hello World!

#+BEGIN_SRC ruby :exports both :results output :session ruby

hi()

#+END_SRC

#+RESULTS:
: Hello World!
: => Hello World!


#+BEGIN_SRC ruby :exports both :session ruby

def hi(name)
 puts "Hello #{name}!"
end

#+END_SRC

#+RESULTS:
: => :hi


** Stringに穴を開ける

#{name}は、文字列に何かを挿入する際のRubyでのやり方です。

ブレースの間にあるものは（もし文字列でなければ）
文字列に変換され、その外側の文字列の中に置き換えられます。このしくみは、
誰かの名前を正しくcapitalizedするのにも使えます。

#+BEGIN_SRC ruby :session ruby :exports both 

 def hi(name = "World")
 puts "Hello #{name.capitalize}!"
 end

#+END_SRC

#+RESULTS:
: => :hi

#+BEGIN_SRC ruby :exports both :session ruby :results output

hi "chris"

#+END_SRC

#+RESULTS:
: Hello Chris!
: => nil

#+BEGIN_SRC ruby :exports both :session ruby :results output

hi 

#+END_SRC

#+RESULTS:
: Hello World!
: => nil

- カッコなしでメソッド呼び出しが使われていることです。何をやっているか
  明確であれば、カッコは省略できます。

- デフォルト引数のWorldです。

** 挨拶人(Greeter)への進化

本物の挨拶人がいたのなら、あなたの名前を覚えてくれる上、歓迎し、いつで
も丁重に扱ってくれるでしょう。そのためにオブジェクトを使いたくなりそう
です。“Greeter”クラスを作ってみましょう。

#+BEGIN_SRC ruby :exports both :session ruby

 class Greeter
   def initialize(name = "World")
     @name = name
   end
   def say_hi
     puts "Hi #{@name}!"
   end
   def say_bye
     puts "Bye #{@name}, come back soon."
   end
 end

#+END_SRC

#+RESULTS:
: :say_bye

#+BEGIN_SRC ruby :session ruby :results output
Greeter.superclass
(Greeter.superclass).methods
Greeter.ancestors
Greeter.class
(Greeter.class).ancestors

'end'


#+END_SRC

#+RESULTS:
: => Object
: => [:new, :allocate, :superclass, :<=>, :module_exec, :class_exec, :<=, :>=, :==, :===, :include?, :included_modules, :ancestors, :name, :public_instance_methods, :instance_methods, :private_instance_methods, :protected_instance_methods, :const_get, :constants, :const_defined?, :const_set, :class_variables, :class_variable_get, :remove_class_variable, :class_variable_defined?, :class_variable_set, :private_constant, :public_constant, :singleton_class?, :deprecate_constant, :freeze, :inspect, :module_eval, :const_missing, :prepend, :method_defined?, :class_eval, :public_method_defined?, :private_method_defined?, :<, :public_class_method, :>, :protected_method_defined?, :private_class_method, :to_s, :autoload, :autoload?, :instance_method, :public_instance_method, :include, :instance_of?, :public_send, :instance_variable_get, :instance_variable_set, :instance_variable_defined?, :remove_instance_variable, :private_methods, :kind_of?, :instance_variables, :tap, :public_method, :singleton_method, :is_a?, :extend, :define_singleton_method, :method, :to_enum, :enum_for, :=~, :!~, :eql?, :respond_to?, :display, :object_id, :send, :nil?, :hash, :class, :singleton_class, :clone, :dup, :itself, :taint, :tainted?, :untaint, :untrust, :trust, :untrusted?, :methods, :protected_methods, :frozen?, :public_methods, :singleton_methods, :!, :!=, :__send__, :equal?, :instance_eval, :instance_exec, :__id__]
: => [Greeter, Object, Kernel, BasicObject]
: => Class
: => [Class, Module, Object, Kernel, BasicObject]

*** 新しいキーワードはclassです。

これはGreeterという新しいクラスと、そのクラスのメソッドをいくつか定義
しています。

また、@nameにも気づいたかもしれません。これは
インスタンス変数で、このクラスにある全てのメソッドで使うことができます。

見ての通り、say_hi と say_byeで使われています。

さて、どうすればこのGreeterクラスを動かせるでしょうか？


** オブジェクトを作りましょう。

#+BEGIN_SRC ruby :session ruby

greeter = Greeter.new("Paul")


#+END_SRC

#+RESULTS:
: #<Greeter:0x007f5a42934ee8 @name="Paul">


#+BEGIN_SRC ruby :session ruby

greeter = Greeter.new("Mary")

#+END_SRC

#+RESULTS:
: #<Greeter:0x007f5a427447a0 @name="Mary">

#+BEGIN_SRC ruby :session ruby :exports both :results code

Greeter.instance_methods(false)

#+END_SRC

#+RESULTS:
#+BEGIN_SRC ruby
[:say_hi, :say_bye]
#+END_SRC

initialize メソッドが，(public) instance_methods に現れないのは，
initialize メソッドは自動的に private になるため


#+BEGIN_SRC ruby :session ruby :exports both :results code

Greeter.private_instance_methods(false)

#+END_SRC

#+RESULTS:
#+BEGIN_SRC ruby
[:initialize]
#+END_SRC


*** respond_to? 

返事がもらえるか

#+BEGIN_SRC ruby :session ruby :exports both :results code

greeter.respond_to?("name")

#+END_SRC

#+RESULTS:
#+BEGIN_SRC ruby
false
#+END_SRC

後から，name メソッドを追加 (できる)

#+BEGIN_SRC ruby :session ruby :exports both :results code
class Greeter
  def name
    @name
  end
end

#+END_SRC

#+RESULTS:
#+BEGIN_SRC ruby
:name
#+END_SRC

#+BEGIN_SRC ruby :session ruby :exports both :results code

greeter.respond_to?("name")

#+END_SRC

#+RESULTS:
#+BEGIN_SRC ruby
true
#+END_SRC


*** ruby スクリプト

#+BEGIN_SRC ruby :tangle ri20min.rb
#,!/usr/bin/env ruby
#, coding:utf-8
class Greeter
  def initialize(name = "World")
     @name = name
  end
  def say_hi
    puts "Hi #{@name}!"
  end
  def say_bye
    puts "Bye #{@name}, come back soon."
  end
end

class MegaGreeter
  attr_accessor :names

  #create the object
  def initialize(names="world")
    @name = names
  end

  #say hi to everybody
  def say_hi
    if @names.nil?
      puts "..."
    elsif @names.respond_to?("each")
      # @names is a list some kind, iterate!
      @names.each do |name|
        puts "Hello #{name}!"
      end
    else
      puts "Hello #{@names}!"
    end

    #say bye to everybody
    def say_bye
      if @names.nil?
        puts "..."
      elsif @names.respond_to?("join")
      # Join the list elements with commas
        puts "Goodby #{@names.join(", ")}. come back soon!"
      else
        puts "Goodby #{@names}. come back soon!"
      end
    end
  end
end


if __FILE__ == $0

  # スクリプトとして実行されている場合

  mg = MegaGreeter.new
  mg.say_hi
  mg.say_bye

  mg.names = "zeke"
  mg.say_hi
  mg.say_bye

  mg.names = ["Albert", "Brenda", "Charles"]
  mg.say_hi
  mg.say_bye

end
#+END_SRC

#+RESULTS:


#+BEGIN_SRC ruby :session ruby :results output

["a","b","c"].class
(["a","b","c"]).respond_to?(:each)
["a","b","c"].each
["a","b","c"].each do |elem| 
   puts elem
end

'end'

#+END_SRC

#+RESULTS:
: 
: => Array
: => true
: => #<Enumerator: ["a", "b", "c"]:each>
: irb(main):096:1* irb(main):097:1> a
: b
: c
: => ["a", "b", "c"]

* メタな視点

** 見えるもの
 
- オブジェクト，クラス，メソッド がある

- すべて，メッセージングで行なわれること
  - あるクラスのインスタンスを作ることも

クラス
- オープン・クラスであること
- クラスが開ける 


* 例題

** file_print.rb

あるファイルの

- 利用クラスライブラリ: File<IO
  - File.open, 
  - openされたファイルは，IOとして扱える
  - IO.read, 

#+BEGIN_SRC ruby :tangle ~suzuki/rubys/examples/file_print.rb :mkdirp yes

def file_print(file_name)
  File.open(file_name) do |io|
    print (io.read)
  end
end

if __FILE__==$0

  ARGV.each do |file|
    file_print(file)
  end

end

#+END_SRC






** home_directory.rb

#+BEGIN_SRC ruby :tangle ~suzuki/rubys/examples/home_directory.rb :results output raw :export both

def home_directory()
  home_path = File.expand_path("~")
  Dir.chdir(home_path) do 
    Dir.glob("*").each do |file|
       p file
    end
  end
end

home_directory

if __FILE__==$0

  ARGV.each do |file|
    file_print(file)
  end

end

#+END_SRC


** shuzo_meigen.rb

   [[http://qiita.com/seiya1121/items/3dde2dae7319fe261323][Nokogiriで簡単なWebスクレイピング - Qiita]] を参考に
   

#+BEGIN_SRC ruby :tangle ~suzuki/rubys/examples/shuzo_meigen.rb :results output raw :exports both

# coding:utf-8
require 'open-uri' 
require 'nokogiri' 

# URL，変更しました ((s-:))
url = 'http://earth-words.org/archives/2746' 
charset = nil

html = open(url) do |f|
  charset = f.charset 
  f.read 
end

# htmlを解析し、オブジェクト化
page = Nokogiri::HTML.parse(html, nil, charset) 

# 名言は<blockquote>タグに囲まれている
shuzo_meigen = page.search('blockquote') 

# shuzo_meigenで取得したデータをテキストに変換
shuzo_meigen.each do |phrase|
  print phrase.text.gsub("\r",'')
end

#+END_SRC

#+RESULTS:

一番になるっていったよな？
日本一なるっつったよな！ 
ぬるま湯なんか
つかってんじゃねぇよお前！！

100回叩くと
壊れる壁があったとする。
でもみんな何回叩けば
壊れるかわからないから、
90回まで来ていても
途中であきらめてしまう。

諦めんなよ!
諦めんなよ、お前！！ 
どうしてそこでやめるんだ、
そこで！！
もう少し頑張ってみろよ！ 
ダメダメダメ!諦めたら!
周りのこと思えよ、
応援してる人たちのこと
思ってみろって!
あともうちょっとの
ところなんだから!

本気になれば自分が変わる！ 
本気になれば全てが変わる！！

過去のことを
思っちゃダメだよ。
何であんなことしたんだろ…
って怒りに変わってくるから。 
未来のことも思っちゃダメ。
大丈夫かな、あはぁ～ん。 
不安になってくるでしょ？ 
ならば、一所懸命、
一つの所に命を懸ける！ 
そうだ！今ここを生きていけば、
みんなイキイキするぞ！！

もっと熱くなれよ…!!
熱い血燃やしてけよ…!!
人間熱くなったときが
ホントの自分に出会えるんだ！

言い訳してるんじゃないですか？ 
できないこと、無理だって、
諦めてるんじゃないですか？ 
駄目だ駄目だ！
あきらめちゃだめだ！ 
できる！できる！
絶対にできるんだから！

よく、時間が解決してくれる
と言うけれど、そうは思わない。
でも、行動した時間なら
解決してくれるはずだ。

わがままではなく、
あるがままに。

悔しがればいい、
泣けばいい、喜べばいい。
それが人間だ！

君が次に叩く１回で、
壁は打ち破れる
かもしれないんだ！

真剣に考えても、
深刻になるな！

反省はしろ！
後悔はするな！

勝ち負けなんか、
ちっぽけなこと。
大事なことは、
本気だったかどうかだ！

心の底から好きなことに
本気で取り組めるなら、
それは幸せ。

何よりも大切なのは、
あなた自身がどうしたいかだ。

家族は
　史上最強の味方だ！

一所懸命生きていれば、
不思議なことに疲れない。

勝敗を分けるのは
いつでもたった一球だ。
だが、プレーをしているときは、
どれがその一球か分からない。

偶然にもうまく
返せたように見える一球。
しかし、僕にとっては
何千球と練習をしたうちの一球だ。
