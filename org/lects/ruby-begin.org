* 20分で始める Ruby の のーと

** インタラクティブRuby

irb の起動

: % irb
: irb(main):001:0>
<sTAB

#+BEGIN_SRC ruby :exports both

"Hello World"

#+END_SRC

#+RESULTS:
: Hello World

IRBが最後の式を実行した結果
を教えてくれている。 

"Hello World"と出力したいのであれば

#+BEGIN_SRC ruby :results output :exports both

puts "Hello World"

#+END_SRC

#+RESULTS:
: Hello World
: => nil

putsはRubyで何かを出力する基本的なコマンドです。 

=> nilは, このコマンドの評価結果です。 putsは必ずnilを返します。nil
は、「まったく何もない」ことを表すRubyの「値」です。

#+BEGIN_SRC ruby :exports both

3+2

#+END_SRC

#+RESULTS:
: => 5

#+BEGIN_SRC ruby :exports both

3*2

#+END_SRC

#+RESULTS:
: => 6

#+BEGIN_SRC ruby :exports both

3**2
#+END_SRC

#+RESULTS:
: => 9

平方根(square root)を求めるにはMathモジュールを使う:

#+BEGIN_SRC ruby :exports both

Math.sqrt(9)

#+END_SRC

#+RESULTS:
: =>3.0

** Math は一体なんでしょうか？

Math は数学のためのビルトインモジュール(標準で組み込まれているモジュー
ル)です。

#+BEGIN_SRC ruby :exports both

Math.class

#+END_SRC

#+RESULTS:
: Module

Rubyでは、モジュールには2通りの役割があります。これはその1つ目の役割、
関連するメソッドを馴染みのある名前でグループ化するものです。Math は
sin() や tan() といったメソッドも持っています。

#+BEGIN_SRC ruby :exports both :results code

(Math.methods)

#+END_SRC

#+RESULTS:
#+BEGIN_SRC ruby
[:atan2, :cos, :sin, :tan, :acos, :asin, :atan, :cosh, :sinh, :tanh, :acosh, :asinh, :atanh, :exp, :log, :log2, :log10, :sqrt, :cbrt, :frexp, :ldexp, :hypot, :erf, :erfc, :gamma, :lgamma, :<=>, :module_exec, :class_exec, :<=, :>=, :==, :===, :include?, :included_modules, :ancestors, :name, :public_instance_methods, :instance_methods, :private_instance_methods, :protected_instance_methods, :const_get, :constants, :const_defined?, :const_set, :class_variables, :class_variable_get, :remove_class_variable, :class_variable_defined?, :class_variable_set, :private_constant, :public_constant, :singleton_class?, :deprecate_constant, :freeze, :inspect, :module_eval, :const_missing, :prepend, :method_defined?, :class_eval, :public_method_defined?, :private_method_defined?, :<, :public_class_method, :>, :protected_method_defined?, :private_class_method, :to_s, :autoload, :autoload?, :instance_method, :public_instance_method, :include, :instance_of?, :public_send, :instance_variable_get, :instance_variable_set, :instance_variable_defined?, :remove_instance_variable, :private_methods, :kind_of?, :instance_variables, :tap, :public_method, :singleton_method, :is_a?, :extend, :define_singleton_method, :method, :to_enum, :enum_for, :=~, :!~, :eql?, :respond_to?, :display, :object_id, :send, :nil?, :hash, :class, :singleton_class, :clone, :dup, :itself, :taint, :tainted?, :untaint, :untrust, :trust, :untrusted?, :methods, :protected_methods, :frozen?, :public_methods, :singleton_methods, :!, :!=, :__send__, :equal?, :instance_eval, :instance_exec, :__id__]
#+END_SRC

その次はドット（.）です。

** このドットは何でしょうか？ 

これは、*レシーバ* の *メッセージ* を指定するためのものです。 

*メッセージ* とは何でしょうか？ この例では、sqrt(9)がメッセージになります。

これは「平方根(square root)」の省略形、 sqrtというメソッドにパラメータ
として9を与えて呼び出しています。 このメソッド呼び出しの実行結果は3.0
という値になります。 3 ではないことに気づいたかもしれません。 平方根は
たいてい整数にならないためです。 そのため、このメソッドは必ず小数（浮
動小数点数）を返します。


** 実行結果を変数に代入

#+BEGIN_SRC ruby :exports both
a = 3 ** 2

b = 4 ** 2

Math.sqrt(a+b)

#+END_SRC

#+RESULTS:
: => 5.0


** メソッドを定義

#+BEGIN_SRC ruby :exports both :session ruby

def hi
  puts "Hello World!"
end

#+END_SRC

#+RESULTS:
: :hi

=> :hi

** 簡潔で繰り返せるメソッド

それではこのメソッドを何度か実行してみましょう。
#+BEGIN_SRC ruby :exports both :results output :session ruby

hi

#+END_SRC

#+RESULTS:
: Hello World!
: => Hello World!

#+BEGIN_SRC ruby :exports both :results output :session ruby

hi()

#+END_SRC

#+RESULTS:
: Hello World!
: => Hello World!


#+BEGIN_SRC ruby :exports both :session ruby

def hi(name)
 puts "Hello #{name}!"
end

#+END_SRC

#+RESULTS:
: => :hi


** Stringに穴を開ける

#{name}は、文字列に何かを挿入する際のRubyでのやり方です。

ブレースの間にあるものは（もし文字列でなければ）
文字列に変換され、その外側の文字列の中に置き換えられます。このしくみは、
誰かの名前を正しくcapitalizedするのにも使えます。

#+BEGIN_SRC ruby :session ruby :exports both 

 def hi(name = "World")
 puts "Hello #{name.capitalize}!"
 end

#+END_SRC

#+RESULTS:
: => :hi

#+BEGIN_SRC ruby :exports both :session ruby :results output

hi "chris"

#+END_SRC

#+RESULTS:
: Hello Chris!
: => nil

#+BEGIN_SRC ruby :exports both :session ruby :results output

hi 

#+END_SRC

#+RESULTS:
: Hello World!
: => nil

- カッコなしでメソッド呼び出しが使われていることです。何をやっているか
  明確であれば、カッコは省略できます。

- デフォルト引数のWorldです。

** 挨拶人(Greeter)への進化

本物の挨拶人がいたのなら、あなたの名前を覚えてくれる上、歓迎し、いつで
も丁重に扱ってくれるでしょう。そのためにオブジェクトを使いたくなりそう
です。“Greeter”クラスを作ってみましょう。

#+BEGIN_SRC ruby :exports both :session ruby

 class Greeter
   def initialize(name = "World")
     @name = name
   end
   def say_hi
     puts "Hi #{@name}!"
   end
   def say_bye
     puts "Bye #{@name}, come back soon."
   end
 end

#+END_SRC

#+RESULTS:
: :say_bye

#+BEGIN_SRC ruby :session ruby :results output
Greeter.superclass
(Greeter.superclass).methods
Greeter.ancestors
Greeter.class
(Greeter.class).ancestors

'end'


#+END_SRC

#+RESULTS:
: => Object
: => [:new, :allocate, :superclass, :<=>, :module_exec, :class_exec, :<=, :>=, :==, :===, :include?, :included_modules, :ancestors, :name, :public_instance_methods, :instance_methods, :private_instance_methods, :protected_instance_methods, :const_get, :constants, :const_defined?, :const_set, :class_variables, :class_variable_get, :remove_class_variable, :class_variable_defined?, :class_variable_set, :private_constant, :public_constant, :singleton_class?, :deprecate_constant, :freeze, :inspect, :module_eval, :const_missing, :prepend, :method_defined?, :class_eval, :public_method_defined?, :private_method_defined?, :<, :public_class_method, :>, :protected_method_defined?, :private_class_method, :to_s, :autoload, :autoload?, :instance_method, :public_instance_method, :include, :instance_of?, :public_send, :instance_variable_get, :instance_variable_set, :instance_variable_defined?, :remove_instance_variable, :private_methods, :kind_of?, :instance_variables, :tap, :public_method, :singleton_method, :is_a?, :extend, :define_singleton_method, :method, :to_enum, :enum_for, :=~, :!~, :eql?, :respond_to?, :display, :object_id, :send, :nil?, :hash, :class, :singleton_class, :clone, :dup, :itself, :taint, :tainted?, :untaint, :untrust, :trust, :untrusted?, :methods, :protected_methods, :frozen?, :public_methods, :singleton_methods, :!, :!=, :__send__, :equal?, :instance_eval, :instance_exec, :__id__]
: => [Greeter, Object, Kernel, BasicObject]
: => Class
: => [Class, Module, Object, Kernel, BasicObject]

*** 新しいキーワードはclassです。

これはGreeterという新しいクラスと、そのクラスのメソッドをいくつか定義
しています。

また、@nameにも気づいたかもしれません。これは
インスタンス変数で、このクラスにある全てのメソッドで使うことができます。

見ての通り、say_hi と say_byeで使われています。

さて、どうすればこのGreeterクラスを動かせるでしょうか？


** オブジェクトを作りましょう。

#+BEGIN_SRC ruby :session ruby

greeter = Greeter.new("Paul")


#+END_SRC

#+RESULTS:
: #<Greeter:0x007f5a42934ee8 @name="Paul">


#+BEGIN_SRC ruby :session ruby

greeter = Greeter.new("Mary")

#+END_SRC

#+RESULTS:
: #<Greeter:0x007f5a427447a0 @name="Mary">

#+BEGIN_SRC ruby :session ruby :exports both :results code

Greeter.instance_methods(false)

#+END_SRC

#+RESULTS:
#+BEGIN_SRC ruby
[:say_hi, :say_bye]
#+END_SRC

initialize メソッドが，(public) instance_methods に現れないのは，
initialize メソッドは自動的に private になるため


#+BEGIN_SRC ruby :session ruby :exports both :results code

Greeter.private_instance_methods(false)

#+END_SRC

#+RESULTS:
#+BEGIN_SRC ruby
[:initialize]
#+END_SRC


*** respond_to? 

返事がもらえるか

#+BEGIN_SRC ruby :session ruby :exports both :results code

greeter.respond_to?("name")

#+END_SRC

#+RESULTS:
#+BEGIN_SRC ruby
false
#+END_SRC

後から，name メソッドを追加 (できる)

#+BEGIN_SRC ruby :session ruby :exports both :results code
class Greeter
  def name
    @name
  end
end

#+END_SRC

#+RESULTS:
#+BEGIN_SRC ruby
:name
#+END_SRC

#+BEGIN_SRC ruby :session ruby :exports both :results code

greeter.respond_to?("name")

#+END_SRC

#+RESULTS:
#+BEGIN_SRC ruby
true
#+END_SRC


*** ruby スクリプト

#+BEGIN_SRC ruby :tangle ri20min.rb
#,!/usr/bin/env ruby
#, coding:utf-8
class Greeter
  def initialize(name = "World")
     @name = name
  end
  def say_hi
    puts "Hi #{@name}!"
  end
  def say_bye
    puts "Bye #{@name}, come back soon."
  end
end

class MegaGreeter
  attr_accessor :names

  #create the object
  def initialize(names="world")
    @name = names
  end

  #say hi to everybody
  def say_hi
    if @names.nil?
      puts "..."
    elsif @names.respond_to?("each")
      # @names is a list some kind, iterate!
      @names.each do |name|
        puts "Hello #{name}!"
      end
    else
      puts "Hello #{@names}!"
    end

    #say bye to everybody
    def say_bye
      if @names.nil?
        puts "..."
      elsif @names.respond_to?("join")
      # Join the list elements with commas
        puts "Goodby #{@names.join(", ")}. come back soon!"
      else
        puts "Goodby #{@names}. come back soon!"
      end
    end
  end
end


if __FILE__ == $0

  # スクリプトとして実行されている場合

  mg = MegaGreeter.new
  mg.say_hi
  mg.say_bye

  mg.names = "zeke"
  mg.say_hi
  mg.say_bye

  mg.names = ["Albert", "Brenda", "Charles"]
  mg.say_hi
  mg.say_bye

end
#+END_SRC

#+RESULTS:


#+BEGIN_SRC ruby :session ruby :results output

["a","b","c"].class
(["a","b","c"]).respond_to?(:each)
["a","b","c"].each
["a","b","c"].each do |elem| 
   puts elem
end

'end'

#+END_SRC

#+RESULTS:
: 
: => Array
: => true
: => #<Enumerator: ["a", "b", "c"]:each>
: irb(main):096:1* irb(main):097:1> a
: b
: c
: => ["a", "b", "c"]

* メタな視点

** 見えるもの
 
- オブジェクト，クラス，メソッド がある

- すべて，メッセージングで行なわれること
  - あるクラスのインスタンスを作ることも

クラス
- オープン・クラスであること
- クラスが開ける 

* 例題

** file_print.rb

あるファイルの

- 利用クラスライブラリ: File<IO
  - File.open, 
  - openされたファイルは，IOとして扱える
  - IO.read, 

#+BEGIN_SRC ruby :tangle ~suzuki/rubys/examples/file_print.rb :results output raw

def file_print(file_name)
  File.open(file_name) do |io|
    print (io.read)
  end
end

if __FILE__==$0

   file_print("ruby-begin.org")

end

file_print("ruby-begin.org")

#+END_SRC

C-c C-v C-t source code output to file
C-c C-c excute
C-c ' edit 

#+BEGIN_SRC ruby :results output raw

path = File.expand_path("~suzuki")

Dir.chdir(path) do 
  Dir.glob("*").each do |file|
    puts file
  end
end

#+END_SRC

#+BEGIN_SRC ruby :results output :session ruby

string = <<EOF
abc
def
EOF

puts string

PI = 3.14

puts PI

PI = 3.1415

puts PI

#+END_SRC

#+RESULTS:
#+begin_example

irb(main):002:0* irb(main):003:0" irb(main):004:0" irb(main):005:0" => "abc\ndef\n"
irb(main):007:0* abc
def
=> nil
irb(main):009:0* => 3.14
irb(main):011:0* 3.14
=> nil
irb(main):013:0* (irb):13: warning: already initialized constant PI
(irb):9: warning: previous definition of PI was here
=> 3.1415
irb(main):015:0* 3.1415
#+end_example


#+BEGIN_SRC ruby :results output

class MyClass
  PI = 3.14
end

puts MyClass::PI
# puts PI

#+END_SRC

#+RESULTS:
: 3.14


#+BEGIN_SRC ruby :results output

path = File.expand_path("~suzuki")
p (files = Dir.glob("#{path}/*"))
p files.class
p files.size
p files[2..3]
files.each do |file| 
  p file
end

ary = [1, 2, 3, 4]
p ary[6] = 6
p ary
p ary.include?(6)
p ary[2..4]
p ary.join(",")

#+END_SRC

#+RESULTS:

#+BEGIN_SRC ruby :results output

mon = {"Jan" => 1, "Feb" => 2}
p mon["Jan"]
p mon["Feb"]
p mon.size

mon.each do |key,val|
  p "#{key}=#{val}"
end





#+END_SRC

#+RESULTS:
: 1
: 2
: 2
: "Jan=1"
: "Feb=2"


